<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java使用正则表达式仅获取中文]]></title>
    <url>%2FBlog%2FJava%2FJava%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%85%E8%8E%B7%E5%8F%96%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[Java 使用正则表达式获取字符串中的中文,将字母、数字、下划线等去除.字符串为现网电视剧订购series_order Java 代码1234567891011121314public static void main(String[] args) &#123; String jsonStr = "[&#123;\"number\":16,\"name\":\"现网电视剧订购series_order\"&#125;,&#123;\"number\":17,\"name\":\"电影详情页movie_detail\"&#125;,&#123;\"number\":19,\"name\":\"限免专区biz_30127402\"&#125;,&#123;\"number\":19,\"name\":\"综艺详情variety_detail\"&#125;,&#123;\"number\":24,\"name\":\"电视剧记录与收藏series_fav\"&#125;,&#123;\"number\":24,\"name\":\"热门推荐biz_79818028\"&#125;,&#123;\"number\":38,\"name\":\"电影专区biz_17101799\"&#125;,&#123;\"number\":49,\"name\":\"电视剧详情页series_detail\"&#125;,&#123;\"number\":53,\"name\":\"现网电视剧播放series_play\"&#125;,&#123;\"number\":103,\"name\":\"热门推荐biz_87847639\"&#125;]"; List&lt;rank&gt; result = JSONArray.parseArray(jsonStr, rank.class); System.out.println(result); String name = ""; String regex = "[a-zA-Z]"; String[] array = new String[3]; for (rank rank : result) &#123; name = rank.getname(); array = name.split(regex); rank.setname(array[0]); &#125; System.out.println(result.toString());&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Blog</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ext4.2.4上传文件]]></title>
    <url>%2FBlog%2FExt%2FExt4.2.4%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用Ext 4.2.4版本导入.xls、xlsx文件内容到数据库 页面内容12 js 内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Ext.onReady(function () &#123; Ext.create('Ext.window.Window', &#123; id: "importInfo", title: "导入广告平台用户", autoShow: true, modal: true, constrainHeader: true, resizable: false, height: 250, width: 550, layout: "fit", items: [&#123; xtype: 'form', width: 400, bodyPadding: 10, items: [&#123; xtype: 'filefield', name: 'file', fieldLabel: '文件上传', labelWidth: 80, msgTarget: 'side', allowBlank: false, anchor: '100%', buttonText: '选择文件' &#125;], buttons: [&#123; text: '上传', handler: function () &#123; var form = this.up('form').getForm(); if (form.isValid()) &#123; form.submit(&#123; url: '../user/importADInformation.do', method: 'POST', waitMsg: '文件正在上传', success: function (form, action) &#123; Ext.Msg.alert('Success', '广告用户信息导入成功'); Ext.getCmp("importInfo").close(); &#125;, failure: function(form, action)&#123; var result = Ext.JSON.decode(action.response.responseText) Ext.Msg.alert('Failed', result.msg); Ext.getCmp("importInfo").close(); &#125; &#125;); &#125; &#125; &#125;] &#125;] &#125;);&#125;); Java 后端代码123456789101112131415161718--top | --Controller | ---AdvertisingController | --Repository | ---AdvertisingUserDao | --Entity | ---AdvertisingEntity ---AdvertisingModel | --listeners | ---ImportAdvertisingUserExcelListener Controller123456789101112131415161718192021222324252627282930313233343536373839404142@ResponseBody@RequestMapping(value = "importADInformation", consumes = "multipart/*", headers = "content-type=multipart/form-data", method = RequestMethod.POST)@MethodLog(remark = "批量导入用户数据")public Object synchronizationInformation(@RequestParam(value = "file", required = false) MultipartFile file) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put("success", false); // 1. 获取Excel 内容,将Excel转换为List InputStream inputStream = null; try &#123; inputStream = new BufferedInputStream(file.getInputStream()); // 引用 easyexcel jar 代码地址：https://github.com/alibaba/easyexcel/ // 使用 EasyExcel 读取 excel 文件内容,将 excel 转为 List&lt;Object&gt; ImportAdvertisingUserExcelListener excelListener = new ImportAdvertisingUserExcelListener(); // 读excel数据,返回List&lt;Object&gt;.将 地址信息转为 50m 栅格编码,并将结果返回 EasyExcelFactory.readBySax(inputStream, new Sheet(1, 1, AdvertisingModel.class), excelListener); List&lt;Object&gt; data = excelListener.getData(); // 2. 获取入库的List List&lt;AdvertisingEntity&gt; list = JSONArray.parseArray(JSONObject.toJSONString(data), AdvertisingEntity.class); System.out.println(JSONObject.toJSONString(list)); this.advertisingUserDao.batchSave(list); result.put("success", true); result.put("msg", "数据导入成功"); &#125; catch (IllegalArgumentException GDException) &#123; result.put("msg", "文件格式错误"); &#125; catch (IOException e) &#123; result.put("msg", "IO异常"); &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; result.put("msg", "IO异常"); &#125; catch (Exception e) &#123; result.put("msg", "文件类型错误(应为*.xls或*.xlsx)"); e.printStackTrace(); &#125; &#125; return result;&#125; Repository1234567891011121314151617181920public void batchSave(List&lt;AdvertisingEntity&gt; list) &#123; Session session = null; try &#123; session = this.getSession(); Transaction transaction = session.beginTransaction(); for (int i = 0; i &lt; list.size(); i++) &#123; AdvertisingEntity adverst = list.get(i); session.saveOrUpdate(adverst); if (i % 100 == 0) &#123; session.flush(); session.clear(); &#125; &#125; transaction.commit(); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Ext</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Ext 4.2.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ext3.4.x上传文件]]></title>
    <url>%2FBlog%2FExt%2FExt3.4.x%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用Ext 3.4.x版本实现上传.txt文件(文件内为id值),删除table_a对应记录 要求: 上传一个txt文件,根据文件内的id删除对应的记录。 需求分析: 使用 Ext 3.4.0 上传文件; Java 解析前端上传的文件,得到待删除 List&lt;Long&gt;; 使用 jdbctemplate 批量删除接口,完成删除操作。 js 页面(表单代码)页面出现连个按钮123456789101112131415161718192021222324252627282930313233&lt;style type=text/css&gt;.upload-icon &#123; background: url('../images/image_add.png') no-repeat 0 0 !important;&#125;.x-form-file-wrap &#123; position: relative; height: 22px;&#125;.x-form-file-wrap .x-form-file &#123; position: absolute; right: 0; -moz-opacity: 0; filter: alpha(opacity : 0); opacity: 0; z-index: 2; height: 22px;&#125;.x-form-file-wrap .x-form-file-btn &#123; position: absolute; right: 0; z-index: 1;&#125;.x-form-file-wrap .x-form-file-text &#123; position: absolute; left: 0; z-index: 3; color: #777;&#125;&lt;/style&gt; 文件类型不支持,需要引用fileuploadfield组件 css 文件内容 12345678910111213141516171819202122232425262728293031323334.upload-icon &#123; // 文件路径需要根据自己需要调整 // 这张为 ext 图片上传png /* https://docs.sencha.com/extjs/4.2.4/extjs-build/examples/shared/icons/fam/image_add.png */ background: url('../images/image_add.png') no-repeat 0 0 !important;&#125;.x-form-file-wrap &#123; position: relative; height: 22px;&#125;.x-form-file-wrap .x-form-file &#123; position: absolute; right: 0; -moz-opacity: 0; filter: alpha(opacity : 0); opacity: 0; z-index: 2; height: 22px;&#125;.x-form-file-wrap .x-form-file-btn &#123; position: absolute; right: 0; z-index: 1;&#125;.x-form-file-wrap .x-form-file-text &#123; position: absolute; left: 0; z-index: 3; color: #777;&#125; js 文件内容 以下 javascript 代码的样式可以自己修改,主要内容是 xtype : &#39;fileuploadfield&#39;、xtype:&#39;button&#39;。同时,提交方式也可以自行替换(Ajax等) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Ext.onReady(function () &#123; var fileForm = new Ext.FormPanel(&#123; title: '删除H码文件', frame: true, fileUpload: true, // required parameter collapsible: true, region: 'north', labelWidth: 40, height: 100, width: '100%', margins: '0 120', items: [&#123; layout: 'form', border: false, items: [&#123; items: &#123; labelWidth: 100, xtype: 'fieldset', labelAlign: 'right', autoHeight: true, items: [&#123; xtype: 'panel', layout: 'column', border: false, items: [&#123; layout: 'column', border: false, items: [&#123; layout: 'form', items: [&#123; xtype: 'fileuploadfield', // 需要引用 fileuploadfield.js文件 id: 'form-file', width: 200, emptyText: '请选择一个文件', fieldLabel: '删除H码文件', buttonText: '', name: 'hcodeFile', buttonCfg: &#123; iconCls: 'upload-icon' &#125; &#125;] &#125;, &#123; layout: 'form', items: [&#123; layout: 'form', xtype: 'button', text: '上传', width: 50, style:&#123; marginLeft: '20px' &#125;, handler: function () &#123; if (fileForm.getForm().isValid()) &#123; var filename = Ext.getCmp('form-file').getValue(); if (filename.indexOf('txt') &gt; -1) &#123; &#125; else &#123; msg('错误', '上传的文件不是txt文件类型,请重新选择!'); return; &#125; fileForm.getForm().submit(&#123; url: '../delete',// 请求 API 地址 waitMsg: '正在上传...', waitTitle: '请等待', success: function (form, action) &#123; msg('提示', action.result.msg); fileForm.getForm().reset(); // 刷新表格数据 // gridReload(); &#125;, failure: function (form, action) &#123; msg('错误', action.result.msg); fileForm.getForm().reset(); // 刷新表格数据 // gridReload(); &#125; &#125;); &#125; &#125; &#125;] &#125;] &#125;] &#125;] &#125; &#125;] &#125;] &#125;); // 提示框内容 var msg = function (title, msg) &#123; Ext.Msg.show(&#123; title: title, msg: msg, minWidth: 200, modal: true, icon: Ext.Msg.INFO, buttons: Ext.Msg.OK &#125;); &#125;;&#125;); 文件上传 Java 后端代码Controller —— 获取传递的参数,获取文件123456789101112131415161718import org.springframework.web.multipart.MultipartFile;@RequestMapping(value = "delet", method = RequestMethod.POST)public void deleteHcode(@RequestParam("hcodeFile") MultipartFile hcodeFile, HttpServletResponse response) throws IOException &#123; // 设置 response.setCharsetEncoding("utf-8") 时在当前代码中依然无效,所以改为设置 ContentType response.setContentType("text/html;charset=utf-8"); // Service 中的方法名 Map&lt;String, Object&gt; result = this.hcodeService.removeHcodeList(hcodeFile); // 返回 JSON 时,前端显示异常.需要改为 PrintWiter PrintWriter out = response.getWriter(); out.write("&#123;success:" + result.get("success") + ",msg:'" + result.get("msg") + "'&#125;"); out.flush(); out.close();&#125; Service —— 将 file 转为 list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.springframework.web.multipart.MultipartFile;public Map&lt;String, Object&gt; removeHcodeList(MultipartFile file) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put("success", false); try &#123; // 获取上传 H码文件中的 hcode list List&lt;Long&gt; hcodeList = this.readHcodeFile(file); hcodeDao.removeHcodeList(hcodeList); result.put("success", true); result.put("msg", "删除成功"); &#125; catch (IllegalArgumentException fileException) &#123; result.put("msg", "删除失败,文件内容错误,请检查文件的准确性..."); &#125; catch (IOException e) &#123; result.put("msg", "删除失败,系统IO异常,请稍后重试"); &#125; catch (Exception e) &#123; result.put("msg", "删除失败,系统异常,请稍后重试"); e.printStackTrace(); &#125; return result;&#125;/** * * @Title: readHcodeFile * @Description: 读取文件的方式可以根据文件内容进行调整 * @param file(*.txt 文件) * @return * Set&lt;Long&gt; * @throws IOException */private List&lt;Long&gt; readHcodeFile(MultipartFile file) throws IOException &#123; InputStreamReader reader = null; BufferedReader br = null; try &#123; reader = new InputStreamReader(file.getInputStream(), "UTF-8"); br = new BufferedReader(reader); Set&lt;Long&gt; hcodeList = new HashSet&lt;Long&gt;(); String line = ""; while ((line = br.readLine()) != null &amp;&amp; line.length() &gt; 1) &#123; line = line.trim(); if (line == null) &#123; continue; &#125; hcodeList.add(Long.parseLong(line)); hcodeList.add(Long.parseLong(line)); &#125; return new ArrayList&lt;Long&gt;(hcodeList); &#125; catch (Exception e) &#123; throw new IllegalArgumentException("文件内容错误"); &#125; finally &#123; reader.close(); br.close(); &#125;&#125; 注： 当前方法读取的文件如下图所示 Repository 批量删除的方法 —— jdbctemplae 方式12345678910111213141516171819import org.springframework.jdbc.core.BatchPreparedStatementSetter;public void removeHcodeList(final List&lt;Long&gt; hcodeList) &#123; String sql = "delete from table_a t where t.hcode = ?"; // batchUpdate 为批量操作方法 this.getJdbcTemplate().batchUpdate(sql, new BatchPreparedStatementSetter() &#123; @Override public void setValues(PreparedStatement preparedstatement, int i) throws SQLException &#123; Long hcode = hcodeList.get(i); preparedstatement.setLong(1, hcode); &#125; @Override public int getBatchSize() &#123; return hcodeList.size(); &#125; &#125;);&#125; 常见异常 不支持文件上传 1org.springframework.web.bind.MissingServletRequestParameterException: Required MultipartFile parameter 'hcodeFile' is not present 方法: 在 applicationContext.xml 文件中实例化 bean,添加如下内容 1234&lt;!-- 支持文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>Ext</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Ext 3.4.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面跳转url传参的参数获取]]></title>
    <url>%2FBlog%2FHTML%2F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%ACurl%E4%BC%A0%E5%8F%82%E7%9A%84%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[页面跳转url传参的参数获取 #]]></content>
      <categories>
        <category>Blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图获取行政区边界坐标]]></title>
    <url>%2FBlog%2FHTML%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E8%8E%B7%E5%8F%96%E8%A1%8C%E6%94%BF%E5%8C%BA%E8%BE%B9%E7%95%8C%E5%9D%90%E6%A0%87%2F</url>
    <content type="text"><![CDATA[百度地图获取行政区边界坐标 输入行政区名称,获取相应的行政区边界坐标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no" /&gt; &lt;style type="text/css"&gt; body, html, #allmap &#123; width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "微软雅黑"; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ed696RjHQMSM2nBkDDFFuXtV"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.js"&gt;&lt;/script&gt; &lt;title&gt;添加行政区划&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="getCity" style="margin: 1% 40%;"&gt; &lt;input type="text" placeholder="请输入行政区名字" /&gt; &lt;button id="city"&gt;获取行政区边界坐标&lt;/button&gt; &lt;/div&gt; &lt;div id="allmap"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; // 百度地图API功能 var map = new BMap.Map("allmap"); map.centerAndZoom(new BMap.Point(116.403765, 39.914850), 5); map.enableScrollWheelZoom(); $('#city').click(function() &#123; var city = $(':input').val(); var bdary = new BMap.Boundary(); bdary.get(city, function(rs) &#123; //获取行政区域 map.clearOverlays(); //清除地图覆盖物 var count = rs.boundaries.length; //行政区域的点有多少个 if(count === 0) &#123; alert('未能获取当前输入行政区域'); return; &#125; var pointArray = []; for(var i = 0; i &lt; count; i++) &#123; var ply = new BMap.Polygon(rs.boundaries[i], &#123; strokeWeight: 2, strokeColor: "#ff0000" &#125;); //建立多边形覆盖物 var str = JSON.stringify(ply.ia); //将BMap获取的行政区边界经纬度转为字符串 spiltStr(str); map.addOverlay(ply); //添加覆盖物 pointArray = pointArray.concat(ply.getPath()); &#125; map.setViewport(pointArray); //调整视野 &#125;); &#125;); //字符串封装为json function spiltStr(city) &#123; //console.log(city+'---') var str = "121.34277300108,31.300726938605;121.34023490295,31.30656768649;121.34101430412,31.321852305581;121.34532986852,31.32373744307;121.34507562469,31.326325179418;121.34279680099,31.327430729214;121.33368722478,31.352486594706;121.32863323993,31.355946076452;121.3306342856,31.389518049891;121.32683032531,31.41448550211;121.33644426228,31.420048486776;121.33796679321,31.419826266008;121.33974283911,31.427986737928;121.33898864558,31.440913595385;121.33444416932,31.453434852669;121.32712127167,31.459698918395;121.32359337774,31.475180614573;121.31526712011,31.489321129362;121.31449534014,31.502646507446;121.29513460234,31.511763775428;121.28658896966,31.509453948404;121.27854782016,31.503306859672;121.25459705023,31.498569551283;121.21061795124,31.479894989687;121.20080623465,31.473441396056;121.19227370437,31.461329066124;121.18074389625,31.455132109974;121.17248676891,31.457784975575;121.15417124487,31.449591888376;121.15190698691,31.44485092269;121.16995564339,31.438369269356;121.15641170403,31.42808158186;121.16368200305,31.418036455773;121.15615209913,31.408916433233;121.15389894579,31.396855643986;121.14636752368,31.389519869487;121.1216241984,31.381207905131;121.126436312,31.375522857236;121.11327467502,31.372544843095;121.11504878311,31.358515688821;121.12543166,31.355738088985;121.12517943556,31.350576427542;121.13706169265,31.348468587078;121.13626008815,31.30993641992;121.14684967884,31.308793560918;121.15113791549,31.315474234933;121.16066357022,31.29917558545;121.16692386311,31.291073907869;121.16166696203,31.285625519425;121.16718195826,31.276446521814;121.17544355574,31.279163976083;121.18898716896,31.263877724792;121.20505391684,31.260119976477;121.21562156159,31.267376880475;121.27097267115,31.262577404004;121.27425078362,31.26044885246;121.29337239048,31.249760859417;121.29940623897,31.238478630296;121.32079145614,31.233202075819;121.34077824014,31.238325554883;121.34559319768,31.244083837124;121.3549768665,31.248019413486;121.36690797737,31.246319504389;121.37222869771,31.253136099939;121.3863911862,31.256071762754;121.3808205898,31.26662893588;121.36689179338,31.268484647818;121.36561439598,31.274102752167;121.35038733712,31.278662550346;121.34277300108,31.300726938605"; var points = []; $.each(str.split(";"), function(index, value) &#123; var point = &#123;&#125;; point.lng = value.split(',')[0]; point.lat = value.split(',')[1]; points.push(point); &#125;); var data = JSON.stringify(points); if(city == data) &#123; console.log('true'); &#125; //console.log(data); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>BMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 常用函数]]></title>
    <url>%2FBlog%2FSQL%2FSQL%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SQL 常用函数 SQL 常用函数及错误记录 获取sysdate前几个月时间 1234567-- 时间发生在 2019/1/29,查询(ORA-01839:指定月份的日期无效)-- 关键在于其他之前时间查询都没问题,就1月不行.有待解答select to_char(sysdate - interval '11' month, 'yyyy/mm') from dual /* 替代SQL */select to_char(sysdate - interval '11' month, 'yyyy/mm') from dual `]]></content>
      <categories>
        <category>Blog</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pom 文件常用配置]]></title>
    <url>%2FBlog%2FMaven%2FPom%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Pom 文件常用配置 pom.xml 常用的配置值properties123456&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt;&lt;/properties&gt; plugin1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>pom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件详解]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SpringBoot配置文件详解]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery 使用日志]]></title>
    <url>%2FBlog%2FJQuery%2FJquery%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Jquery 使用日志 Jquery 使用笔记文件加载后进行初始化123456789101112131415161718192021222324$(function () &#123; // 本月产品类型 monthTypes(); //本月产品订购次数排名 monthRanked(); //最近24小时订购次数 h24Rank(); //本月产品订购收入排名 mpincomeRank(); /** * 定时刷新数据 */ setInterval(function () &#123; setTimeout(monthTypes(), Math.random() * 100); setTimeout(monthRanked(), Math.random() * 100); setTimeout(h24Rank(), Math.random() * 100); setTimeout(mpincomeRank(), Math.random() * 100); &#125;, 1000 * 60 * 5);&#125;) list遍历 each 1234$.each(result, function(index, item) &#123; // result[index] = item console.log(index);&#125;); map 123result.map(function(item)&#123; console.log(item)&#125;) for 数字滚动插件 GitHub 地址 参照博客数字滚动显示插件地址]]></content>
      <categories>
        <category>Blog</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 使用记录]]></title>
    <url>%2FBlog%2FLinux%2FLinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux 使用记录 Linux 命令使用记录查看已经在使用的端口1netstat -nultp 检查端口是否被占用1netstat -anp|grep 7090 删除文件夹1rm -rf xx 删除文件1rm -f xx.log 查看 tomcat 相关的进程1ps -ef|grep tomcat 查看 tomcat 实时输出日志1tail -f /opt/tomcat/logs/catalina.out 查看内存信息参考地址 12345678[root@CentOS7 apache-tomcat-8.0.52]# cat /proc/cpuinfo | grep &apos;physical id&apos; | uniq -- cpu 个数physical id : 0physical id : 2[root@CentOS7 apache-tomcat-8.0.52]# cat /proc/cpuinfo | grep &apos;cpu cores&apos; | uniq -- cpu 核数cpu cores : 1[root@CentOS7 apache-tomcat-8.0.52]# cat /proc/cpuinfo | grep &apos;model name&apos; | uniq -- cpu 型号model name : Intel(R) Xeon(R) CPU E7-4809 v2 @ 1.90GHz[root@CentOS7 apache-tomcat-8.0.52]# 某个进程 CPU 占用1top -p 8104 Linux 下 Tomcat 开启查看 GC 信息 在 tomcat 的安装目录下,找到 bin/catalina.sh文件 修改前： 1JAVA_OPTS=&apos;-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m&apos; 修改后： 123456# create gc log monitor# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -Xloggc:/opt/apache-tomcat-8.0.52/logs/tomcat_gc.log'# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC']]></content>
      <categories>
        <category>Blog</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 手动部署 war 包]]></title>
    <url>%2FBlog%2FLinux%2FLinux%E9%83%A8%E7%BD%B2war%E5%8C%85%2F</url>
    <content type="text"><![CDATA[执行 shutdown.sh 时关闭 Tomcat 与 进程, XShell 连接 安装 lrzsz yum -y install lrzsz 上传 Tomcat 到 linux 下载 Linux 版本 tomcat 进入官网Tomcat，下载历史版本选择则 Download 中的 Archives选项1https://archive.apache.org/dist/tomcat/tomcat-8/v8.0.52/bin/ 注： 文件夹为 bin 而不是 src 上传文件到 linux 当前目录下 123# rz 打开文件对话框(出现错误)# rz -be 能够正确上传 解压 tomcat 文件 1tar zxvf apache-tomcat-8.0.52.tar.gz 解压xx.tar文件 1tar xvf xx.tar 12进入../bin 目录，执行该命令chmod u+x *.sh 清空catalina.out日志文件 引用linux清空 catalina.out 日志 不需要重启 tomcat 123[root@CDH46 logs]# du -h catalina.out # 查看日志文件大小17M catalina.out [root@CDH46 logs]# &gt;catalina.out # 重定向清空文件 分配 JVM 内存空间，记录 GC 日志 1234567编辑 catalina.sh 文件,增加# create gc log monitor# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -Xloggc:/opt/apache-tomcat-8.0.52/logs/tomcat_gc.log'# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC 指定tomcat依赖的 jdk 版本 找到 catalina.sh 与 setclasspath.sh 文件路径 123[root@cdh02 bin]# pwd/opt/iptvOrder/apache-tomcat-8.0.52/bin[root@cdh02 bin]# vi ./catalina.sh 在catalina.sh文件头部加入以下配置,指定 jdk 及 jre 路径 123# specify jdk versionJAVA_HOME=/usr/java/jdk1.8.0_101JRE_HOME=/usr/java/jdk1.8.0_101/jre shutdown 命令 kill 进程 修改catalina.sh文件 12345export JAVA_HOME=/usr/java/jdk1.8.0_101export JRE_HOME=/usr/java/jdk1.8.0_101/jreexport CATALINA_HOME=/opt/apache-tomcat-8.0.52export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH 修改catalina.sh文件,设置记录CATALINA_PID(catalina.sh) 12345# Get standard environment variablesPRGDIR=`dirname "$PRG"`if [ -z "$CATALINA_PID" ]; then CATALINA_PID=$PRGDIR/CATALINA_PIDfi 注: 设置会在启动时候bin下新建一个CATALINA_PID文件 关闭时候从CATALINA_PID文件找到pid，kill。。。同时删除CATALINA_PID文件 修改shutdown.sh 12345# 这是 8.0.50 版本最后一行exec "$PRGDIR"/"$EXECUTABLE" stop -force "$e@"# 这是 8.5.38 版本最后一行exec "$PRGDIR"/"$EXECUTABLE" stop -force "$@"]]></content>
      <categories>
        <category>Blog</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>War</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 使用笔记]]></title>
    <url>%2FBlog%2FOracle%2FOracle%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Oracle 使用笔记 Oracle使用笔记触发器 查询 t_device表是否有关联触发器,查 all_triggers 表得到 trigger_name select trigger_name from all_triggers where table_name = &#39;XX&#39;; 根据 trigger_name 查询出触发器详细信息 select text from all_source where type = &#39;TRIGGER&#39; AND name = &#39;TR_XXX&#39;; SQL查看CLOB类型内容SQL : select dbms_lob.substr(t.boundary_point) from t_station_boundary t; 说明 :dbms_lob.substr将大文本转换字符类型读出来 引用地址：Oracle的CLOB大数据字段类型 SQL按月份统计数据 引用地址: Oracle按月统计数据 Oracle时间转换为5分钟粒度1234select to_char(watchtime, 'yyyy/MM/dd hh24') || ':' || lpad(floor(to_char(watchtime, 'mi') / 5) * 5, 2, 0) watchtime, num from tm_num_watch order by watchtime asc; Oracle将一个字段拆分为两个字段在同行显示结果12345-- 获取行政区中心点坐标select station_name, regexp_substr(t.central_point, '[^,]+', 1, 1) lat, regexp_substr(t.central_point, '[^,]+', 1, 2) lng from t_station_boundary t; 时间计算查询1234567891011121314-- 相差月份查询select ceil((months_between(sysdate,'26-7月-2014'))) months from dual-- 天数查询select ceil((to_date('2018/5/24','yyyy/mm/dd') - to_date('2014/7/26','yyyy/mm/dd'))) days from dual -- 小时查询select ceil((to_date('2018/5/24', 'yyyy/mm/dd') - to_date('2014/7/26', 'yyyy/mm/dd'))*24) hoursfrom dual;-- 相差时间查询select * from ( (select ceil((months_between(sysdate, '26-7月-2014'))) as "相差月数" from dual)), (select ceil(sysdate - to_date('2014/7/26', 'yyyy/mm/dd')) as "相差天数" from dual), (select ceil((sysdate - to_date('2014/7/26', 'yyyy/mm/dd')) * 24) as "相差小时" from dual); 引用 [Oracle 两个时间相减][oracle_date_difference] [oracle_date_difference][https://blog.csdn.net/redarmy_chen/article/details/7351410] 注： Oracle 两个时间相减默认的是天数; 两个时间相减的差 * 24 是得到的是 小时(hours),依次类推得到的相应的时间差.]]></content>
      <categories>
        <category>Blog</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impala 使用记录]]></title>
    <url>%2FBlog%2FImpala%2FImpala%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[impala 使用记录 impala 使用记录基本命令 进入 impala impala-shell 退出 impala exit; 展示所有表 show tables; 描述表结构 desc table_name; 注: 每个SQL语句结束时需要加 ‘;’,当数据量大时可以使用limit; 查询时尽量使用数据分区字段,可以有效减少查询时间时间]]></content>
      <categories>
        <category>Blog</category>
        <category>Impala</category>
      </categories>
      <tags>
        <tag>Impala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误]]></title>
    <url>%2FBlog%2FIntellij%20IDEA%E8%BF%90%E8%A1%8Cweb%E9%A1%B9%E7%9B%AE%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 错误信息 Intellij IDEA 控制台信息12java.io.FileNotFoundException: Could not resolve XML resource [null] with public ID [-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN], system ID [http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd] and base URI [jar:file:/D:/Code/IDE-workspace/iptvView/target/WEB-INF/lib/standard-1.1.2.jar!/META-INF/c-1_0-rt.tld] to a known, local entity.at org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(LocalResolver.java:155) Chrome 浏览器页面信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP Status 500 - The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationtype Exception reportmessage The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationdescription The server encountered an internal error that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:55) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:277) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:75) org.apache.jasper.compiler.TagLibraryInfoImpl.generateTldResourcePath(TagLibraryInfoImpl.java:250) org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:125) org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:421) org.apache.jasper.compiler.Parser.parseDirective(Parser.java:479) org.apache.jasper.compiler.Parser.parseElements(Parser.java:1435) org.apache.jasper.compiler.Parser.parse(Parser.java:139) org.apache.jasper.compiler.ParserController.doParse(ParserController.java:227) org.apache.jasper.compiler.ParserController.parse(ParserController.java:100) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:201) org.apache.jasper.compiler.Compiler.compile(Compiler.java:358) org.apache.jasper.compiler.Compiler.compile(Compiler.java:338) org.apache.jasper.compiler.Compiler.compile(Compiler.java:325) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:580) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:363) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238) org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:263) org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827) javax.servlet.http.HttpServlet.service(HttpServlet.java:687) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)note The full stack trace of the root cause is available in the Apache Tomcat/8.0.52 logs.Apache Tomcat/8.0.52 项目 xxx/WEB-INF/lib 中不存在相关jar包; 可以从 mavenrepository地址 中找到相应jar包,添加相关依赖到pom.xml文件中并重新编译，查看问题是否解决。 注： 通过添加缺失jar可以解决的就不用往下看了 项目依赖中存在相关依赖,依然无法正常显示页面 找到项目配置的 tomcat 下 xx\apache-tomcat-8.0.52\conf\context.xml文件 修改文件,添加如下内容 &lt;Context xmlBlockExternal=”false” &gt; 注： 只需要添加下划线中的 xmlBlockExternal=&quot;false&quot; 到 Context 标签即可 总结: 出现jsp页面显示错误,一般都是缺少 jar 包所致。可检查在tomcat或编译后的文件夹中是否能够找到相关依赖。 上述异常中缺失的jar有,然而本次并不是缺少jar的错误 1standard-1.1.2.jar、jstl-1.2.jar、jersey-server-1.9.jar、jstl-impl.jar 本博客无法解决疑问时,可简练相关关键字再搜索。 参考博客 新版Tomcat无法解析web.xml]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Intellij IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impala 使用记录]]></title>
    <url>%2FBlog%2FJava%2FResultSet%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[impala 使用记录 大数据量查询,使用 ResultSet 出现 JVM 内存溢出 解决方案 修改前代码 1statement = connection.prepareStatement(sql); 修改后代码 1statement = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Memory Overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误]]></title>
    <url>%2FBlog%2FIntellij%20IDEA%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AEweb.xml%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 背景 intellij IDEA 将应用打成war包可以正常运行及显示 eclipse 使用同样的tomcat | JDK运行正常 intellij IDEA 使用tomcat运行失败 错误信息 Intellij IDEA 控制台信息 12java.io.FileNotFoundException: Could not resolve XML resource [null] with public ID [-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN], system ID [http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd] and base URI [jar:file:/D:/Code/IDE-workspace/iptvView/target/WEB-INF/lib/standard-1.1.2.jar!/META-INF/c-1_0-rt.tld] to a known, local entity.at org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(LocalResolver.java:155) Chrome 浏览器页面信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP Status 500 - The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationtype Exception reportmessage The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationdescription The server encountered an internal error that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:55) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:277) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:75) org.apache.jasper.compiler.TagLibraryInfoImpl.generateTldResourcePath(TagLibraryInfoImpl.java:250) org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:125) org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:421) org.apache.jasper.compiler.Parser.parseDirective(Parser.java:479) org.apache.jasper.compiler.Parser.parseElements(Parser.java:1435) org.apache.jasper.compiler.Parser.parse(Parser.java:139) org.apache.jasper.compiler.ParserController.doParse(ParserController.java:227) org.apache.jasper.compiler.ParserController.parse(ParserController.java:100) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:201) org.apache.jasper.compiler.Compiler.compile(Compiler.java:358) org.apache.jasper.compiler.Compiler.compile(Compiler.java:338) org.apache.jasper.compiler.Compiler.compile(Compiler.java:325) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:580) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:363) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238) org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:263) org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827) javax.servlet.http.HttpServlet.service(HttpServlet.java:687) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)note The full stack trace of the root cause is available in the Apache Tomcat/8.0.52 logs.Apache Tomcat/8.0.52 项目 xxx/WEB-INF/lib 中不存在相关jar包 可以从 mavenrepository地址 中找到相应jar包,添加相关依赖到pom.xml文件中并重新编译，查看问题是否解决。 注： 通过添加缺失jar可以解决的就不用往下看了 项目依赖中存在相关依赖,依然无法正常显示页面 找到项目配置的 tomcat 下 xx\apache-tomcat-8.0.52\conf\context.xml文件 修改文件,添加如下内容 &lt;Context xmlBlockExternal=”false” &gt; 注： 只需要添加下划线中的 xmlBlockExternal=&quot;false&quot; 到 Context 标签即可 总结： 出现jsp页面显示错误,一般都是缺少 jar 包所致。可检查在tomcat或编译后的文件夹中是否能够找到相关依赖。 上述异常中缺失的jar有,然而本次并不是缺少jar的错误 1standard-1.1.2.jar、jstl-1.2.jar、jersey-server-1.9.jar、jstl-impl.jar 本博客无法解决疑问时,可简练相关关键字再搜索。 参考博客 新版Tomcat无法解析web.xml]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Intellij IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell log]]></title>
    <url>%2FBlog%2FShell%2FShell%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Shell log 12345678910111213141516171819202122232425262728#!/bin/bashyou_name="runoob.com";echo "Hello : "$&#123;you_name&#125;;# 只读变量的值不能被改变myUrl="http://www.baidu.com";readonly myUrl;# myUrl="http://runoob.com";# 删除变量unset you_name;echo $&#123;you_name&#125;;# 获取字符串长度string="abcd";echo $&#123;#string&#125;;# 查找子字符串string="runoob is a great site";echo `expr index "$&#123;string&#125;" sg`;# 定义数组track=("min" "mid" "max");track[5]="io流";valuen=$&#123;track[5]&#125;;echo $&#123;valuen&#125;;echo $&#123;#track[@]&#125;;]]></content>
      <categories>
        <category>Blog</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 基础]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SpringBoot 基础 参数校验统一用户认证(token | session)返回结果统一数据库访问多数据源前后端分离(前端页面展示)文件上传(本地 | 七牛云)富文本编辑器分页组件表格、表单]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 配置定时任务]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[SpringBoot 配置定时任务 SpringBoot 创建定时任务要求 * 已创建SpringBoot项目 * JDK 版本 1.8 及以上(非必须) * Maven 版本 3.2+ 添加依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 注: 进行 选中项目右键 &gt; Maven &gt; Update Project 操作后如果 JDK 版本被修改，在pom.xml中添加 1234567891011121314&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 启动类添加注解12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;//定时任务注解@EnableScheduling@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 创建定时任务实现类 定时任务 12345678910111213import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class SyncingTask &#123; private int count = 0; @Scheduled(cron = "*/6 * * * * ?") public void process() &#123; System.out.println("this is scheduler task runing" + (count++)); &#125;&#125; 定时任务 1234567891011121314151617import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class PrintTask &#123; private static final SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() &#123; System.out.println("现在时间：" + sdf.format(new Date())); &#125;&#125; 运行程序即可在控制台看到类似输出 12345678910112018-07-16 16:44:57.045 INFO 9352 --- [ restartedMain] s.a.ScheduledAnnotationBeanPostProcessor : No TaskScheduler/ScheduledExecutorService bean found for scheduled processing现在时间：16:44:572018-07-16 16:44:57.045 INFO 9352 --- [ restartedMain] com.learning.Application : Started Application in 0.49 seconds (JVM running for 0.931)this is scheduler task runing0现在时间：16:45:03this is scheduler task runing1现在时间：16:45:09this is scheduler task runing2现在时间：16:45:15this is scheduler task runing3现在时间：16:45:21 示例可参见官方地址 Scheduling Tasks @Scheduled注解说明 @Scheduled(fixedRate = 5000)：上次开始执行时间点之后5秒再执行 @Scheduled(fixedDelay = 5000)：上次执行完毕时间点之后5秒再执行 @Scheduled(initialDelay = 1000, fixedRate = 5000)：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 @Scheduled(cron = &quot;*/6 * * * * *&quot;)：通过 cron 表达式定义规则]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>EnableScheduling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 图片上传]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[SpringBoot 图片上传 SpringBoot 实现图片上传功能 SpringBoot 是为了简化Spring应用的创建、运行、测试、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本事而不是外部的xml配置，我们只需遵循规范，引入相关的依赖就可以轻易搭建出一个web工程 说明 文件上传控件较多，本文以引用LayUI图片上传控件为例 页面上传插件使用Layui的图片上传控件，点击跳转 文件上传使用JQuery 的Ajax请求对应图片上传API，API返回包含图片路径格式的JSON数据 上传图片路径并非在项目文件夹中，需配置静态资源文件路径 配置文件上传控件 第一步：添加 Layui 的文件上传控件 将Layui库添加进项目的静态资源文件夹中，在src/main/resources/satic文件夹下创建layui文件夹存放Layui库等资源文件; HTML页面引用js及css文件，图片上传控件需要用到的资源有jquery.mini.js/jquery.js、layer.js、layui.js、layui.css。相关资源文件路径需要配置为项目具体引用路径或使用在线配置路径layui，详细内容可到layui官网查看。 初始化插件及样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script type="text/javascript"&gt;layui.use('upload',function() &#123; var $ = layui.jquery, upload = layui.upload; //普通图片上传 var uploadInst = upload.render(&#123; url : '../picture/uploadImg'//图片上传action路径配置 ,data : &#123; folder : 'hotel/' &#125;, before : function(obj) &#123; //预读本地文件示例，不支持ie8 obj.preview(function(index, file, result) &#123; $('#imgSrc').attr('src', result); //图片链接（base64）,显示缩略图 &#125;); &#125;, done : function(data) &#123; if (data.data.message == 'success') &#123; $('#hotelPicture').val( data.data.picUrl);//设置图片相对路径，表单提交时提交图片url return layer.msg('上传成功!') &#125; &#125;, error : function() &#123; //演示失败状态，并实现重传 var demoText = $('#demoText'); demoText .html('&lt;span style="color: #FF5722;"&gt;上传失败&lt;/span&gt; &lt;a class="layui-btn layui-btn-mini demo-reload"&gt;重试&lt;/a&gt;'); demoText.find('.demo-reload').on( 'click', function() &#123; uploadInst.upload(); &#125;); &#125; &#125;);&#125;);&lt;/script&gt;``` ## 修改配置文件 &gt; 第二步: 修改配置文件 ```properties# file write static resource pathweb.upload-path=F:/temp/springboot/spring.mvc.static-path-pattern=/**spring.resources.static-locations=classpath:/templates/,classpath:/META-INF/resources/,classpath:/resources/,\ classpath:/static/,classpath:/public/,file:$&#123;web.upload-path&#125; 注： web.upload-path 为图片保存路径，若使用linux系统部署需要将绝对路径替换为相对路径。 例如： API 接口 第三步：文件上传API 文件上传API待更新 页面显示配置 第四步：图片在前端页面显示路径配置，不配置显示不了图片 1234567891011121314151617181920212223242526272829package cn.com.weiyi.wisdomh.Config;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;public class WebAppConfig extends WebMvcConfigurerAdapter &#123; @Value("$&#123;web.upload-path&#125;") private String imgPath;//application.properties中的文件资源位置 /** * 图片访问方法 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if(imgPath.equals("") || imgPath.equals("$&#123;web.upload-path&#125;"))&#123; String imagesPath = WebAppConfig.class.getClassLoader().getResource("").getPath(); if(imagesPath.indexOf(".jar")&gt;0)&#123; imagesPath = imagesPath.substring(0, imagesPath.indexOf(".jar")); &#125;else if(imagesPath.indexOf("classes")&gt;0)&#123; imagesPath = "file:"+imagesPath.substring(0, imagesPath.indexOf("classes")); &#125; imagesPath = imagesPath.substring(0, imagesPath.lastIndexOf("/"))+"/images/"; imgPath = imagesPath; &#125; LoggerFactory.getLogger(WebAppConfig.class).info("imagesPath="+imgPath); registry.addResourceHandler("/images/**").addResourceLocations(imgPath); super.addResourceHandlers(registry); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>EnableScheduling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合在线API(Swagger2)]]></title>
    <url>%2FSpringBoot%2FSwagger2%2FSpringBoot%E6%95%B4%E5%90%88Swagger2%2F</url>
    <content type="text"><![CDATA[SpringBoot 整合在线API(Swagger2) SpringBoot 整合 Swagger2创建SpringBoot 项目 第一步：创建SpringBoot项目，启动应用看是否能够启动 第二步：修改 pom.xml 为项目增加Swagger2支持 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 配置类 第三步：配置 Swagger2 配置类 12345678910111213141516171819202122232425262728293031@Configuration@EnableSwagger2public class Swagger2 extends WebMvcConfigurerAdapter &#123;//配置需要扫描的注解包路径private String basePackage="com.swagger.learing.controller";@Beanpublic Docket creatRestApi()&#123;return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.basePackage(this.basePackage)).paths(PathSelectors.any()).build();&#125;/*** 文档创建描述* @return*/private ApiInfo apiInfo()&#123;return new ApiInfoBuilder() .title("Spring Boot 使用Swagger2构建RESTful APIS") .description("智慧酒店App相关API") .termsOfServiceUrl("http://127.0.0.1:8070/swagger-ui.html";) .contact(new Contact("JK","http://www.mbntinc.com";,"hui.luo@mbntinc.com")) .version("1.0") .build(); &#125;&#125; 注解说明： @Configuration 声明类为配置类 @EnableSwagger2 用于开启Swagger注解 设置 Controller 层注解 第四步: 为UserVo(返回结果实体)类添加 Swagger2 注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.swagger.learing.domain;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(value = "用户模型实体类")public class UserVo &#123;@ApiModelProperty(value = "账户", required = true)private String account;@ApiModelProperty(value = "姓名", required = true)private String name;@ApiModelProperty(value = "昵称", required = true)private String nickName;public UserVo() &#123;&#125;public UserVo(String account, String name, String nickName) &#123; this.account = account; this.name = name; this.nickName = nickName;&#125;public String getAccount() &#123; return account;&#125;public void setAccount(String account) &#123; this.account = account;&#125;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public String getNickName() &#123; return nickName;&#125;public void setNickName(String nickName) &#123; this.nickName = nickName;&#125;@Overridepublic String toString() &#123; return "UserVo&#123;" + "account='" + account + '\'' + ", name='" + name + '\'' + ", nickName='" + nickName + '\'' + '&#125;'; &#125;&#125; 第五步：为Controller添加 Swagger2 生成在线API文档注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.swagger.learing.controller;import com.alibaba.fastjson.JSON;import com.swagger.learing.domain.UserVo;import io.swagger.annotations.*;import org.springframework.web.bind.annotation.*;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.List;@RestController@RequestMapping("user")@Api("userController相关Api")@EnableSwagger2 // 设置可被swagger识别显示public class UserController &#123; /** * 获取用户list * @param userName * @param password * @return */ @ApiOperation("获取用户相关信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "userName", dataType = "String", required = true, value = "用户的姓名", defaultValue = "张飞"), @ApiImplicitParam(paramType = "query", name = "password", dataType = "String", required = true, value = "用户的密码", defaultValue = "wangga") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "/getUser", method = RequestMethod.POST) public List&lt;UserVo&gt; getUser(@RequestParam("userName") String userName, @RequestParam("password") String password) &#123; System.out.print("logger.in:getUser---------"); UserVo info = new UserVo("test01", "测试账户一", "士兵"); UserVo info2 = new UserVo("test02", "测试账户二", "将领"); UserVo info3 = new UserVo("test03", "测试账户三", "元帅"); List&lt;UserVo&gt; list = new ArrayList&lt;&gt;(); list.add(info); list.add(info2); list.add(info3); return list; &#125; /** * 查询用户详细信息 * @param id * @return */ @ApiOperation(value = "查询用户详细信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "queryUserInfo/&#123;id&#125;", method = RequestMethod.POST) public UserVo queryUserInfo(@PathVariable("id") Long id) &#123; UserVo info = new UserVo("test" + id, "00" + id, "鼠标" + id); return info; &#125; /** * 修改用户信息 * @param id * @param userVo * @return */ @ApiOperation(value = "修改用户信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1"), @ApiImplicitParam(paramType = "body", name = "User", dataType = "User", value = "修改的用户信息") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者跳转页面错误") &#125;) @RequestMapping(value = "modifyUserInfo", method = RequestMethod.POST) public String modifyUserInfo(@RequestParam("id") Long id, @RequestBody UserVo userVo) &#123; System.out.print("-----------modifyUserInfo:" + userVo.toString()); userVo.setAccount(++id + ""); return JSON.toJSONString(userVo); &#125; /** * 删除用户信息 * @param id * @return */ @ApiOperation(value = "删除用户信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径异常,或者跳转页面错误") &#125;) @RequestMapping(value = "delUserById/&#123;id&#125;", method = RequestMethod.DELETE) public String delUserById(@PathVariable(value = "id", required = true) Long id) &#123; System.err.print("-----del"); return "success"; &#125;&#125; 按上述步骤配置，项目启动后访问地址：http://localhost:8080/swagger-ui.html 页面访问效果如下：]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Swagger2</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除 List 中的重复数据]]></title>
    <url>%2FBlog%2FJava%2FJava%E5%AF%B9List%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[去除 List 中的重复数据 从List&lt;Object&gt; 中取相同列，转为另一个list123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142private static List&lt;UserUrl&gt; initData() &#123; List&lt;UserUrl&gt; list = new ArrayList&lt;&gt;(); UserUrl url = new UserUrl("20181107153500", "1", 120); list.add(url); url = new UserUrl("20181107153500", "2", 120); list.add(url); url = new UserUrl("20181107153500", "3", 156); list.add(url); url = new UserUrl("20181107153500", "4", 120); list.add(url); url = new UserUrl("20181107153500", "5", 156); list.add(url); url = new UserUrl("20181107153500", "6", 120); list.add(url); url = new UserUrl(); url = new UserUrl("20181107153000", "1", 120); list.add(url); url = new UserUrl("20181107153000", "2", 156); list.add(url); url = new UserUrl("20181107153000", "3", 120); list.add(url); url = new UserUrl("20181107153000", "4", 156); list.add(url); url = new UserUrl("20181107153000", "5", 156); list.add(url); url = new UserUrl("20181107153000", "6", 120); list.add(url); // 校验时间格式 String reg = "(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)"; List&lt;UserUrl&gt; result = new ArrayList&lt;&gt;(); for (UserUrl userUrl : list) &#123; String time = userUrl.getProcess_time(); // 更改时间格式 time = time.replaceAll(reg, "$2-$3 $4:$5"); userUrl.setProcess_time(time); result.add(userUrl); &#125; System.err.println(result); return result;&#125;/** * * @Title: queryActiveTrend * @Description: 活跃用户趋势 * 应用Map中键唯一的特性，将相同统计时间节点的数据合并为一个object * @param @return * @return Object * @throws */public static List&lt;ActiveTrendVO&gt; queryActiveTrend() &#123; // 1.得到查询结果:process_time,type,user_num List&lt;UserUrl&gt; list = initData();// userCountDao.queryActiveUserTrend(); System.out.println(list.toString()); // 2.将统计时间相同的数据封装为 ActiveTrendVO List&lt;ActiveTrendVO&gt; result = new ArrayList&lt;&gt;(); /** /// 嵌套的 list List&lt;ActiveUserVO&gt; nestvo = new ArrayList&lt;&gt;(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); /// 第一条数据结果缺失,采用第二种方案 for (UserUrl userUrl : list) &#123; if (map.containsKey(userUrl.getProcess_time())) &#123; ActiveUserVO user = new ActiveUserVO(userUrl.getType(), userUrl.getUser_num()); nestvo.add(user); &#125; else &#123; ActiveTrendVO trend = new ActiveTrendVO(userUrl.getProcess_time(), nestvo); result.add(trend); nestvo.clear(); &#125; map.put(userUrl.getProcess_time(), userUrl.getProcess_time()); &#125; */ TreeMap&lt;String, List&lt;UserUrl&gt;&gt; tm = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; UserUrl userUrl = list.get(i); String time = userUrl.getProcess_time(); if (tm.containsKey(time)) &#123; ArrayList&lt;UserUrl&gt; tempList = (ArrayList&lt;UserUrl&gt;) tm.get(time); tempList.add(userUrl); &#125; else &#123; ArrayList&lt;UserUrl&gt; temlist = new ArrayList&lt;&gt;(); temlist.add(userUrl); tm.put(time, temlist); &#125; &#125; for (String key : tm.keySet()) &#123; List&lt;UserUrl&gt; userList = tm.get(key); ArrayList&lt;ActiveUserVO&gt; nestList = new ArrayList&lt;&gt;(); for (UserUrl userUrl : userList) &#123; ActiveUserVO active = new ActiveUserVO(userUrl.getType(), userUrl.getUser_num()); nestList.add(active); &#125; ActiveTrendVO trend = new ActiveTrendVO(key, nestList); result.add(trend); &#125; return result;&#125;public static void main(String[] args) &#123; List&lt;UserUrl&gt; list = initData(); // 2.将统计时间相同的数据封装为 ActiveTrendVO List&lt;ActiveTrendVO&gt; result = new ArrayList&lt;&gt;(); /// 嵌套的 list TreeMap&lt;String, List&lt;UserUrl&gt;&gt; tm = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; UserUrl userUrl = list.get(i); String time = userUrl.getProcess_time(); if (tm.containsKey(time)) &#123; ArrayList&lt;UserUrl&gt; tempList = (ArrayList&lt;UserUrl&gt;) tm.get(time); tempList.add(userUrl); &#125; else &#123; ArrayList&lt;UserUrl&gt; temlist = new ArrayList&lt;&gt;(); temlist.add(userUrl); tm.put(time, temlist); &#125; &#125; for (String key : tm.keySet()) &#123; List&lt;UserUrl&gt; userList = tm.get(key); ArrayList&lt;ActiveUserVO&gt; nestList = new ArrayList&lt;&gt;(); for (UserUrl userUrl : userList) &#123; ActiveUserVO active = new ActiveUserVO(userUrl.getType(), userUrl.getUser_num()); nestList.add(active); &#125; ActiveTrendVO trend = new ActiveTrendVO(key, nestList); result.add(trend); &#125; System.out.println(JSON.toJSONString(result));&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private static List&lt;UserAccountStatus&gt; initData() &#123; List&lt;UserAccountStatus&gt; list = new ArrayList&lt;&gt;(); UserAccountStatus userAccountStatus = new UserAccountStatus(4822, "1", "四月"); list.add(userAccountStatus); userAccountStatus = new UserAccountStatus(352, "2", "四月"); list.add(userAccountStatus); UserAccountStatus userAccountStatus1 = new UserAccountStatus(44, "1", "五月"); list.add(userAccountStatus1); userAccountStatus1 = new UserAccountStatus(0, "2", "五月"); list.add(userAccountStatus1); UserAccountStatus userAccountStatus2 = new UserAccountStatus(406, "1", "六月"); list.add(userAccountStatus2); userAccountStatus2 = new UserAccountStatus(27, "2", "六月"); list.add(userAccountStatus2); UserAccountStatus userAccountStatus3 = new UserAccountStatus(15, "1", "七月"); list.add(userAccountStatus3); userAccountStatus3 = new UserAccountStatus(0, "2", "七月"); list.add(userAccountStatus3); UserAccountStatus userAccountStatus4 = new UserAccountStatus(0, "1", "八月"); list.add(userAccountStatus4); userAccountStatus4 = new UserAccountStatus(0, "2", "八月"); list.add(userAccountStatus4); UserAccountStatus userAccountStatus5 = new UserAccountStatus(1, "1", "九月"); list.add(userAccountStatus5); userAccountStatus5 = new UserAccountStatus(0, "2", "九月"); list.add(userAccountStatus5); UserAccountStatus userAccountStatus6 = new UserAccountStatus(511, "1", "十月"); list.add(userAccountStatus6); userAccountStatus6 = new UserAccountStatus(6, "2", "十月"); list.add(userAccountStatus6); UserAccountStatus userAccountStatus7 = new UserAccountStatus(15, "1", "十一月"); list.add(userAccountStatus7); userAccountStatus7 = new UserAccountStatus(1, "2", "十一月"); list.add(userAccountStatus7); System.err.println(JSON.toJSONString(list)); return list;&#125;/** * * @Title: queryOpenAccountGrowth * @Description: 开户用户历史增长情况 * @return * Object */public List&lt;ActiveTrendVO&gt; queryOpenAccountGrowth() &#123; // 1.查询数据库得按 月、类型 分组的用户统计数 List&lt;UserAccountStatus&gt; userAccountStatusList = initData(）//userCountDao.queryUserAccuontStatusGroupByMonth(); List&lt;ActiveTrendVO&gt; result = new ArrayList&lt;&gt;(); LinkedHashMap&lt;String, List&lt;UserAccountStatus&gt;&gt; linkMap = new LinkedHashMap&lt;&gt;(); // 2.使用 process_time 作为键 for (UserAccountStatus userAccountStatus : userAccountStatusList) &#123; String time = userAccountStatus.getProcessTime(); if (linkMap.containsKey(time)) &#123; ArrayList&lt;UserAccountStatus&gt; tempList = (ArrayList&lt;UserAccountStatus&gt;) linkMap.get(time); tempList.add(userAccountStatus); &#125; else &#123; ArrayList&lt;UserAccountStatus&gt; temList = new ArrayList&lt;&gt;(); temList.add(userAccountStatus); linkMap.put(time, temList); &#125; &#125; // 3.遍历key,转换实体类 for (String key : linkMap.keySet()) &#123; System.err.println("process_time:" + key); List&lt;UserAccountStatus&gt; list = linkMap.get(key); ArrayList&lt;ActiveUserVO&gt; nestList = new ArrayList&lt;&gt;(); for (UserAccountStatus userAccountStatus : list) &#123; ActiveUserVO activeUserVO = new ActiveUserVO(userAccountStatus.getType(), userAccountStatus.getUserNum()); nestList.add(activeUserVO); &#125; ActiveTrendVO trend = new ActiveTrendVO(key, nestList); result.add(trend); &#125; return result;&#125; 对连续数据取最后一条作为结果显示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private List&lt;UserUrl&gt; formartPlayTrackResult(List&lt;UserUrl&gt; list) &#123; // 数组下标 int index = 0; for (UserUrl userUrl : list) &#123; userUrl.setIndex(index++); &#125; List&lt;UserUrl&gt; result = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(list)); // set去重后恢复排序 UserUrl[] temp = new UserUrl[result.size()]; result.toArray(temp); Arrays.sort(temp, new Comparator&lt;UserUrl&gt;() &#123; @Override public int compare(UserUrl userUrl1, UserUrl userUrl2) &#123; return userUrl1.getIndex() - userUrl2.getIndex(); &#125; &#125;); result = Arrays.asList(temp); result = new ArrayList&lt;&gt;(result); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm"); try &#123; for (int i = 0; i &lt; result.size(); i++) &#123; for (int j = i + 1; j &lt; result.size();) &#123; // 第一条播放记录的播放时间,示例值： 2018-11-13 14:05 String firstTime = result.get(i).getProcess_time(); // 第二条播放记录播放时间 String secondTime = result.get(j).getProcess_time(); String firstName = result.get(i).getChannel_name(); String secondName = result.get(j).getChannel_name(); // 两条记录的时间间隔 long difference = sdf.parse(secondTime).getTime() - sdf.parse(firstTime).getTime(); difference = difference / (1000 * 60); // 时间间隔为5分钟 if (difference == 5 &amp;&amp; firstName.equals(secondName)) &#123; result.remove(i); &#125; else &#123; j++; &#125; &#125; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return result;&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 多环境配置]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot 多环境配置 SpringBoot 多环境配置在开发环境、生产环境、测试环境中使用的配置也许有些不同，使用同一个配置文件时每次package前都需要修改成指定的环境配置。写该笔记已解决上述困，坑又被填平了一个….真好。 当前开发环境: SpringBoot适用场景: 多环境指定配置参数 划重点 命名规范application-xx.properties或appliction-xx.yml 使用当前配置构建的 jar 文件包含多环境的配置文件，可以通过java -jar xx.jar --spring.profiles.active=prod命令加载指定的配置文件 多配制文件(推荐)主文件 application.yml1234567891011spring: profiles: active: dev #指定应用`pacakage`时加载的文件名 mvc: static-path-pattern: /** view: prefix: /WEB-INF/jsp/ suffix: .jsp resources: static-locations: - classpath:/static,classpath:/templates,file:$&#123;web.upload-path&#125; 开发环境 application-dev.yml123456789101112server: port: 8090spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@192.168.203.158:1521/test username: test password: test jpa: hibernate: ddl-auto: validate show-sql: true 生产环境 application-prod.yml123456789101112server: port: 8090spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@127.0.0.1:1521/test username: 数据库用户名 password: 数据库密码 jpa: hibernate: ddl-auto: validate show-sql: true 单配置文件 application-conlony.yml 1234567891011121314151617181920212223242526272829server: port: 1001spring: profiles: server-1eureka: instance: hostname: server-1 client: register-with-eureka: false fetch-registry: false service-url:# defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/$&#123;spring.application.name&#125; defaultZone: http://server-2:1002/eureka-server--- server: port: 1002 spring: profiles: server-2 eureka: instance: hostname: server-2 client: register-with-eureka: false fetch-registry: false service-url: # defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/$&#123;spring.application.name&#125; defaultZone: http://server-1:1001/eureka-server 启动 1使用`application-conlony.yml` 配置文件时,需要指定激活的配置项.(例如启动`server-1`,需运行`java -jar xx.jar --spring.profiles.active=server-1`)]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 获取 自定义时间格式时间、上周(周一、周日)、上个月(第一天、最后一天)]]></title>
    <url>%2FBlog%2FJava%2FJava%E6%97%A5%E6%9C%9F%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java 获取 自定义时间格式时间、上周(周一、周日)、上个月(第一天、最后一天) 获取时间格式工具类获取当前日期/指定日期的 上周(周一、周日) 时间 List12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * * @Title: getLastWeekMondayAndSunday * @Description: 获取指定日期的 上周:周一、周日 时间 * @param date 指定日期 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastWeekMondayAndSunday(Date date) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); // 获取指定日期的 上个星期周一、周日时间 if (date != null) &#123; calendar.setTime(date); &#125; // 一周七天 calendar.add(Calendar.DAY_OF_WEEK, -7); // 设置每周第一天为 周一 calendar.setFirstDayOfWeek(Calendar.MONDAY); calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); String monday = df.format(calendar.getTime()); list.add(monday); calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY); String sunday = df.format(calendar.getTime()); list.add(sunday); return list;&#125;/** * * @Title: getLastWeekMondayAndSunday * @Description: 获取当前时间,上周：周一、周日时间 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastWeekMondayAndSunday() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); // 一周七天 calendar.add(Calendar.DAY_OF_WEEK, -7); // 设置每周第一天为 周一 calendar.setFirstDayOfWeek(Calendar.MONDAY); calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); String monday = df.format(calendar.getTime()); list.add(monday); calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY); String sunday = df.format(calendar.getTime()); list.add(sunday); return list;&#125; 获取当前/指定日期的 上个月(第一天、最后一天) 时间 List1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * * @Title: getLastMonthFirstDayAndLastDay * @Description: 获取当前时间,上个月:第一天、最后一天 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastMonthFirstDayAndLastDay() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); // 时间格式 SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); // 上个月的最后一天 calendar.set(Calendar.DAY_OF_MONTH, 0); String lastDay = df.format(calendar.getTime()); // 上个月的第一天 calendar.set(Calendar.DAY_OF_MONTH, 1); String firstDay = df.format(calendar.getTime()); list.add(firstDay); list.add(lastDay); return list;&#125;/** * * @Title: getLastMonthFirstDayAndLastDay * @Description: 获取指定日期,上个月:第一天、最后一天 * @param date * 指定日期 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastMonthFirstDayAndLastDay(Date date) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); // 时间格式 SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); // 上个月的最后一天 calendar.set(Calendar.DAY_OF_MONTH, 0); String lastDay = df.format(calendar.getTime()); // 上个月的第一天 calendar.set(Calendar.DAY_OF_MONTH, 1); String firstDay = df.format(calendar.getTime()); list.add(firstDay); list.add(lastDay); return list;&#125; 获取当前日期 0时0分0秒 时间123456789101112131415161718/** * * @Title: todayZero * @Description: 获取当前日期0时0分0秒时间 * @param formartStr(时间格式:yyyyMMdd等) * @return * String */public static String getTodayZero(String formartStr) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(new Date()); calendar.set(Calendar.HOUR_OF_DAY, 0); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); SimpleDateFormat format = new SimpleDateFormat(formartStr); return format.format(calendar.getTime());&#125; 当前日期多少天前的时间123456789101112131415161718192021222324/** * * @Title: getBeforeDay * @Description: 获取自定义格式的 ; 多天前时间 * @param before ：多少天之前,例如：3 * @param formatStr:时间格式 * 例如： yyyyMMdd | yyyyMMddHH | yyyyMMddHHmm * @return * String */public static String getBeforeDay(int before, String formatStr) &#123; // 24 * 60 * 60 * 1000 = 86400000 /** Date day = new Date(System.currentTimeMillis() - (before * 86400000)); SimpleDateFormat format = new SimpleDateFormat(formatStr); return format.format(day); */ Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DATE, -before); SimpleDateFormat format = new SimpleDateFormat(formatStr); return format.format(calendar.getTime());&#125; 指定日期的N天之后的日期12345678910111213141516/** * * @Title: getAfterMonth * @Description: 获取N天之后日期 * @param number * @return * Long */public static Date getAfterDay(Date date, int number) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(Calendar.DATE, number); return calendar.getTime();&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Calendar</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历 Java 实体类属性及值]]></title>
    <url>%2FBlog%2FJava%2FJava%E9%81%8D%E5%8E%86%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[遍历 Java 实体类属性及值 遍历Java实体类属性及值 核心代码 1234567891011121314151617181920212223242526272829303132/** * * @Title: getPostParams * @Description: 将实体类clazz的属性转换为url参数 * @param clazz 参数实体类 * @return * String */private String getPostParams(Object clazz) &#123; Field[] fields = clazz.getClass().getDeclaredFields(); StringBuilder requestURL = new StringBuilder(); try &#123; boolean flag = true; String property, value; for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; // 允许访问私有变量 field.setAccessible(true); // 属性名 property = field.getName(); // 属性值 value = field.get(clazz).toString(); System.out.println(property+":"+value); &#125; &#125; catch (Exception e) &#123; logger.error("用户播放轨迹查询Qos 日志失败,参数为：" + clazz.toString()); &#125; return requestURL.toString();&#125; 示例 将查询参数封装为url123456789101112131415161718192021222324252627282930313233343536373839/** * * @Title: getPostParams * @Description: 将实体类clazz的属性转换为url参数 * @param clazz 参数实体类 * @return * String */private String getPostParams(Object clazz) &#123; // 遍历属性类、属性值 Field[] fields = clazz.getClass().getDeclaredFields(); StringBuilder requestURL = new StringBuilder(); try &#123; boolean flag = true; String property, value; for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; // 允许访问私有变量 field.setAccessible(true); // 属性名 property = field.getName(); // 属性值 value = field.get(clazz).toString(); String params = property + "=" + value; if (flag) &#123; requestURL.append(params); flag = false; &#125; else &#123; requestURL.append("&amp;" + params); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("URL参数为：" + clazz.toString()); &#125; return requestURL.toString();&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Entity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置单个 maven 项目 pom 依赖仓库地址]]></title>
    <url>%2FBlog%2FMaven%2FPom%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[配置单个 maven 项目 pom 依赖仓库地址 pom.xml 配置 maven 仓库地址，不需要改 setting pom.xml文件中加入repositories配置 12345678910111213141516171819202122232425&lt;!--配置maven阿里云仓库开始,不用去改maven的setting --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;local private nexus&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;local private nexus&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;!--配置maven阿里云结束 --&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML log]]></title>
    <url>%2FBlog%2FHTML%2FHTML%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTML log HTML 应用记录css获取奇偶行数 奇数行：td:nth-child(odd){} 偶数行：td:nth-child(even){} css选择器：参考地址 跳转html页面1parent.window.location.href = "../main/index.do"; border设置渐变色123456.customborder &#123; border-image: -webkit-linear-gradient(#F80, #2ED) 20 20; border-image: -moz-linear-gradient(#F80, #2ED) 20 20; border-image: -o-linear-gradient(#F80, #2ED) 20 20; border-image: linear-gradient(#F80, #2ED) 20 20;&#125; 数组首尾添加空对象1234 // 头部添加result.unshift(&#123;&#125;);// 数组 尾部添加result.push(&#123;&#125;);]]></content>
      <categories>
        <category>Blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目集成 FineBI 应用系统]]></title>
    <url>%2FBlog%2FWeb-Plugins%2FFineBI%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[项目集成 FineBI 应用系统 项目集成 FineBI 应用系统 s 页面 安装FIneBi 找到..\FineBI5.0\webapps\webroot 文件夹，复制文件至..\apache-tomcat-9.0.8\webapps\目录下; 复制JDK 1.8 或以上环境中的 D:\Program Files\Java\jdk1.8.0_161\lib\tools.jar文件到 D:\Environment\Tomcat\apache-tomcat-9.0.8\lib 文件夹下; 在dos窗口执行catalina.bat run命令启动tomcat 或执行start.sh; 访问http://127.0.0.1:8080/webroot/decision 出现FineBI登录配置页面. 数据库连接配置 连接 iptvView 项目时，需要修改部署项目 Tomcat 8.0.x 中的 xx\webapps\webroots\WEB-INF\lib 的 ojdbc14.jar 改为 ojdbc6.jar]]></content>
      <categories>
        <category>Blog</category>
        <category>Web Plugins</category>
      </categories>
      <tags>
        <tag>FineBI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka-Server]]></title>
    <url>%2FSpringCloud%2FEureka-Server%2F</url>
    <content type="text"><![CDATA[Eureka-Server 基于 Eureka 搭建高可用(双节点服务注册中心)本项目是一个基于 SpringBoot(1.5.19.RELEASE)、SpringCloud(Dalston.SR5)、Eureka 的服务注册中心 配置文件说明 application.yml: 单个 Eureka 服务注册中心 application-colony.yml: 双节点注册中心示例,实现双向注册从而提高可用性 默认使用 application.yml 配置文件; 使用application-conlony.yml 配置文件时,需要指定激活的配置项.(例如启动server-1,需运行java -jar xx.jar --spring.profiles.active=server-1)]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts使用总结]]></title>
    <url>%2FBlog%2FWeb-Plugins%2FECharts%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Echarts使用总结 Echarts使用笔记设置默认选中显示数据1234567option =&#123; legend:&#123; selected : &#123; 'XX':false //不想显示的设为false &#125; &#125;&#125; 设置Y轴数值 1000显示为1K123456789101112131415yAxis : &#123; type : 'value', axisLabel : &#123; color : '#fff', formatter : function(value, index) &#123; var thousand; if (value &gt;= 1000) &#123; thousand = value / 1000 + 'k'; &#125; else &#123; thousand = value &#125; return thousand; &#125; &#125;&#125; 设置超长字符串为...设置echarts 柱状图颜色123option:&#123; color: ['#003366', '#006699', '#4cabce', '#ccc']&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Web Plugins</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse | STS(Spring Tool Suite)开发工具配置]]></title>
    <url>%2FBlog%2FEclipse%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Eclipse | STS(Spring Tool Suite)开发工具配置 开发环境中Eclipse、STS(Spring Tool Suite)通用配置 Java实体类，重写toString().生成JSON字符串配置 Eclipse 快捷键 Alt + S 选择 Generate toString，重写toString()方法 添加自定义的format格式，选择Edit 新的template，输入Name和Pattern 点击OK，完成创建。 回到第一个页面，默认选中刚刚创建的JSONString，点击Generate完成创建 创建完成后效果]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doc 常用命令记录]]></title>
    <url>%2FBlog%2FDoc%2FDOS%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Doc 常用命令记录 DOC 命令 log删除文件夹及文件夹下所有文件和文件夹1rd /s /q folder 删除指定后缀的文件1del /a /f /q file path\*.xx 查看当前文件加下所有文件夹及文件列表1dir 清空 DOS 界面1cls 文件夹 进入某个文件夹内 1cd xxx/xxx/folder 返回上级目录 1cd ../ 有多少层级目录就写多少个../便返回相应的某一层]]></content>
      <categories>
        <category>Blog</category>
        <category>Doc</category>
      </categories>
      <tags>
        <tag>Doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ext 4.0 使用笔记]]></title>
    <url>%2FBlog%2FExt%204.0%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ext 4.0 使用笔记 Ext 4.0 使用笔记获取Grid 当前选中行数据 获取行数据 123var record = Ext.getCmp('now_alarm').getSelectionModel().getSelection();//获取选中单行的某列值 var deviceName = record[0].data.DEVICE_NAME; 列宽自动适应12forceFit:true,//注意不要用autoFill:true;那样设置当GridPanel的大小变化(比如resize了它)时不会自动调整column的宽度scrollOffset:0//不加这个的话,会在grid的最右边有个空白,留作滚动条的位置 load store12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //查询参数 var getParams = function() &#123; return &#123; sheetIds : Ext.getCmp('sheetId').getValue(), station : Ext.getCmp('station').getValue(), maintain : Ext.getCmp('maintainer').getValue(), startTime : Ext.util.Format.date(Ext.getCmp('startTime').getValue(),'Y-m-d'), //status : state,// Ext.getCmp('status').getValue(), endTime : Ext.util.Format.date(Ext.getCmp('endTime').getValue(),'Y-m-d'), worksheettype : Ext.getCmp('worksheetType').getValue() &#125; &#125; // 条件查询 function reportLoad()&#123; var params = getParams();// console.log(params); for ( var key in params) &#123; if (params[key] == null || params[key] == "") &#123; delete params[key]; continue; &#125; &#125; reportStore.setProxy(&#123; type : 'ajax', url: '../centerSheet/getWorkSheet', extraParams : params, reader:&#123; type:'json', root:'records', totalProperty:'totalCount' &#125; &#125;); switch (state) &#123; case 0: Ext.getCmp('no_confirm').getStore().load(); break; case 1: Ext.getCmp('no_repair').getStore().load(); break; case 2: Ext.getCmp('no_statements').getStore().load(); break; case 4: Ext.getCmp('statements').getStore().load(); break; default: break; &#125; &#125; 创建window1234567891011121314151617181920212223242526272829303132Ext.create('Ext.window.Window', &#123; title : '问题单信息录入', labelWidth : 75, // label settings here cascade unless overridden url : 'save-form.php', frame : true, bodyStyle : 'padding:5px 5px 0', width : document.body.clientWidth * 0.58, renderTo : Ext.getBody(), layout : 'column', // arrange fieldsets side by side xtype : 'form', defaults : &#123; bodyPadding : 4 &#125;, items : [ &#123; xtype : 'fieldset', columnWidth : 1, title : '告警基本信息', collapsible : true, defaultType : 'textfield', defaults : &#123; anchor : '100%' &#125;, layout : 'anchor', items : [ &#123; fieldLabel : 'Field 1', name : 'field1' &#125;, &#123; fieldLabel : 'Field 2', name : 'field2' &#125; ] &#125; ]&#125;).show(); 获取选中行displayField的值1Ext.getCmp('distributeUserName').getRawValue(), 获取点击行数据Ext.getCmp(&#39;now_alarm&#39;).getStore().getAt(index).data Store load 第一种 12345678910historyStore.setProxy(&#123; type : 'ajax', url : newUrl, reader:&#123; type:"json", root:'root', totalProperty:'totalCount' &#125; &#125;);Ext.getCmp('history_alarm').getStore().load(); 第二种 123// now_alarm : GridPanelvar gridStore = Ext.getCmp('now_alarm').getStore();gridStore.reload(gridStore.lastOptions); store加载传参 proxy 设置 extraParams 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748xtype : 'combo',fieldLabel : '维保人员',id : 'sendOperUser',name : 'sendOperUser',style:&#123; margin : '10px 10px 10px 50px'&#125;,resizable : false,store : Ext.create('Ext.data.Store',&#123; autoLoad : true, fields : [ &#123; name : 'id', mapping :'ID', &#125;, &#123; name : 'name', mapping :'NAME', &#125;], proxy : &#123; type : "ajax", url : '../alarm/getMaintainer', extraParams : &#123; error_sheet : errorSheetId, company : company &#125;, reader : &#123; type : "json" &#125; &#125;, listeners: &#123; load: function(store, records, successful, eOpts)&#123; for(k in records)&#123; if (records[k].data) &#123; // console.log(records[k].data); if (distribute_account == records[k].data.name) &#123; Ext.getCmp('sendOperUser').setValue(records[k].data.id); &#125; &#125; &#125; &#125; &#125; &#125;), valueField : 'id',displayField : 'name',mode : 'local',triggerAction : 'all',allowBlank : false,blankText : '必选项',maxHeight : 150 拼接URL 1234567proxy : &#123; type : "ajax", url : '../alarm/getMaintainer?error_sheet='+errorSheetId+'&amp;company='+company, reader : &#123; type : "json" &#125;&#125;, 监听 tabpanel 事件12345listeners:&#123; tabchange :function(tabPanel,tab)&#123; &#125; &#125;, 解析store返回自定义参数值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 查询条件 封装var getParams = function() &#123; return &#123; sheetIds : Ext.getCmp('sheetId').getValue(), station : Ext.getCmp('station').getValue(), maintain : Ext.getCmp('maintainer').getValue(), startTime : Ext.util.Format.date(Ext.getCmp('startTime').getValue(),'Y-m-d'), status : state,// Ext.getCmp('status').getValue(), endTime : Ext.util.Format.date(Ext.getCmp('endTime').getValue(),'Y-m-d'), worksheettype : Ext.getCmp('worksheetType').getValue() &#125; &#125; // 条件查询 function reportLoad()&#123; // 移除为空的查询条件 var params = getParams(); for ( var key in params) &#123; if (params[key] == null || params[key] == "") &#123; delete params[key]; continue; &#125; &#125; // 添加自定义返回参数`no_coinfirm` reportStore.setProxy(&#123; type : 'ajax', url: '../centerSheet/getWorkSheet', extraParams : params, reader:&#123; type:'json', root:'records', totalProperty:'totalCount', no_coinfirm:'no_confirm', no_repair:'no_repair', no_statements:'no_statements', statements:'statements' &#125; &#125;); // 加载对应的 tabpanel 的数据、更新titel reportStore.load(&#123; scope: this, callback: function(records, operation, success) &#123; var reader = reportStore.getProxy().getReader(); Ext.getCmp('no_confirm').setTitle(tabpanel1 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.no_confirm); Ext.getCmp('no_repair').setTitle(tabpanel2 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.no_repair); Ext.getCmp('no_statements').setTitle(tabpanel3 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.no_statements); Ext.getCmp('statements').setTitle(tabpanel3 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.statements); &#125; &#125;); &#125; fieldset 可折叠控制`collapsible : true` 监听表格数据双击事件12345678910111213listeners: &#123; // 监听双击事件 itemdblclick: function (dataView, record, item, index, e) &#123; // 当前数据行数据 var data = record.data; console.log(data); //传参 var user_id = data.id; var process_time = Ext.util.Format.date(data.process_time, 'YmdHi'); queryQosLog(user_id, process_time); &#125; &#125; Ext window遮罩效果实现12在Ext.window.Window 中添加属性 modal: true,]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Web Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用EasyExcel上传文件]]></title>
    <url>%2FBlog%2FJava%2FEasyExcel%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Java使用EasyExcel上传文件 Java使用EasyExcel 上传文件 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;1.1.2-beta5&lt;/version&gt;&lt;/dependency&gt; 部分代码 导入信息实体类(上传文件对应实体类) 123456789101112131415161718192021222324252627282930313233343536/** * * @ClassName: Advertising * @Description: 广告信息批量导入Model * @date 2019/01/29 */public class AdvertisingImportModel extends BaseRowModel &#123; @ExcelProperty(index = 0) private String ad; @ExcelProperty(index = 1) private String address; public String getAd() &#123; return ad; &#125; public void setAd(String ad) &#123; this.ad = ad.trim(); &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address.trim(); &#125; @Override public String toString() &#123; return "&#123;\"ad\":\"" + ad + "\",\"address\":\"" + address + "\"&#125;"; &#125;&#125; 导出文件上传实体类 1234567891011121314151617181920212223242526272829303132333435363738public class AdvertisingExportModel extends BaseRowModel &#123; @ExcelProperty(value = "用户AD", index = 0) private String name; @ExcelProperty(value = "用户地址", index = 1) private String address; public AdvertisingExportModel() &#123; &#125; public AdvertisingExportModel(String name, String address) &#123; this.name = name; this.address = address; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "&#123;\"name\":\"" + name + "\",\"address\":\"" + address + "\"&#125;"; &#125;&#125; 需要自己创建 ExcelListener 1234567891011121314151617181920212223public class ExcelListener extends AnalysisEventListener&lt;Object&gt; &#123; private List&lt;Object&gt; data = new ArrayList&lt;&gt;(); @Override public void invoke(Object object, AnalysisContext context) &#123; data.add(object); &#125; @Override public void doAfterAllAnalysed(AnalysisContext context) &#123; &#125; public List&lt;Object&gt; getData() &#123; return data; &#125; public void setData(List&lt;Object&gt; data) &#123; this.data = data; &#125;&#125; API实现方法,简单起见将代码都写在了controller(可以将具体的实现写在service层中) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * * @Title: synchronizationInformation * @Description: 上传文件并返回自己生成的数据文件 * @param file 需要同步的用户文件 * @param response 下载的文件 * void */@RequestMapping(value = "easyexcel", consumes = "multipart/*", headers = "content-type=multipart/form-data", method = RequestMethod.POST)public void synchronizationInformation(@RequestParam(name = "file", required = false) MultipartFile file, HttpServletResponse response) &#123; try &#123; List&lt;AdvertisingImportModel&gt; result; // 1. 将excel 转换为 List&lt;Object&gt; list InputStream inputStream = new BufferedInputStream(file.getInputStream()); // 文件名 String fileName = file.getOriginalFilename(); // 文件后缀 String prefix = fileName.substring(fileName.lastIndexOf(".") + 1); ExcelListener excelListener = new ExcelListener(); EasyExcelFactory.readBySax(inputStream, new Sheet(1, 1, AdvertisingImportModel.class), excelListener); // 文件内容 List&lt;Object&gt; data = excelListener.getData(); result = JSONObject.parseArray(JSON.toJSONString(data), AdvertisingImportModel.class); logger.info("上传文件包含内容:\t" + result.toString()); // 原本是要调用http接口,作为list的返回值(现暂时模拟返回值为这些) // 2.导出栅格数据文件内容 List&lt;AdvertisingExportModel&gt; list = new ArrayList&lt;&gt;(); list = JSONObject.parseArray( "[&#123;\"name\":\"亚索\",\"address\":\"艾欧尼亚\"&#125;,&#123;\"name\":\"诺克\",\"address\":\"诺克萨斯\"&#125;,&#123;\"name\":\"瑞文\",\"address\":\"艾欧尼亚\"&#125;]", AdvertisingExportModel.class); ExcelTypeEnum excelTypeEnum = prefix == ".xls" ? ExcelTypeEnum.XLS : ExcelTypeEnum.XLSX; ServletOutputStream outputStream = response.getOutputStream(); ExcelWriter writer = new ExcelWriter(outputStream, excelTypeEnum, true); Sheet sheet = new Sheet(1, 0, AdvertisingExportModel.class); sheet.setAutoWidth(true); sheet.setSheetName("第一个sheet"); fileName = new String(new SimpleDateFormat("yyyy-MM-dd").format(new Date()).getBytes(), "utf-8"); // System.out.println(fileName + prefix); response.setContentType("application/octet-stream"); response.setCharacterEncoding("utf-8"); response.setHeader("Content-Disposition", "attachment;filename=" + fileName + "." + prefix); writer.write(list, sheet); writer.finish(); outputStream.flush(); inputStream.close(); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 注： InputStream 使用file.getInputStream()时,会报异常。 使用easyexcel工具类时,需要将项目中原有的poi、poi-ooxml、poi-ooxml-schemas 版本需与easyexcel版本一致。 使用EasyExcel时,遇到的问题 org.apache.catalina.core.StandardWrapperValve 控制台输出 123二月 21, 2019 1:59:51 下午 org.apache.catalina.core.StandardWrapperValve invoke严重: Servlet.service() for servlet [springmvc] in context with path [/iptvView] threw exception [Request processing failed; nested exception is com.alibaba.excel.exception.ExcelAnalysisException: File type error，io must be available markSupported,you can do like this &lt;code&gt; new BufferedInputStream(new FileInputStream(\"/xxxx\"))&lt;/code&gt; "] with root causecom.alibaba.excel.exception.ExcelAnalysisException: Xls must be available markSupported,you can do like this &lt;code&gt; new BufferedInputStream(new FileInputStream("/xxxx"))&lt;/code&gt; 问题原因 123InputStream inputStream = file.getInputStream();//获取的时文件inputStream,获取xls时失败.抛出异常InputStream inputStream = new BufferedInputStream(file.getInputStream());//正确的获取方式 解决方式 1改为第二种获取InputStream 的方式 java.lang.ClassNotFoundException: org.apache.poi.poifs.filesystem.FileMagic 问题原因 项目中引用了poi、poi-oomxl、poi-oomxl-schemas jar包，并且版本与 easyexcel 版本不一致 解决方案 更新/降低 项目中引入的poi版本,使 版本保持一致]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fall%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置https(xx.Jar、xx.war)]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8https%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot配置https(xx.Jar、xx.war) SpringBoot配置https 与 War包配置https参考地址：https://blog.csdn.net/u012702547/article/details/53790722 SpringBoot 项目配置 *.jar 第一步：生成加密证书 方法：使用Java自带的命令,在cmd中执行以下语句 keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 参数说明 -storetype 指定秘钥仓库类型 -keyalg 指定证书生成算法签名，RSA是一种非对称加密算法 -keysize 证书大小 -keystore 生成证书文件的存储路径 -validity 证书有效期 第二步：修改项目配置 执行上述命令后，可在当前系统登录用户根目录下找到keystore.p12文件。将文件复制到springboot项目根目录下.同时需要对application.yml文件作出修改，增加如下内容。(也可使用xx.properties文件，文本内容修改为properties文件格式即可) 配置文件修改(.yml格式文件，.properties文件修改只是使用了不同的书写方式如有不懂请自行百度) 123456server: ssl: key-store: keystore.p12 key-store-password: 111111 key-store-type: PKCS12 key-alias: tomcat Tomcat 部署 SpringBoot *.war 文件 第一步：生成加密证书 方法：使用Java自带的命令,在cmd中执行以下语句 keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 第二步： 注释 8080 (tomcat默认端口为8080,如果修改为其他端口则注释修改后的端口) &lt;!-- &lt;Connector port=&quot;7090&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; --&gt; 取消注释 8433 端口配置,并修改为 443 端口(访问可不加端口设置)，修改tomcat中D:\Environment\Tomcat\apache-tomcat-8.0.50\conf\server.xml 需做如下配置。(tomcat路径为发布war文件的server.xml) keystoreFile=&quot;D:\Environment\Tomcat\apache-tomcat-8.5.31\conf\keystore.p12&quot; keystorePass=&quot;111111&quot; 注：修改后如下 12345678910&lt;Connector port="443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" keystoreFile="D:\Environment\Tomcat\apache-tomcat-8.5.31\conf\keystore.p12" keystorePass="111111" &gt; &lt;!-- &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile="conf/localhost-rsa.jks" type="RSA" /&gt; &lt;/SSLHostConfig&gt; --&gt;&lt;/Connector&gt; &lt;!-- 修改8443端口为443 --&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="443" /&gt;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Durid | Hikari 多数据源 JDBCTemplate]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[SpringBoot + Durid 多数据源 JDBCTemplateSpringBoot + Hikari 多数据源 JDBCTemplate SpringBoot 配置多数据源(Druid | Hikari) 注释: Druid：阿里系数据连接池Hikari：SpringBoot 2.0开始推HikariCP，将默认的数据库连接池tomcat jdbc pool改为了hikari SpringBoot + Druid 配置Druid-Jdbctemplate 连接配置jdbctemplate连接 增加pom依赖 12345678910111213&lt;!-- 数据库连接池 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 设置application.yml文件配置 12345678910111213141516171819202122232425262728293031323334spring: autoconfigure: ## 多数据源下必须排除掉 DataSourceAutoConfiguration,否则会导致循环依赖报错 exclude: - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration datasource: type: com.alibaba.druid.pool.DruidDataSource druid: ## 以`spring.datasources`和`spring.datasource.druid`开头的属性会作为公共配置,注入到每一个数据源 initial-size: 5 min-idle: 5 max-active: 20 stat-view-servlet: login-username: admin login-password: admin max-wait: 60000 time-between-eviction-runs-millis: 60000 ## 配置间隔多久才进行一次检测,检测需要关闭的空闲连接.单位是毫秒 min-evictable-idle-time-millis: 300000 ## 配置一个连接池中最小生存的时间,单位是毫秒 ## 配置监控统计拦截的filters,去掉后监控界面SQL无法进行统计,`wall`用于防火墙(https://blog.csdn.net/garyond/article/details/80189939) filters: config,stat,wall,log4j web-stat-filter: exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' ## 多数据源的标识,若该属性存在则为多数据源环境,不存在则为但数据源环境 data-sources: primary: url: jdbc:oracle:thin:@//192.168.203.158:1521/pdb1.us.oracle.com username: iptvpro password: iptv2016 driverClassName: oracle.jdbc.driver.OracleDriver secondary: url: jdbc:oracle:thin:@//192.168.203.158:1521/pdb1.us.oracle.com username: iptvqosadv password: iptv2013 driverClassName: oracle.jdbc.driver.OracleDriver Druid 连接池配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import com.alibaba.druid.pool.DruidDataSource;/** * * @ClassName: DruidDataScouConfig * @Description: 多数据源,集成Druid * @author time * @date 2018/10/29 */@Configurationpublic class DruidDataScouConfig &#123; @Primary//必需注解，缺少该注解将启动异常.可自定义某个数据源为主数据源 @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.druid.data-sources.primary") public DataSource primaryDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.druid.data-sources.secondary") public DataSource secondaryDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryJdbcTemplate") public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 测试数据源是否可用 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sanss.config;import java.util.List;import java.util.Map;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import com.alibaba.fastjson.JSON;@RunWith(SpringRunner.class)@SpringBootTestpublic class DruidDataSourceTest &#123; @Autowired // @Qualifier("primaryJdbcTemplate") private JdbcTemplate primaryJdbcTemplate; @Autowired // @Qualifier("secondaryJdbcTemplate")//注解可省略 private JdbcTemplate secondaryJdbcTemplate; @Test public void TestPrimaryDataSourceConnect() &#123; System.err.println("primary data source connection start:"); String sql = "select * from t_user where rownum &lt;=1"; List&lt;Map&lt;String, Object&gt;&gt; result = primaryJdbcTemplate.queryForList(sql); System.out.println(JSON.toJSONString(result)); &#125; @Test public void TestSecondaryDataSourceConnect() &#123; System.err.println("secondary data source connection start:"); String sql = "select * from t_user where rownum &lt;=1"; List&lt;Map&lt;String, Object&gt;&gt; result = secondaryJdbcTemplate.queryForList(sql); System.out.println(JSON.toJSONString(result)); &#125;&#125; Hikari-jdbctemplate 连接配置 添加pom.xml依赖 12345&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 设置application.yml多环境配置文件 123456789101112spring: datasource: primary: jdbc-url: jdbc:oracle:thin:@//192.168.0.158:1521/test username: admin password: test driver-class-name: oracle.jdbc.driver.OracleDriver secondary: jdbc-url: jdbc:oracle:thin:@//192.168.0.157:1521/test username: test password: test driver-class-name: oracle.jdbc.driver.OracleDriver Hikari 数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import com.zaxxer.hikari.HikariDataSource;/** * * @ClassName: HikariDataSourceConfig * @Description: Hikari 多数据源配置 * @author time * @date 2018/10/29 */@Configurationpublic class HikariDataSourceConfig &#123; @Primary @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.secondary") public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryJdbcTemplate") public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 测试数据源是否可用 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.List;import java.util.Map;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import com.alibaba.fastjson.JSON;@RunWith(SpringRunner.class)@SpringBootTestpublic class HikariDataSourceTest &#123; @Autowired private JdbcTemplate primaryJdbcTemplate; @Autowired private JdbcTemplate secondaryJdbcTemplate; @Test public void TestPrimaryDataSourceConnect() &#123; System.err.println("primary data source connection start:"); String sql = "select * from t_account where rownum &lt;=1"; List&lt;Map&lt;String, Object&gt;&gt; result = primaryJdbcTemplate.queryForList(sql); System.out.println("primary data source :\t"+JSON.toJSONString(result)); &#125; @Test public void TestSecondaryDataSourceConnect() &#123; System.err.println("secondary data source connection start:"); String sql = "select * from t_account where rownum &lt;=1"; List&lt;Map&lt;String, Object&gt;&gt; result = secondaryJdbcTemplate.queryForList(sql); System.out.println("secondary data source :\t"+JSON.toJSONString(result)); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Durid</tag>
        <tag>Hikari</tag>
        <tag>JDBCTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通 Java/Jave Web 转为 Maven 项目]]></title>
    <url>%2FBlog%2FJava%2F%E6%A0%B9%E6%8D%AEjar%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90pom%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[普通 Java/Jave Web 转为 Maven 项目 Jar文件 更改为 pom.xml 依赖 只需要运行方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.sanss.util;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.jar.JarInputStream;import java.util.jar.Manifest;import org.dom4j.Element;import org.dom4j.dom.DOMElement;import org.jsoup.Jsoup;import com.alibaba.fastjson.JSONObject;/** * * @ClassName: MakePomFromJars * @author: * @Date: 2018/06/21 * @Description: 将jar 包生pom依赖 * */public class MakePomFromJars &#123; public static void main(String[] args) throws FileNotFoundException, IOException &#123; Element dependencys = new DOMElement("dependencies"); File dir = new File("D:\\Code\\sts-work-workspace\\iptvView\\WebRoot\\WEB-INF\\lib");// 生pom文件的lib路径 System.out.println("读取文件路径为:\t" + dir.getPath()); System.out.println("开始读取文件: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); StringBuffer missJar = new StringBuffer(); for (File jar : dir.listFiles()) &#123; JarInputStream jis = new JarInputStream(new FileInputStream(jar)); Manifest manifest = jis.getManifest(); jis.close(); if (manifest == null) &#123; continue; &#125; String bundleName = manifest.getMainAttributes().getValue("Bundle-Name"); String bundleVersion = manifest.getMainAttributes().getValue("Bundle-Version"); Element element = null; System.out.println(jar.getName()); StringBuffer sb = new StringBuffer(jar.getName()); if (bundleName != null) &#123; bundleName = bundleName.toLowerCase().replace(" ", "-"); sb.append(bundleName + "\t" + bundleVersion); element = getDependices(bundleName, bundleVersion); // System.out.println(sb.toString()); // System.out.println(element.asXML()); &#125; if (element == null || element.elements().size() == 0) &#123; bundleName = ""; bundleVersion = ""; String[] ns = jar.getName().replace(".jar", "").split("-"); for (String s : ns) &#123; if (Character.isDigit(s.charAt(0))) &#123; bundleVersion += s + "-"; &#125; else &#123; bundleName += s + "-"; &#125; &#125; if (bundleVersion.endsWith("-")) &#123; bundleVersion = bundleVersion.substring(0, bundleVersion.length() - 1); &#125; if (bundleName.endsWith("-")) &#123; bundleName = bundleName.substring(0, bundleName.length() - 1); &#125; element = getDependices(bundleName, bundleVersion); sb.setLength(0); sb.append(bundleName + "\t").append(bundleVersion); // System.out.println(sb.toString()); // System.out.println(element.asXML()); &#125; element = getDependices(bundleName, bundleVersion); if (element.elements().size() == 0) &#123; element.add(new DOMElement("groupId").addText("not found")); element.add(new DOMElement("artifactId").addText(bundleName)); element.add(new DOMElement("version").addText(bundleVersion)); missJar.append(bundleName + "\n");// 统计缺失的jar名称 &#125; else &#123; dependencys.add(element); // System.out.println(); &#125; &#125; System.err.println(missJar); System.out.println(dependencys.asXML()); &#125; private static Element getDependices(String key, String ver) &#123; Element dependency = new DOMElement("dependency"); // 设置代理 // System.setProperty("http.proxyHost","127.0.0.1"); // System.setProperty("http.proxyPort", "8090"); try &#123; String url = "http://search.maven.org/solrsearch/select?q=a%3A%22" + key + "%22%20AND%20v%3A%22" + ver + "%22&amp;rows=3&amp;wt=json"; org.jsoup.nodes.Document doc = Jsoup.connect(url).ignoreContentType(true).timeout(30000).get(); String elem = doc.body().text(); JSONObject response = JSONObject.parseObject(elem).getJSONObject("response"); if (response.containsKey("docs") &amp;&amp; response.getJSONArray("docs").size() &gt; 0) &#123; JSONObject docJson = response.getJSONArray("docs").getJSONObject(0); Element groupId = new DOMElement("groupId"); Element artifactId = new DOMElement("artifactId"); Element version = new DOMElement("version"); groupId.addText(docJson.getString("g")); artifactId.addText(docJson.getString("a")); version.addText(docJson.getString("v")); dependency.add(groupId); dependency.add(artifactId); dependency.add(version); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return dependency; &#125;&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面传参中文参数乱码]]></title>
    <url>%2FBlog%2FHTML%2Furl%E4%BC%A0%E5%8F%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[页面传参中文参数乱码 页面传递中文参数乱码解决 方案一: 接收端设置编码格式 使用 request.setCharacterEncoding(&#39;utf-8&#39;); 使用 request.getParameter(&quot;handlerType&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;) 接受传递的参数值]]></content>
      <categories>
        <category>Blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CharacterEncoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Redis 自定义主键增长策略]]></title>
    <url>%2FSpringBoot%2FSpringboot%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%94%AE%E5%A2%9E%E9%95%BF%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[SpringBoot + Redis 自定义主键增长策略 SpringBoot 使用 Redis 生成yyyyMMdd + 0001 格式id 开发环境 当前开发环境: SpringBoot + redis，应该可以用于其他同样使用Redis的环境生成唯一id环境(未曾亲自实践) 适用场景: 单个服务的唯一id生成工具类 如果之前未引入Redis则需要增加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在.properties文件中增加Redis配置 123456789101112131415161718192021# REDIS的配置信息# Redis数据库索引（默认为0）spring.redis.database=0 # 指定Redis服务器地址，多环境/注释实现(本文有参考链接)spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379# 用户缓存超时时间spring.redis.expireTime=1800# Redis服务器连接密码（默认为空）#spring.redis.password=foobared# 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1 # 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8 # 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0 # 连接超时时间（毫秒）spring.redis.timeout=12000 注: SpringBoot多环境配置[^多环境配置] 工具类代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar; import java.util.Date;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.support.atomic.RedisAtomicLong;import org.springframework.stereotype.Service;/** * * @ClassName: RedisGeneratorCode * @Description: 生成日期开头加0001，0002，0003的工具类 * @author time * @date 2018/10/09 * &#123;@link https://www.cnblogs.com/jbml-154312/p/7490810.html&#125; */@Servicepublic class RedisGeneratorCode &#123; private static final Logger logger = LoggerFactory.getLogger(RedisGeneratorCode.class); private RedisTemplate&lt;String, Object&gt; redisTemplate; @Autowired public RedisGeneratorCode(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * * @Title: generateCode * @Description: 生成自定义前缀的类似 HTG201810120001格式的自增数 * @param key * @param prefix * @param hasExpire * @param minLength * @return * String */ public String generateCode(String key, String prefix, boolean hasExpire, Integer minLength) &#123; return this.createGenerateCode(key, prefix, hasExpire, minLength); &#125; /** * * @Title: generateCode * @Description: 生成 类似 201810120001格式的自增数 * @param key * @param hasExpire * @param minLength * @return * String */ public String generateCode(String key, boolean hasExpire, Integer minLength) &#123; return this.createGenerateCode(key, "", hasExpire, minLength); &#125; /** * * @Title: generateCode * @Description: 组装符合自己规则的id并设置过期时间 * @param key redis中的key值 * @param prefix 最后编码的前缀 * @param hasExpire redis 是否使用过期时间设置自增id * @param minLength redis生成的自增id的最小长度，如果小于这个长度前面补0 * @return * String */ public String createGenerateCode(String key, String prefix, boolean hasExpire, Integer minLength) &#123; try &#123; Date date = null; Long id = null; Calendar calendar = Calendar.getInstance(); if (hasExpire) &#123; calendar.set(Calendar.HOUR_OF_DAY, 23); calendar.set(Calendar.MINUTE, 59); calendar.set(Calendar.SECOND, 59); calendar.set(Calendar.MILLISECOND, 9999); date = calendar.getTime(); &#125; else &#123; calendar.set(Calendar.MINUTE, calendar.get(Calendar.MINUTE) + 10); date = calendar.getTime(); &#125; id = this.generateId(key, date); if (id != null) &#123; return this.format(id, prefix, minLength); &#125; &#125; catch (Exception e) &#123; logger.info("error --&gt; redis 生成自增id出现异常"); logger.error(e.getMessage(), e); &#125; return null; &#125; /** * * @Title: generateId * @Description: 使用RedisAtomicLong自增 * @param key * @param date * @return * Long */ private Long generateId(String key, Date date) &#123; RedisAtomicLong counter = new RedisAtomicLong(key, redisTemplate.getConnectionFactory()); // 通过key获取自增并设定过期时间 counter.expireAt(date); return counter.incrementAndGet(); &#125; /** * * @Title: format * @Description: 获取 redis 自增后，生成自定义格式的id * @param id redis 获取的 id值 * @param prefix 自定义前缀 * @param minLength 生成数的长度，不满足时 0 补齐 * @return * String */ private String format(Long id, String prefix, Integer minLength) &#123; // 拼接的字符串 StringBuffer sb = new StringBuffer(); // 当前日期 Date date = new Date(); // 自定义前缀 sb.append(prefix); if (date != null) &#123; DateFormat df = new SimpleDateFormat("yyyyMMdd"); sb.append(df.format(date)); &#125; /* 对不满足长度的id值,使用0补齐 */ // redis 生成的id值 String strId = String.valueOf(id); // redis 生成id 的长度 int length = strId.length(); if (length &lt; minLength) &#123; for (int i = 0; i &lt; minLength - length; i++) &#123; sb.append("0"); &#125; sb.append(strId); &#125; else &#123; sb.append(strId); &#125; return sb.toString(); &#125;&#125; 测试工具类 123456789101112131415@Autowiredprivate RedisGeneratorCode redisGeneratorCode;@Testpublic void createGenerateCodeTest() &#123; // String code = primaryGenerater.generateCode("worksheet_id", "", true, 4); boolean flag = true; String code = null; int count = 0; while (flag) &#123; code = redisGeneratorCode.generateCode("worksheet_id", "", true, 4); flag = code == null ? true : false; &#125; System.out.println(code);&#125; 参考链接: java生成自增流水号，并从每月第一天重新清零计数将业务流水号添加到数据库(原创) 使用redis生成全局唯一id SpringBoot集成Redis 脚注 [^多环境配置]: 参考另一篇博客SpringBoot多环境配置]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat 多端口部署 web 项目]]></title>
    <url>%2FBlog%2FTomcat%2F%E5%8D%95%E4%B8%AATomcat%E5%A4%9A%E7%AB%AF%E5%8F%A3%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Tomcat 多端口部署 web 项目 单个 Tomcat 运行多个实例、分配不同端口 第一种方式：更改 Connector 中的端口号 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;!-- 第一个项目端口号 --&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;!-- 第二个端口号 --&gt; &lt;Connector port="7090" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" maxThreads="150" maxSpareThreads="75" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 多个 Tomcat 部署上传多个不同版本 tomcat/tomcat 部署多个实例修改 server.xml默认 server.xml 配置 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 修改 shutdown 端口,如果同样使用 8005 那么关闭其中一个时另外的 shutdown.port= 7005 的tomcat 也会被关闭 --&gt;&lt;Server port="7005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;!-- 修改启动端口号 --&gt; &lt;Connector port="7090" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="7443" maxThreads="150" maxSpareThreads="75" /&gt; &lt;Connector port="7009" protocol="AJP/1.3" redirectPort="7443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + logback 日志配置]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AElogback%2F</url>
    <content type="text"><![CDATA[SpringBoot + logback 日志配置 SpringBoot 使用 logback-spring.xml 生成日志文件 注: 参考配置1参考配置2 logback配置文件命名 自定义日志配置 创建名为 logback.xml、logback-xxx.xml的文件,需要在 application.yml/application.properties文件中指定加载的配置文件路径 12logging: config: classpath:logback.xml 注：官方推荐将logback-spring.xml放在根目录下,可以省略上述步骤. logback-spring.xml配置 指定日志文件输出路径、文件名 123logback: logdir: D:/safeCity/logs name: safeCity 注: 当前环境为window为包含盘符的绝对路径,linux环境需要修改为不含盘符的绝对路径 logback-spring.xml配置文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="tue" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- application.yml 传递参数，不能使用logback 自带的&lt;property&gt;标签 --&gt; &lt;!-- 日志输出路径,在yml文件中配置 --&gt; &lt;springProperty scope="context" name="logdir" source="logback.logdir"/&gt; &lt;!-- 文件名 --&gt; &lt;springProperty scope="context" name="logName" source="logback.name"/&gt; &lt;!-- 输出到控制台 Consoleappender --&gt; &lt;appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 展示格式 layout --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- infoLog 输出 --&gt; &lt;appender name="fileInfoLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 如果只是想要 info 级别的日志,只是过滤 info 还是会输出 error 日志,因为 Error 的日志级别更高。 使用下面的策略,可以避免输出 Error 日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;!-- 过滤 Error --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;!-- 匹配到就禁止 --&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;!-- 没有匹配到就允许 --&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 日志名称,如果没有 File 属性,name只会使用FileNamePattern的文件路径规则 如果同时又&lt;File&gt;和&lt;FileNamePattern&gt;,那么当天日志时&lt;File&gt;.明天会自动把今天的日志名改为今天的日期 即：&lt;File&gt; 的日志都是当天的。 --&gt; &lt;File&gt;$&#123;logdir&#125;/info.$&#123;logName&#125;.log&lt;/File&gt; &lt;!-- 滚动策略,按照时间滚动 TimeBasedRollingPolicy --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件路径,定义了日志的切分方式 把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间 --&gt; &lt;FileNamePattern&gt;$&#123;logdir&#125;/info.$&#123;logName&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!-- 设置 日志保留时间 30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 用来指定日志文件的上限大小,到上限之后会删除旧日志 --&gt; &lt;!-- &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; --&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出编码格式化 --&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- Error 级别日志文件 --&gt; &lt;appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 如果只是想要 Error 级别的日志,那么需要过滤一下.默认是info 级别的,ThresholdFilter --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter" &gt; &lt;level&gt;Error&lt;/level&gt; &lt;/filter&gt; &lt;!-- 日志名称,如果没有 File 属性,name只会使用FileNamePattern的文件路径规则 如果同时又&lt;File&gt;和&lt;FileNamePattern&gt;,那么当天日志时&lt;File&gt;.明天会自动把今天的日志名改为今天的日期 即：&lt;File&gt; 的日志都是当天的。 --&gt; &lt;File&gt;$&#123;logdir&#125;/error.$&#123;logName&#125;.log&lt;/File&gt; &lt;!-- 滚动策略,按照时间滚动 TimeBasedRollingPolicy --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件路径,定义了日志的切分方式 把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间 --&gt; &lt;FileNamePattern&gt;$&#123;logdir&#125;/error.$&#123;logName&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!-- 设置 日志保留时间 30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 用来指定日志文件的上限大小,到上限之后会删除旧日志 --&gt; &lt;!-- &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; --&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出编码格式化 --&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 开发环境日志级别为DEBUG ,可以使用逗号分隔列表指定多个配置文件 --&gt; &lt;springProfile name="dev"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="consoleLog" /&gt; &lt;appender-ref ref="fileInfoLog" /&gt; &lt;appender-ref ref="fileErrorLog" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 配置文件标签说明 根节点&lt;configuration&gt;包含的属性 scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 注: 依照本文配置,可在指定路径中生成自定义的日志文件名(info与error日志分开,默认当前日志为application.yml中的logging.name作为文件名可自行定义)。历史日志文件名 增加日期格式]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Log]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SpringBoot Log Transactional事务回滚 12345678910//方法上增加注解@Transactional(rollbackOn = Exception.class)public void example() &#123; try &#123; &#125; catch (Exception e) &#123; // 设置异常时执行回滚 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); &#125;&#125; 配置类序列化失败 问题描述： 将配置类使用 JackSon 序列化时，出现序列化异常 SpringBoot请求跨域 12345678910111213141516171819202122232425262728293031323334package com.learnning.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;/** * * @ClassName: CustomCORSConfiguration * @Description: 配置跨域请求访问失败的问题 * @author time * @date 2018/11/21 */@Configurationpublic class CustomCORSConfiguration &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); return new CorsFilter(source); &#125;&#125; 注: 引用链接: 周立解决方案 SpringBoot JPA查询传参 使用占位符? 12@Query(value = "select account_id,user_name,validity from t_account where account_id = ?", nativeQuery = true)User findByAccount_id(Long account_id); 使用命名化参数:name 12@Query(value = "select account_id,user_name,validity from t_account where account_id =:id", nativeQuery = true)User findByAccount_id(@Param("id") Long account_id); 注: 参考Spring Data JPA系列: 使用@Query注解（Using @Query）]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 在线文档地址]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SpringBoot 在线文档地址 SpringBoot 在线文档地址英文版中文版 15.1 在main函数类中使用@Import注解1You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes. 释义： 您无需将所有@Configuration放入单个类中。 @Import注释可用于导入其他配置类。或者，您可以使用@ComponentScan自动获取所有Spring组件，包括@Configuration类。 24.56 使用Java类加载 配置文件参数值 配置类 1234567891011121314151617181920212223242526 @ConfigurationProperties("foo") public class FooProperties &#123; private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;(); public List&lt;MyPojo&gt; getList() &#123; return this.list; &#125; &#125; ``` * 注: 推荐使用构造函数的方式注入属性值&gt; 配置文件 ```ymlfoo: list: - name: my name description: my description---spring: profiles: devfoo: list: - name: my another name]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Hikari +JPA 多数据源]]></title>
    <url>%2FSpringBoot%2FHikari%2FSpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90JPA%2F</url>
    <content type="text"><![CDATA[SpringBoot + Hikari +JPA 多数据源 SpringBoot2.0 Hikari 多数据源 —— JPA SpringBoot 连接多数据源使用 JPA 查询应用记录. pom.xml依赖配置12345&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 注：SpringBoot 2.0默认的数据连接池为Hikari，故不需要添加 Hikari 依赖 多数据源配置 primaryDataSource 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.learnning.config;import javax.persistence.EntityManager;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.zaxxer.hikari.HikariDataSource;/** * * @ClassName: HikariDataSourceConfig * @Description: Hikari 多数据源配置(第一数据源配置) * @author time * @date 2018/10/29 * &#123;@link &#123;@link http://blog.didispace.com/springbootmultidatasource/&#125;&#125; */@Configuration@EnableTransactionManagement@EnableJpaRepositories(entityManagerFactoryRef = "primaryEntityManagerFactory", // transactionManagerRef = "primaryTransactionManager", // basePackages = &#123; "com.learnning.domain.p" &#125;) // 设置Repository所在位置public class PrimaryConfig &#123; @Primary @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Primary @Bean(name = "primaryEntityManager") public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return primaryEntityManagerFactory(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = "primaryEntityManagerFactory") public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return builder// .dataSource(primaryDataSource()) // .packages("com.learnning.domain.p")// .persistenceUnit("primaryPersistenceUnit")// .build(); &#125; @Primary @Bean(name = "primaryTransactionManager") public PlatformTransactionManager transactionManager(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(primaryEntityManagerFactory(builder).getObject()); &#125;&#125; sencondaryDataSource 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.learnning.config;import javax.persistence.EntityManager;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.zaxxer.hikari.HikariDataSource;/** * * @ClassName: HikariDataSourceConfig * @Description: Hikari 多数据源配置(第一数据源配置) * @author time * @date 2018/10/29 * &#123;@link &#123;@link http://blog.didispace.com/springbootmultidatasource/&#125;&#125; */@Configuration@EnableTransactionManagement@EnableJpaRepositories(entityManagerFactoryRef = "secondaryEntityManagerFactory", // transactionManagerRef = "secondaryTransactionManager", // basePackages = &#123; "com.learnning.domain.s" &#125;) // 设置Repository所在位置public class SecondaryConfig &#123; @Bean(name = "sencondaryDataSource") @Qualifier(value = "sencondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.secondary") public DataSource sencondaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "secondaryEntityManager") public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return secondaryEntityManagerFactory(builder).getObject().createEntityManager(); &#125; @Bean(name = "secondaryEntityManagerFactory") public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return builder// .dataSource(sencondaryDataSource()) // .packages("com.learnning.domain.s")// .persistenceUnit("secondaryPersistenceUnit")// .build(); &#125; @Bean(name = "secondaryTransactionManager") PlatformTransactionManager transactionManager(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(secondaryEntityManagerFactory(builder).getObject()); &#125;&#125; JPA 使用多数据源查询划重点： JPA的entity与table因为有映射关系，所以实体类路径需要映射到对应的DataSource中 JPA查询接口最好也根据不同数据源区分开 primary数据源配置 primary数据源实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.learnning.domain.p;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name = "t_account")public class User &#123; @Id @GeneratedValue private Long account_id; private String user_name; private Integer validity; public Long getAccount_id() &#123; return account_id; &#125; public void setAccount_id(Long account_id) &#123; this.account_id = account_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getValidity() &#123; return validity; &#125; public void setValidity(Integer validity) &#123; this.validity = validity; &#125; @Override public String toString() &#123; return "&#123;\"account_id\":\"" + account_id + "\",\"user_name\":\"" + user_name + "\",\"validity\":\"" + validity + "\"&#125;"; &#125;&#125; primary 数据源Repository 1234567891011121314151617181920212223package com.learnning.domain.p.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import com.learnning.domain.p.User;public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; /** * * @Title: findByAccount_id * @Description: 查询用户 User 信息 * nativeQuery：指定为原生SQL查询 * @param account_id * @return * User */ /// 模糊匹配 @Query(value = "select account_id,user_name,validity from t_account where account_id = ?", nativeQuery = true) User findByAccount_id(Long account_id);&#125; secondary 数据源配置 secondary 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.learnning.domain.s;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name = "t_user")public class PopUser &#123; @Id @GeneratedValue private Long pop_id; private String pop_name; private String ip_start; private String ip_end; private String netmask; private String description; private String start_num; private String end_num; private String platform; private Integer ipgap; private Integer pop_type; public Long getPop_id() &#123; return pop_id; &#125; public void setPop_id(Long pop_id) &#123; this.pop_id = pop_id; &#125; public String getPop_name() &#123; return pop_name; &#125; public void setPop_name(String pop_name) &#123; this.pop_name = pop_name; &#125; public String getIp_start() &#123; return ip_start; &#125; public void setIp_start(String ip_start) &#123; this.ip_start = ip_start; &#125; public String getIp_end() &#123; return ip_end; &#125; public void setIp_end(String ip_end) &#123; this.ip_end = ip_end; &#125; public String getNetmask() &#123; return netmask; &#125; public void setNetmask(String netmask) &#123; this.netmask = netmask; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getStart_num() &#123; return start_num; &#125; public void setStart_num(String start_num) &#123; this.start_num = start_num; &#125; public String getEnd_num() &#123; return end_num; &#125; public void setEnd_num(String end_num) &#123; this.end_num = end_num; &#125; public String getPlatform() &#123; return platform; &#125; public void setPlatform(String platform) &#123; this.platform = platform; &#125; public Integer getIpgap() &#123; return ipgap; &#125; public void setIpgap(Integer ipgap) &#123; this.ipgap = ipgap; &#125; public Integer getPop_type() &#123; return pop_type; &#125; public void setPop_type(Integer pop_type) &#123; this.pop_type = pop_type; &#125; @Override public String toString() &#123; return "&#123;\"pop_id\":\"" + pop_id + "\",\"pop_name\":\"" + pop_name + "\",\"ip_start\":\"" + ip_start + "\",\"ip_end\":\"" + ip_end + "\",\"netmask\":\"" + netmask + "\",\"description\":\"" + description + "\",\"start_num\":\"" + start_num + "\",\"end_num\":\"" + end_num + "\",\"platform\":\"" + platform + "\",\"ipgap\":\"" + ipgap + "\",\"pop_type\":\"" + pop_type + "\"&#125;"; &#125;&#125; secondary 数据源 Repository 123456789101112131415package com.learnning.domain.s.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import com.learnning.domain.s.PopUser;public interface PopUserRepository extends JpaRepository&lt;PopUser, Long&gt; &#123; @Query(value = "select pop_name,pop_id,ip_start,ip_end,netmask,description,start_num,end_num,platform,ipgap,pop_type from t_user where rownum&lt;= 10", nativeQuery = true) List&lt;PopUser&gt; queryPopUserPage1();&#125; 测试类123456789101112131415@Autowiredprivate UserRepository userRepository;@Autowiredprivate PopUserRepository popUserRepository;@Testpublic void testPrimarySession() &#123; User users = userRepository.findByAccount_id(1L); System.out.println(users.toString()); List&lt;PopUser&gt; page = popUserRepository.queryPopUserPage1(); System.out.println(page.toString());&#125; 注： SpringBoot官方建议使用构造函数的方式注入依赖，上述测试代码为在测试类中使用. 使用构造函数注入如下： 123456789private UserRepository userRepository;private PopUserRepository popUserRepository;@Autowiredpublic MyErrorController(UserRepository userRepository, PopUserRepository popUserRepository) &#123; this.userRepository = userRepository; this.popUserRepository = popUserRepository;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Hikari</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Hikari</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康威定律与微服务的关系]]></title>
    <url>%2FBlog%2F%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[康威定律与微服务的关系 康威定律与微服务的关系康威第一定律 人类是复杂的社会动物 康威第二定律罗马不是一天建成的，学会先解决首要问题 康威第三定律创建独立的子系统，减少沟通成本 总结前面提到，人类是复杂的社会动物，人与人之间的交流是非常复杂的，当涉及到一个系统时，人们经常选择增加人力去减少复杂性，对于企业来说，该如何处理这样的沟通问题？答案是：分而治之。 看看公司内，一名经理管理的员工一般少于15个，二三线经理管理的员工要更少，因此，大企业通常会将团队拆成一个个小团队或部门减少沟通成本及管理的问题，有一些需要考虑的场景： 创业的项目很好，拿到一大笔风投，再招募更多的程序员 人员太多，需要找几个经理进行管理 康威定律好告诉我们，可以从系统设计中看出组织通信的模式，每个经理要对大系统的某一小部分负责，通过这种方式，它们和更大的系统间沟通有了便捷，因此大的系统也会被拆分成一个个小系统。（微服务可以更好地服务于此) 康威定律与微服务康威定律是如何在半个世纪前就奠定了微服务理论基础的 人与人之间的交流很复杂，每个人的精力都是有限的，因此当问题很复杂需要协调的去解决时，需要将组织划分进而提高沟通效率。 团队成员工作的系统设计依赖于成员之间的沟通，管理人员可以调整划分模式，实现团队之间的不同沟通方式，这也会影响系统的设计。 如果子系统有清晰的外部通信便捷，那么就可以有效的降低通信成本，相应的设计将更加适合和有效。 需要不断优化一个复杂的系统，并容错性和故障恢复率的帮助下进行优化，不要期望大而全面额设计或架构，因为它们的开发以迭代的方式发生。 具体的实践建议： 利用一切手段提高通信效率，如Slack、GitHub、Wiki，且至于相关人员进行沟通，每个人和每个系统必须有明确的职责，在遇到问题时，知道找谁去解决。 在MVP模式下设计一套系统，以迭代的方式优化及验证，并确保系统的弹性。 采用与系统设计相一致的团队，以扁平化和以业务为基准的方式去简化团队，每个小团队之间必须有对应负责的模块，避免模糊的界限，可以在发生问题时定义责任承担者。 精简团队规模，求精而不将就。人员数量的增加在降低效率的同时也在增加投入成本，亚马逊CEO Jeff Bezos的经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。互联网公司的产品团队普遍由7-8人组成(包括前端和后端测试、交互和用户体验师，一人可能身兼数职)。 在查看以下微服务标准时，更能体现微服务与康威定律间的关系： 由分布式服务组成的系统 企业部门的业务线 开发优秀的产品 Smart endpoints and dumb pipes DevOps 容错 快速发展 内容来源：简化自翟永超文章]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 使用自定义 Swagger2]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E6%95%B4%E5%90%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84SwaggerAPI%2F</url>
    <content type="text"><![CDATA[SpringBoot 使用自定义 Swagger2 SpringBoot 整合 Swagger2 | 自定义 swagger-spring-boot-starter 注: 传统的后端开发人员与其他前端或APP端需共同制定API接口文档，Swagger2 将文档变成可更新的在线版本，并且支持在线测试可以提高沟通效率和规范接口说明. 自定义 swagger-spring-boot-starter 的依赖，我所知道的分别有 唐亚峰 12345&lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5-RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring4all社区版 12345&lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.7.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 前提： 创建 SpringBoot 项目(也可以是SpringMVC项目，配置方法另行百度咯) 第一种：使用 Swagger 原生依赖配置创建SpringBoot应用，添加pom.xml依赖项目创建完成完整依赖如下： 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建 Swagger2配置类 创建API组 注: 本文创建的是API组，故Swagger2Config配置类中有多个。只需要创建单个API组时无需创建两个 Docke @Bean实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.learning.config;import org.springframework.context.annotation.Bean;import org.springframework.web.context.request.async.DeferredResult;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * Swagger2 配置类, * 不使用@Configuration 注解是可以在 SwaggerApplication.class 中使用@Import注解代替 * @ClassName: Swagger2Config * @Description: TODO * @Created by time on 2018/07/19 */ @Configuration public class Swagger2Config &#123; /** * 第一组 API */ private final String BASEPACKAGE ="com.learning.controller"; private final String BASEPACKAGE2 ="com.learning.group"; /** * 定义单个 API * */ @Bean public Docket createApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName("用户相关API") .genericModelSubstitutes(DeferredResult.class) .useDefaultResponseMessages(false) .forCodeGeneration(true) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(BASEPACKAGE)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("SpringBoot 官方版 Swagger 构建RESTful文档") .description("SpringBoot应用在线调试文档") .termsOfServiceUrl("http://www.baidu.com") .contact(new Contact("author", "http://baidu.com", ""))//名字，地址，邮箱 .version("1.0") .build(); &#125; /** * 定义 API 组 */ @Bean public Docket innerApi() &#123; return new Docket(DocumentationType.SWAGGER_12) .groupName("innerApi") .genericModelSubstitutes(DeferredResult.class) .useDefaultResponseMessages(false) .forCodeGeneration(true) .select() .apis(RequestHandlerSelectors.basePackage(BASEPACKAGE2)) .paths(PathSelectors.any()) .build() .apiInfo(innerApiInfo()); &#125; private ApiInfo innerApiInfo() &#123; return new ApiInfoBuilder() .title("SpringBoot 官方版 Swagger 构建RESTful文档") .description("SpringBoot应用在线调试文档") .termsOfServiceUrl("http://www.baidu.com") .contact(new Contact("程序员DD", "http://blog.didispace.com", "")) .version("1.0") .build(); &#125;&#125; 修改Application.class中增加@Import 12// 增加 Class 类注解@Import(value= &#123;Swagger2Config.class&#125;) 创建带有Swagger注解实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.learning.entity.vo;import java.io.Serializable;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * 用户视图实体类 * @ClassName: UserVO * @Description: TODO * @Created by time on 2018/07/18 */@ApiModel(value = "用户实体类")public class UserVO implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = "账户", required = true) private String account; @ApiModelProperty(value = "姓名", required = true) private String name; @ApiModelProperty(value = "昵称", required = true) private String nickName; public UserVO() &#123; &#125; public UserVO(String account, String name, String nickName) &#123; this.name = name; this.nickName = nickName; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; UserVO other = (UserVO) obj; if (account == null) &#123; if (other.account != null) return false; &#125; else if (!account.equals(other.account)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; if (nickName == null) &#123; if (other.nickName != null) return false; &#125; else if (!nickName.equals(other.nickName)) return false; return true; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; @Override public String toString() &#123; return "UserVO [account=" + account + ", name=" + name + ", nickName=" + nickName + "]"; &#125;&#125; 创建带有Swagger注解的controller另一个Controller与下面的一致，就不贴代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.learning.controller;import java.util.ArrayList;import java.util.List;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.learning.entity.vo.UserVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiResponse;import io.swagger.annotations.ApiResponses;/** * * @ClassName: UserController * @Description: 用户管理 * @author time * @date 2018/11/20 */@RestController@RequestMapping(value = "/user")@Api(value = "UserManager", tags = &#123; "用户管理" &#125;)public class UserController &#123; /** * * @Title: getUser * @Description: 获取用户list * @param userName * @param password * @return * List&lt;UserVO&gt; */ @ApiOperation("获取用户相关信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "userName", dataType = "String", required = true, value = "用户的姓名", defaultValue = "张飞"), @ApiImplicitParam(paramType = "query", name = "password", dataType = "String", required = true, value = "用户的密码", defaultValue = "wangga") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "/getUser", method = RequestMethod.POST) public List&lt;UserVO&gt; getUser(@RequestParam("userName") String userName, @RequestParam("password") String password) &#123; System.out.print("logger.in:getUser---------"); UserVO info = new UserVO("test01", "测试账户一", "士兵"); UserVO info2 = new UserVO("test02", "测试账户二", "将领"); UserVO info3 = new UserVO("test03", "测试账户三", "元帅"); List&lt;UserVO&gt; list = new ArrayList&lt;&gt;(); list.add(info); list.add(info2); list.add(info3); return list; &#125; /** * * @Title: queryUserInfo * @Description: 查询用户详细信息 * @param id * @return * Object */ @ApiOperation(value = "查询用户详细信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "queryUserInfo/&#123;id&#125;", method = RequestMethod.GET) public Object queryUserInfo(@PathVariable("id") Long id) &#123; UserVO info = new UserVO("士兵" + id, "00" + id, "张三" + id); return info; &#125; /** * * @Title: modifyUserInfo * @Description: 修改用户信息 * @param id * @param UserVO * @return * Object */ @ApiOperation(value = "修改用户信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1"), @ApiImplicitParam(paramType = "body", name = "User", dataType = "User", value = "修改的用户信息") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者跳转页面错误") &#125;) @RequestMapping(value = "modifyUserInfo", method = RequestMethod.POST) public Object modifyUserInfo(@RequestParam("id") Long id, @RequestBody UserVO UserVO) &#123; System.out.print("-----------modifyUserInfo:" + UserVO.toString()); UserVO.setAccount(++id + ""); return UserVO; &#125; /** * * @Title: delUserById * @Description: 删除用户信息 * @param id * @return * String */ @ApiOperation(value = "删除用户信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径异常,或者跳转页面错误") &#125;) @RequestMapping(value = "delUserById/&#123;id&#125;", method = RequestMethod.DELETE) public String delUserById(@PathVariable(value = "id", required = true) Long id) &#123; System.err.print("-----del"); return "success"; &#125;&#125; RESTful接口 Swagger 注解说明 @Api： 描述Controller value：文档页面不显示 tags:数组类型（{“…”,”…”}）；显示 @ApiIgnore： 忽略该Controller，指不对当前类做扫描 @ApiOperation： 描述Controller类中的method接口 @ApiParam： 单个参数描述，与@ApiImplicitParam不同的是，他是写在参数左侧的。如（@ApiParam(name = &quot;username&quot;,value = &quot;用户名&quot;) String username） @ApiModel： 描述POJO对象 @ApiProperty： 描述POJO对象中的属性值 @ApiImplicitParam： 描述单个入参信息 @ApiImplicitParams： 描述多个入参信息 @ApiResponse： 描述单个出参信息 @ApiResponses： 描述多个出参信息 @ApiError： 接口错误所返回的信息 第二种: 使用自定义 Swagger 依赖配置创建SpringBoot项目 添加pom.xml中的依赖 注: 替换上述的swagger dependency为下方依赖即可** 12345&lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5-RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改application.yml配置文件，定义在线接口显示内容 123456789spring: swagger: base-package: com.learning.controller enabled: true title: Swagger API文档说明 description: 在线调试文档 version: 1.0 contact: name: Time Machine 修改主函数Application.class，添加@EnableSwagger2Doc注解 注: 只需要按照Swagger的注解创建controller与entity即可，无需SwaggerConfig配置类]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
</search>
