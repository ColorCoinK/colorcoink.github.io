<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL解压版安装]]></title>
    <url>%2Fblog%2FMySQL%E8%A7%A3%E5%8E%8B%E7%89%88%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[MySQL 8.0 版本使用.zip文件安装过程中遇到的一些问题,整理成了文章为同样遇到问题的你提供参考。ERROR 1130 (HY000) Host &#39;xx-PC&#39; is not allowed to connect to this MySQL server错误的解决方案 MySQL解压后遇到的一些问题总结 MySQL下载路径: https://dev.mysql.com/downloads/mysql/ 运行环境 Windows: Windows 7 MySQL版本: mysql-8.0.11-winx64 环境配置 文件解压 解压后的路径: D:\Program Files (x86)\mysql-8.0.11-winx64 系统环境变量 新建MYSQL_HOME:D:\Program Files (x86)\mysql-8.0.11-winx64; 添加PATH:%MYSQL_HOME%\bin; 或者 添加PATH: D:\Program Files (x86)\mysql-8.0.11-winx64\bin 注:选择两种方式中的一种都可以(对后续步骤无影响),根据自身喜好决定 MySQL配置 配置文件 在D:\Program Files (x86)\mysql-8.0.11-winx64(本地MySQL安装路径)下新建my.ini.txt名字的文件(文件名及文件格式需一致)。 123456789101112131415161718# 设置端口号port=3306# 设置MySQL安装路径basedir=D:\Program Files (x86)\mysql-8.0.11-winx64# 设置MySQL数据库的存放目录datadir=D:\Program Files (x86)\mysql-8.0.11-winx64\data# 允许最大连接数max_connections=200# 允许连接失败的次数max_connect_errors=10# 服务端使用的字符集默认为UTF-8character-set-server=utf8# 创建新表时将使用默认的存储引擎default-storage-engine=INNODB# 使用默认时区为东八区default-time-zone='+8:00'# 密码# root@localhost: &amp;i4heQcySo;L 执行MySQL安装命令 使用管理员权限运行CMD,进入MySQL安装路径 1mysqld --install mysql 注： 如果之前有安装其他版本的mysql服务器名称,可以使用mysql-version在mysql后添加自定义的版本名称区分开;可选择删除之前的版本,mysqld remove mysql; 安装时会生成初始化密码,密码在root@localhost:的后面(需要及时保存,后续需要登录MySQL修改密码)。 再次启动服务器 1net start mysql 如果出现ERROR 1130 (HY000): Host &#39;xx-PC&#39; is not allowed to connect to this MySQL server类似错误,后续有解决方法 修改密码 新开一个CMD窗口,进入安装MySQL_HOME\bin的路径, 1234567891011121314151617D:\Program Files (x86)\mysql-8.0.11-winx64\bin&gt;mysql -uroot -p # 使用临时密码登录Enter password: ****Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 7Server version: 8.0.11 MySQL Community Server - GPLCopyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; use mysqlDatabase changedmysql&gt; alter user user() identified by &apos;root&apos;; 之后便能使用root@localhost: root账号和密码登录了,当前设置密码为root可以自行修改 解决问题 ERROR 1130 (HY000): Host &#39;xx-PC&#39; is not allowed to connect to this MySQL server 这是因为MySQL用的是电脑的名字登录,而不是数据库初始化默认的localhost地址。 解决方法 管理员启动CMD并进入D:\Program Files (x86)\mysql-8.0.11-winx64\bin&gt;执行下列语句,使用跳过验证的方式启动mysql。 1D:\Program Files (x86)\mysql-8.0.11-winx64\bin&gt;mysqld --console --skip-grant-tables --shared-memory 新开一个CMD窗口,使用mysql -uroot -p登录;然后修改user表内的root用户信息;将root账号host改为对应的账号名字(有可能你的并不是xx-PC,这个要根据实际情况调整) 执行SQL 123mysql&gt; update user set host='xxx-PC' where user='root';Query OK, 1 row affected (0.12 sec)Rows matched: 1 Changed: 1 Warnings: 0 修改之前 123456789mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | mysql.infoschema || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+ 修改之后 12345678910mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | dew || localhost | mysql.infoschema || localhost | mysql.session || localhost | mysql.sys || xxx-PC | root |+-----------+------------------+ 改完之后就能使用net start mysql语句启动后使用root@xxx-PC的方式连接数据库了;可以新建一个账号实现localhost的登录。 创建数据库登录用户的SQL 1create user 'dew'@'localhost' identified by 'root'; 无法使用新增的账号访问数据库 123-- grant all privileges on `数据库名字`.* to `新建账号`@'localhost';grant all privileges on dew_boot_learning.* to dew@'localhost'; 注:希望我记录的解决方法能帮到你,如果你在实际过程中遇到其他的问题。可以在文章下留言,我看到后会及时回复。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat服务器端部署配置案例]]></title>
    <url>%2Fblog%2FTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Tomcat服务器端部署配置案例 执行shutdown.sh的同时kill -9 PID简化 修改$TOMCAT_HOME/bin/catalina.sh配置 配置Tomcat运行的JDK路径 123456789101112export JAVA_HOME=#设置为服务器的JDK路径 /jdk1.8.0_101export JRE_HOME=#设置为服务器的JRE路径 /jdk1.8.0_101/jreexport CATALINA_HOME=/apache-tomcat-8.5.40export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC'# specify jdk versionJAVA_HOME=# JDK路径 /jdk1.8.0_101JRE_HOME=# JRE 路径 /usr/java/jdk1.8.0_101/jre 查询服务器JDK路径 1echo $JAVA_HOME 生成Tomcat运行时的进程文件,关闭时不需要执行kill -9 pid命令(也是在catalina.sh文件内,注释的近几十行找到#Get standard environment variables就可以了) 12345# Get standard environment variablesPRGDIR=`dirname "$PRG"`if [ -z "$CATALINA_PID" ]; then CATALINA_PID=$PRGDIR/CATALINA_PIDfi 修改$TOMCAT_HOME/bin/shutdown.sh文件 shutdown.sh文件的最后一行,修改后变成如下所示(增加-force) 1exec "$PRGDIR"/"$EXECUTABLE" stop -force "$@" 多个项目部署为不同Tomcat时可以通过修改$TOMCAT_HOME/conf/server.xml中的8005端口只关闭指定端口 首行 1&lt;Server port="1005" shutdown="SHUTDOWN"&gt; 自定义端口 123&lt;Connector port="1009" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 目录遍历Bug方法一：指定自定义目录为Tomcat访问路径(Tomcat通过端口遍历webapps下的文件目录) 修改$TOMCAT_HOME/conf/server.xml 123&lt;Host name="localhost" appBase="$DEPLOY_PATH" unpackWARs="true" autoDeploy="true"&gt;&lt;/Host&gt; 注 $DEPLOY_PATH: WEB程序部署路径 方法二: 删除$TOMCAT_HOME/webapps/文件夹下的非项目文件(ROOT目录可删可不删)1rm -rf $TOMCAT_HOME/webapps/* 注 删除文件需注意所在文件夹位置,可使用pwd命令确认路径是否正确 中间件版本泄露漏洞 将Tomcat中的catalina.jar解压 unzipi $TOMCAT_HOME/lib/catalina.jar 得到META-INF、org两个文件夹 修改Tomcat中的/opt/tomcat-iptvview/apache-tomcat-8.5.56/lib/org/apache/catalina/util/ServerInfo.properties 123[root@CDH44 bin]# pwd/opt/tomcat-iptvview/apache-tomcat-8.5.56/bin[root@CDH44 bin]# vi /opt/tomcat-iptvview/apache-tomcat-8.5.56/lib/org/apache/catalina/util/ServerInfo.properties 修改后的文件内容 123server.info=Apache Tomcatserver.number=0.0.0.0server.built=Jun 3 2020 20:18:30 UTC 注: 修改了server.info后的版本号;server.number的版本号为0.0.0.0 将修改后的信息压缩回jar包 123456[root@CDH44 lib]# vi ./org/apache/catalina/util/ServerInfo.properties [root@CDH44 lib]# pwd/opt/tomcat-iptvview/apache-tomcat-8.5.56/lib[root@CDH44 lib]# jar uvf catalina.jar ./org/apache/catalina/util/ServerInfo.properties adding: org/apache/catalina/util/ServerInfo.properties(in = 885) (out= 513)(deflated 42%)[root@CDH44 lib]#]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot初始化数据库脚本]]></title>
    <url>%2Fspringboot%2FSpringBoot%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[SpringBoot 1.x 与SpringBoot 2.x版本初始化脚本时的区别;使用Druid连接池时初始化数据库脚本。 SpringBoot 1.x启动时初始化脚本 注: 案列中使用的是JPA,在application.yml文件中增加了相关配置;使用的是H2数据库(可根据实际情况修改数据库连接配置) Maven依赖及配置 项目结构 123456789├─java│ │ └─com│ │ └─learning│ │ │ ProviderApplication.java│ │ │ └─resources│ application.yml│ data.sql│ schema.sql 版本信息 SpringBoot版本:&lt;version&gt;1.5.12.RELEASE&lt;/version&gt; 项目依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; application.yml文件内容123456789101112131415161718192021222324server: port: 2001spring: application: name: microsevice-provider-user datasource: # 指定数据源;默认H2建表脚本(根目录/schema.sql);默认H2的insert脚本(classpath:data.sql) url: jdbc:h2:mem:~/example-app; # 指定数据库,默认 platform: h2 username: sa password: driver-class-name: org.h2.Driver h2: console: enabled: true # 是否启用H2数据库控制台 settings: web-allow-others: true # 允许远程浏览器访问H2 数据库控制台 trace: false jpa: show-sql: true hibernate: ddl-auto: none generate-ddl: false database-platform: org.hibernate.dialect.H2Dialect 脚本内容 脚本名称说明(机翻自官网) Spring Boot可以自动创建数据源的架构（DDL脚本）并对其进行初始化（DML脚本）。它从标准根类路径位置（分别为schema.sql和data.sql）加载SQL。另外，Spring Boot处理schema-$ {platform} .sql和data-$ {platform} .sql文件（如果存在），其中platform是spring.datasource.platform的值。这使您可以在必要时切换到特定于数据库的脚本。例如，您可以选择将其设置为数据库的供应商名称（hsqldb，h2，oracle，mysql，postgresql等）。 data.sql 12345678910drop table if exists tbl_account;create table tbl_account( id number(12) not null , name varchar not null, age int(2) not null , sex char(2) not null , password varchar(80) not null , role varchar(10) not null); schema.sql 12345678910insert into tbl_account (id,name,age,sex,password,role) values (1001,'admin',18,'男','1','ROLE_ADMIN');insert into tbl_account (id,name,age,sex,password,role) values (1002,'zy',25,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1003,'lb',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1004,'lk',22,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1005,'zj',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1006,'lc',21,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1007,'wdd',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1008,'ln',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1009,'gy',20,'女','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1010,'dew',35,'男','1','ROLE_USER'); SpringBoot 2.x启动时初始化脚本 注: 需要在SpringBoot 1.x的application.yaml中增加属性,示例如下 1spring.datasource.initialization-mode=always application.yml完整内容 123456789101112131415161718192021222324server: port: 2002spring: application: name: sofa-account datasource: # 指定数据源;默认H2建表脚本(根目录/schema-h2.sql);默认H2的insert脚本(classpath:data-h2.sql) url: jdbc:h2:mem:~/example-app; # 指定数据库,默认 platform: h2 username: sa password: driver-class-name: org.h2.Driver initialization-mode: always # SpringBoot 2.0 中需要添加的属性配置 h2: console: enabled: true # 是否启用H2数据库控制台 settings: web-allow-others: true # 允许远程浏览器访问H2 数据库控制台 trace: false jpa: show-sql: true hibernate: ddl-auto: none generate-ddl: false database-platform: org.hibernate.dialect.H2Dialect SpringBoot 2.0使用Druid连接池初始化脚本Maven依赖及配置 SpringBoot 默认的数据库连接池为Hikari,本文中使用的是Druid而已;配置和Hikari应该是一样的,如果有不同烦请告知。 项目结构 123456789101112131415161718192021├─main│ ├─java│ │ └─com│ │ └─dew│ │ │ Application.java│ │ │ │ │ ├─config│ │ │ DruidDataSourceConfig.java│ │ │ └─resources│ application.yaml│ bootstrap.yaml│ data.sql│ schema.sql│ └─test └─java └─com └─dew ├─config │ DruidDataSourceConfigTest.java 版本信息 SpringBoot版本: &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; 项目依赖 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt;&lt;/dependency&gt; application.yml文件内容123456789101112131415161718192021222324252627282930313233343536373839server: port: 2001spring: application: name: sofa-authentication datasource: type: com.alibaba.druid.pool.DruidDataSource druid: initial-size: 5 min-idle: 5 max-active: 20 stat-view-servlet: login-username: admin login-password: admin max-wait: 60000 time-between-eviction-runs-millis: 60000 # 配置间隔多久才进行一次检测,检测需要关闭的空闲连接.单位是毫秒 min-evictable-idle-time-millis: 300000 # 配置一个连接池中最小生存的时间,单位是毫秒 ## 配置监控统计拦截的filters,去掉后监控界面SQL无法进行统计,`wall`用于防火墙(https://blog.csdn.net/garyond/article/details/80189939) filters: config,stat,wall,log4j web-stat-filter: exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' ## 多数据源的标识,若该属性存在则为多数据源环境,不存在则为但数据源环境 data-sources: primary: url: jdbc:h2:mem:~/example-app # 指定数据库,默认 username: sa password: secondary: url: jdbc:h2:mem:~/example-app # 指定数据库,默认 username: sa password: async-init: true initialization-mode: always h2: console: enabled: true # 是否启用H2数据库控制台 settings: web-allow-others: true # 允许远程浏览器访问H2 数据库控制台 trace: false 脚本内容 与上述一致,为方便查看copy了一下 脚本名称说明(机翻自官网) Spring Boot可以自动创建数据源的架构（DDL脚本）并对其进行初始化（DML脚本）。它从标准根类路径位置（分别为schema.sql和data.sql）加载SQL。另外，Spring Boot处理schema-$ {platform} .sql和data-$ {platform} .sql文件（如果存在），其中platform是spring.datasource.platform的值。这使您可以在必要时切换到特定于数据库的脚本。例如，您可以选择将其设置为数据库的供应商名称（hsqldb，h2，oracle，mysql，postgresql等）。 data.sql 12345678910drop table if exists tbl_account;create table tbl_account( id number(12) not null , name varchar not null, age int(2) not null , sex char(2) not null , password varchar(80) not null , role varchar(10) not null); schema.sql 12345678910insert into tbl_account (id,name,age,sex,password,role) values (1001,'admin',18,'男','1','ROLE_ADMIN');insert into tbl_account (id,name,age,sex,password,role) values (1002,'zy',25,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1003,'lb',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1004,'lk',22,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1005,'zj',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1006,'lc',21,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1007,'wdd',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1008,'ln',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1009,'gy',20,'女','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1010,'dew',35,'男','1','ROLE_USER'); 数据源配置 DruidDataSourceConfig 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.dew.config;import com.alibaba.druid.pool.DruidDataSource;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;/** * @ClassName DruidDataSourceConfig * @Description &lt;br/&gt; Druid 连接池配置 * @Author Dew * @Date 2019/12/4 **/@Configurationpublic class DruidDataSourceConfig &#123; @Primary//必需注解，缺少该注解将启动异常.可自定义某个数据源为主数据源 @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.druid.data-sources.primary") public DataSource primaryDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.druid.data-sources.secondary") public DataSource secondaryDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "secondaryJdbcTemplate") public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; DruidDataSourcesConfigTest 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.dew.config;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.dew.entity.UserPO;import com.dew.repository.UserRepository;import java.util.List;import java.util.Map;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;/** * @author ：Dew * @date ：Created in 2019/12/4 */@Slf4j@RunWith(SpringRunner.class)@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)public class DruidDataSourceConfigTest &#123; @Autowired private JdbcTemplate primaryJdbcTemplate; @Autowired private JdbcTemplate secondaryJdbcTemplate; @Test public void primaryDataSource() &#123; String sql = "select * from TBL_ACCOUNT where NAME='admin' and PASSWORD = '1'"; List&lt;Map&lt;String, Object&gt;&gt; result = primaryJdbcTemplate.queryForList(sql); log.info("primary datasource test:&#123;&#125;", JSONArray.toJSONString(result)); &#125; @Test public void secondaryDataSource() &#123; String sql = "SELECT * FROM TBL_ACCOUNT"; List&lt;Map&lt;String, Object&gt;&gt; result = primaryJdbcTemplate.queryForList(sql); log.info(JSONArray.toJSONString(result)); &#125;&#125; 小提示: 若对数据库连接池配置有不明白的,可以查看另一篇博客SpringBoot配置多数据源]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot加密敏感信息]]></title>
    <url>%2Fspringboot%2FSpringBoot%E5%8A%A0%E5%AF%86%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[在SpringBoot中,使用jasypt依赖实现配置文件加密。记录了Hikari与Druid连接池的使用方法,配置文件中使用ENC(xx)方式,extends HikariDataSource的两种方式实现 SpringBoot 配置加密的数据库连接信息使用Hikari数据库连接池 application.yml 配置文件(根据自身实际情况调整配置内容及配置文件格式properties) 123456789101112131415spring: datasource: primary: driver-class-name: com.cloudera.impala.jdbc41.Driver jdbc-url: xx secondary: driver-class-name: oracle.jdbc.OracleDriver jdbc-url: xx username: xx password: xx# 配置自己的根密码jasypt: encryptor: password: xx 两种方式都需要导入jasypt依赖,导入配置后需要在配置文件中添加jasypt.encryptor.password属性 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt;&lt;/dependency&gt; 使用jasypt包中的依赖,生成加密后的字符串 这里是在测试类中生成的 1234567891011121314151617181920212223242526272829303132333435 @Autowired private StringEncryptor encryptor; @Testpublic void generatorEncryptProperties() &#123; /* 生成加密的数据库配置信息 */ // dev String jdbcUrlDev = "jdbc:oracle:thin:@//127.0.0.1:1521/db"; jdbcUrlDev = encryptor.encrypt(jdbcUrlDev); String userNameDev = "test"; userNameDev = encryptor.encrypt(userNameDev); String passwordDev = "test"; passwordDev = encryptor.encrypt(passwordDev); log.info("jdbcUrlDev:&#123;&#125;", jdbcUrlDev); log.info("userNameDev:&#123;&#125;", userNameDev); log.info("passwordDev:&#123;&#125;", passwordDev); // prod String jdbcUrlPro = "jdbc:oracle:thin:@//ip:1521/db"; jdbcUrlPro = encryptor.encrypt(jdbcUrlPro); String userNamePro = "test"; userNamePro = encryptor.encrypt(userNamePro); String passwordPro = "test"; passwordPro = encryptor.encrypt(passwordPro); log.info("jdbcUrlPro:&#123;&#125;", jdbcUrlPro); log.info("userNamePro:&#123;&#125;", userNamePro); log.info("passwordPro:&#123;&#125;", passwordPro);&#125; 第一种(以上步骤是相同的,以下步骤开始区分) 修改配置文件 配置文件中使用密文替换原先配置ENC(xx) 12345678910spring: datasource: primary: driver-class-name: com.cloudera.impala.jdbc41.Driver jdbc-url: ENC(xx) secondary: driver-class-name: oracle.jdbc.OracleDriver jdbc-url: ENC(xx) username: ENC(xx) password: ENC(xx) 这是上述配置中DataSource配置 123456789101112131415161718192021222324252627282930313233343536373839404142import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import com.zaxxer.hikari.HikariDataSource;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;@Configurationpublic class HikariDataSourceConfig &#123; @Primary @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.secondary") public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "secondaryJdbcTemplate") public NamedParameterJdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new NamedParameterJdbcTemplate(dataSource); &#125;&#125; 创建测试类,测试程序是否能够获取数据库连接 123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.List;import java.util.Map;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import com.alibaba.fastjson.JSON;@Slf4j@SpringBootTest@RunWith(SpringRunner.class)public class HikariDataSourceConfigTest &#123; @Autowired private NamedParameterJdbcTemplate secondaryJdbcTemplate; @Test public void queryAdGeocodeTest() &#123; log.info("secondary data source connection start:"); String sql = "select 1 from dual"; List&lt;Map&lt;String, Object&gt;&gt; result = secondaryJdbcTemplate.queryForList(sql,new HashMap&lt;&gt;()); log.info("secondary data source:\t&#123;&#125;",JSON.toJSONString(result)); &#125; &#125; 控制台输出,以下是正常时的内容 12345secondary data source connection start:13:55:14.949 [main] INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...13:55:15.209 [main] INFO com.zaxxer.hikari.pool.PoolBase - HikariPool-1 - Driver does not support get/set network timeout for connections. (oracle.jdbc.driver.T4CConnection.getNetworkTimeout()I)13:55:15.219 [main] INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.secondary data source: [&#123;"1":1&#125;] 第二种 新建JasyptHikariDataSource 注释的属性可以根据实际情况进行调整,选择自己需要加密的属性重写相关方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import com.zaxxer.hikari.HikariDataSource;import lombok.extern.slf4j.Slf4j;import org.jasypt.encryption.StringEncryptor;import org.springframework.beans.factory.annotation.Autowired;/** * @ClassName JasyptHikariDataSource * @Description &lt;br/&gt; 加密数据库密码 * @Author Dew * @Date 2019/11/8 9:02 * @Version 1.0 **/@Slf4jpublic class JasyptHikariDataSource extends HikariDataSource &#123; @Autowired private StringEncryptor encryptor; // @Override // public String getJdbcUrl() &#123; // String encJdbcUrl = super.getJdbcUrl(); // if (encJdbcUrl.isEmpty()) &#123; // return null; // &#125; // String decJdbcUUrl = encryptor.decrypt(encJdbcUrl); // log.info("解密后的jdbcUrl:\t&#123;&#125;", decJdbcUUrl); // return decJdbcUUrl; // &#125; // @Override // public String getUsername() &#123; // String encUsername = super.getUsername(); // if (encUsername.isEmpty()) &#123; // return null; // &#125; // String decUsername = encryptor.decrypt(encUsername); // log.info("解密后的用户名:\t&#123;&#125;", decUsername); // return decUsername; // &#125; @Override public String getPassword() &#123; // 配置文件中加密后的密码 String encPassword = super.getPassword(); if (encPassword.isEmpty()) &#123; return null; &#125; String decPassword = encryptor.decrypt(encPassword); log.info("解密后的密码:\t&#123;&#125;", decPassword); return decPassword; &#125;&#125; 修改HikariDataSource中的数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import com.zaxxer.hikari.HikariDataSource;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;@Configurationpublic class HikariDataSourceConfig &#123; @Primary @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.secondary") public DataSource secondaryDataSource() &#123; /* 这是第一种方法中实例化的对象,也可以用其他的方式实现实例化 */ // return DataSourceBuilder.create().type(HikariDataSource.class).build(); /* 这是第二种方法中实例化的对象,也可以用其他的方式实现实例化 */ return DataSourceBuilder.create().type(JasyptHikariDataSource.class).build(); &#125; @Bean(name = "secondaryJdbcTemplate") public NamedParameterJdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new NamedParameterJdbcTemplate(dataSource); &#125;&#125; 创建测试类,测试程序是否能够获取数据库连接 123456789101112131415161718192021222324252627282930313233import java.util.HashMap;import java.util.List;import java.util.Map;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import com.alibaba.fastjson.JSON;@Slf4j@SpringBootTest@RunWith(SpringRunner.class)public class HikariDataSourceConfigTest &#123; @Autowired private NamedParameterJdbcTemplate secondaryJdbcTemplate; @Test public void queryAdGeocodeTest() &#123; log.info("secondary data source connection start:"); String sql = "select 1 from dual"; List&lt;Map&lt;String, Object&gt;&gt; result = secondaryJdbcTemplate.queryForList(sql,new HashMap&lt;&gt;()); log.info("secondary data source:\t&#123;&#125;",JSON.toJSONString(result)); &#125; &#125; 运行正常即可 使用Druid数据库连接池(项目连接的是Oracle数据库,其他数据库看实际情况修改导入的连接依赖即可) 修改pom.xml添加依赖 12345678910111213141516171819202122232425&lt;!-- 数据库连接池 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 本地连接oracle的文件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;$&#123;ojdbc.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jasypt 加密依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java操作Linux]]></title>
    <url>%2Fblog%2FJava%2FJava%E6%93%8D%E4%BD%9CLinux%2F</url>
    <content type="text"><![CDATA[Java操作Linux Java操作Linux使用java.lang.Runtime操作运行脚本1234567891011121314151617181920import lombok.extern.slf4j.Slf4j;/** * @Title callCloseCommand * @Description 执行关闭程序脚本 * @Param * @param * @return void **/private void callCloseCommand() &#123; String command = "./server.sh stop"; log.error("高德地理编码API失效,请更新IP地址", command); try &#123; Runtime.getRuntime().exec(command); &#125; catch (Exception e) &#123; log.error("Linux 命令执行错误,&#123;&#125;", command); e.printStackTrace(); &#125;&#125; 注: 也可以根据实际情况调整command内容,更改linux语句。例如:./server.sh restart]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库语法对比]]></title>
    <url>%2Fblog%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[统计了在开发过程中,不同数据库实现相同功能的不同语句。 概述 在开发过程中,需要写一些不同数据库间的相同功能SQL 。今天有时间就特地总结一下,方便自己以后查阅和比对。 分页功能 Oracle 12345678-- 查询 0,10select * from t_demo where rownum &lt;= 10;-- 查询 10,20select * from ( select *,rn from t_demo where rownum &lt;= 20)where rn &gt; 10; SQL Server 12345-- 查询 0,10select top 10 * from t_demo ;-- 查询 10,20select top 20 * from addressbook where id not in (select top 10 id from addressbook) MySQL Server 12345-- 查询 0,10select * from t_demo limit 10;-- 查询 10,20select * from t_demo limit 10,20; Impala 12345-- 查询 0,10select * from t_demo limit 10;-- 查询 10,20select * from t_demo limit 20 offset 10;]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式]]></title>
    <url>%2FBlog%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式代表有经验的面向对象软件开发人员使用的最佳实践。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是由许多软件开发人员在相当长的时间内通过试错获得的。设计模式的目的是为了让软件具有更好的代码重用性、可读性、可扩展性、可靠性,同时使程序实现高内聚、低耦合。 模式类型 在《设计模式-可重用的面向对象软件元素》一书中,阐明一共有23中设计模式。按三类可分为:创造型模式(Creational Patterns)、结构型模式(Structural Patterns)、行为型模式(Behavioral Patterns)。其中还有另一类设计模式: J2EE设计模式。 序号 分类名称 说明 包括 1 创造型模式 创造模式提供了一种创建对象而隐藏创建逻辑的方法,并不是直接使用new实例化对象。使程序在决定对于给定的用例需要创建哪些对象时具有更大的灵活性 工厂模式(Factory Pattern) 抽象工厂模式(Abstract Factory Pattern) 单例模式(Singleton Pattern) 建造者模式(Builder Pattern) 原型模式(Prototype Pattern) 2 结构型模式 结构型模式关注类和对象的组合。集成的概念被用来组合接口和定义组合对象获得新的功能 适配器模式(Adapter Pattern) 桥接模式(Bridge Pattern)过滤器模式(Filter、Criteria Pattern)组合模式(Composite Pattern)装饰器模式(Decorator Pattern)外观模式(Facade Pattern)享元模式(Flyweight Pattern)代理模式(Proxy Pattern) 3 行为型模式 行为型模式特别关注对象之间的通信 责任链模式(Chain of Responsibility Pattern)命令模式(Command Pattern)解释器模式(Interpreter Pattern)迭代器模式(Iterator Pattern)中介者模式(Mediator Pattern)备忘录模式(Memento Pattern)观察者模式(Observer Pattern)状态模式(State Pattern)空对象模式(Null Object Pattern)策略模式(Strategy Pattern)模板模式(Template Pattern)访问者模式(Visitor Pattern) 4 J2EE模式 J2EE模式特别关注表示层,是由Sun Java Center 鉴定的。 MVC模式(MVC Pattern)业务代表模式(Business Delegate Pattern)组合实体模式(Composite Entity Pattern)数据访问对象模式(Data Access Object Pattern)前端控制器模式(Front Controller Pattern)拦截过滤器模式(Intercepting Filter Pattern)服务定位器模式(Service Locator Pattern)传输对象模式(Transfer Object Pattern) 设计原则 提倡Design Pattern原因: 实现代码复用,增加可维护性。 单一职责原则(Single Responsibility Principle SRP) 注: 详细解释参照百科单一职责原则 说明: 单一职责原则又称单一功能原则,面向对象五个基本原则(SOLID)之一。 定义: 一个类,只有一个引起它变化的原因。 解释: 所谓职责就是指类变化的原因。如果一个类有多余一个的动机被改变,那么这个类就具有多余一个的职责。而单一职责原则就是指一个类应该有且仅有一个改变的原因。 解决的问题: 降低类的复杂度 提高类的可读性,提高系统的可维护性 降低变更引起的风险(降低对其他功能的影响) 开闭原则(Open Close Principle OCP) 说明: 在面向对象编程领域中，开闭原则规定软件中的对象(类、模块、函数等)应该对于扩展是开放的,但是对于修改时封闭的。 解释: 在程序需要进行扩展的时候,不能去修改原有的代码,实现一个热插拔的效果。简言之,是为了是程序的扩展性好,易于维护和升级。 实现: 里氏代换原则(Liskov Substitution Principle LSP) 定义: 任何基类可以出现的地方,子类一定可以出现。 解释:LSP是继承复用的基石,只有当衍生类可以替换掉基类,软件单位的功能不受到影响时,基类才能真正被复用,而衍生类也能够给在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 解决的问题: 增强程序的健壮性,版本升级时也可以保持非常好的兼容性 提高代码复用率 依赖倒转原则(Dependence Inversion Principle DIP) 接口隔离原则(Interface Segregation Principle ISP) 合成/聚合复用原则(Composite/Aggregate Reuse Principle CARP) 最小知识原则(Principle of Least Knowledge PLK,迪米特法则)]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记(《Linux就该这么学》)]]></title>
    <url>%2FBlog%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8ALinux%E5%B0%B1%E8%AF%A5%E8%BF%99%E4%B9%88%E5%AD%A6%E3%80%8B%2F</url>
    <content type="text"><![CDATA[Linux学习笔记(《Linux就该这么学》) Linux就该这么学 网站首页:《Linux就该这么学》 第二章 · 新手必须掌握的Linux命令常用系统工作命令 echo 命令 echo命令用于在终端输出字符串或变量提取后的值,格式为echo [字符串|变量] 例如: echo Hello World! 12[root@dew ~]# echo Hello World!Hello World! 使用$变量的方式提取变量SHELL的值,并输出 12[root@dew ~]# echo $SHELL/bin/bash date 命令 date 命令用于显示及设置系统的时间或日期,格式为date [选项][+指定的格式] 参数 作用 %t 跳格[Tab键] %H 小时(00~23) %I 小时(00~12) %M 分钟(00~59) %S 秒(00~59) %j 今年中的第几天 默认格式输出系统当前时间 12[root@dew ~]# dateTue Aug 20 15:47:14 CST 2019 指定格式输出系统当前时间 12[root@dew ~]# date "+%Y-%m-%d %H:%M:%S"2019-08-20 15:47:49 设置系统当前时间 12[root@dew ~]# date -s"20190820 15:49:00"Tue Aug 20 15:49:00 CST 2019 date命令中的参数%j可用来查看今天是当年中的第几天。这个桉树能够很好的区分备份时间的新旧,即数字越大,越靠近当前时间。 12[root@dew ~]# date "+%j"232 reboot 命令 reboot 命令用于重启系统,其格式为reboot。由于重启计算机会涉及硬件资源的管理权限,默认只能由root管理员重启。 12345678910111213141516171819202122232425262728[root@dew ~]# reboot``` 4. `poweroff` 命令- `poweroff` 命令用于关闭系统,其格式为`poweroff`。该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑。```sh[root@dew ~]# poweroff``` 5. `wget` 命令- `wget` 命令用于在终端下载网络文件,格式为`wget [参数] 下载地址`| 参数 | 作用 || ---- | ----------------------------------- || -b | 后台下载模式 || -P | 下载到指定目录 || -t | 最大尝试次数 || -c | 断点续传 || -p | 下载页面内所有资源,包括图片、视频等 || -r | 递归下载 |* 使用`wget`命令下载最新的`pdf`格式电子文档 ```sh[root@dew ~]# wget https://www.linuxprobe.com/docs/LinuxProbe.pdf ps 命令 ps 命令用于查看系统中的进程状态,格式为ps [参数]。通常搭配管道技术使用,用来抓取某个指定服务进程相对应的PID 参数 作用 -a 显示所有进程(包括其他用户的进程) -u 用户以及其他详细信息 -x 显示没有控制终端的进程 Linux系统中时刻运行着许多进程，如果能够合理地管理，可以优化系统的性能。五种常见的进程状态,运行、中断、不可中断、僵死、停止。 状态名称 含义 R(运行) 进程正在运行或在运行队列中等待 S(中断) 进程处于休眠中,当某个条件形成后或者接收到信号时，则脱离该状态 D(不可中断) 进程不响应系统异步信号，即便用kill命令也不能将其中断 Z(僵死) 进程已经终止，但进程描述符依然存在，直到父进程调用wait4()系统函数后将进程释放 T(停止) 进程收到停止信号后停止运行 ps -aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 进程的所有者 进程ID CPU占用率 内存占用率 虚拟内存使用率(/KB) 占用的固定内存量(/KB) 所在终端 进程状态 被启动的时间 实际使用CPU的时间 命令名称与参数 root 1 0.0 0.0 19348 1120 ? Ss 2018 93:29 /sbin/init root 2 0.0 0.0 0 0 ? S 2018 0:00 [kthreadd] root 3 0.0 0.0 0 0 ? S 2018 0:08 [migration/0] root 4 0.0 0.0 0 0 ? S 2018 92:20 [ksoftirqd/0] root 5 0.0 0.0 0 0 ? S 2018 0:00 [migration/0] root 6 0.0 0.0 0 0 ? S 2018 0:42 [watchdog/0] root 7 0.0 0.0 0 0 ? S 2018 0:35 [migration/1] root 8 0.0 0.0 0 0 ? S 2018 0:00 [migration/1] top 命令 top 命令用于动态的监视进程活动与系统负载等信息,其格式为top 123456789101112131415161718192021222324252627282930313233[root@dew ~]# toptop - 16:29:09 up 1117 days, 5:23, 3 users, load average: 0.00, 0.00, 0.00Tasks: 158 total, 1 running, 157 sleeping, 0 stopped, 0 zombieCpu(s): 0.7%us, 0.8%sy, 0.0%ni, 98.5%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 4052796k total, 3223016k used, 829780k free, 139760k buffersSwap: 4063228k total, 219528k used, 3843700k free, 1060376k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 5608 root 20 0 3517m 487m 12m S 2.3 12.3 472:35.14 java 2624 root 20 0 326m 5948 3600 S 0.3 0.1 3158:05 vmtoolsd 10147 root 20 0 1489m 65m 2280 S 0.3 1.7 9206:20 cmf-agent 1 root 20 0 19356 1240 1016 S 0.0 0.0 9:03.72 init 2 root 20 0 0 0 0 S 0.0 0.0 0:00.79 kthreadd 3 root RT 0 0 0 0 S 0.0 0.0 12:07.86 migration/0 ``` | 行数 | 含义 || ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ || 第 1 行 | 系统时间、运行时间、登录终端数、系统负载(loadverage: 数值越小意味着负载越低) || 第 2 行 | 进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数|| 第 3 行 | 用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。&lt;br/&gt;其中数据均为CPU数据并以百分比格式显示，例如:“98.5%id” 意味着有 98.5% 的CPU处理器资源处于空闲 || 第 4 行 |物理内存、内存使用量、内存空闲量、作为内核缓存的内存量||第 5 行|虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量|8. `pidof` 命令- `pidof` 命令用于查询某个指定服务进程的`PID`值，格式为`pidof [参数] [服务名称]`每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID```sh[root@dew ~]# pidof sshd29110 27979 2974 kill 命令 kill 命令用于终止某个指定PID 的服务进程,格式为kill [参数] [进程PID] 12345678910111213[root@dew ~]# kill 29110``` 10. `killall` 命令- `killall` 命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数][服务名称]”```sh[root@linuxprobe ~]# pidof httpd13581 13580 13579 13578 13577 13576[root@linuxprobe ~]# killall httpd[root@linuxprobe ~]# pidof httpd[root@linuxprobe ~]# 系统状态检测命令 ifconfig 命令]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven安装jar到本地仓库]]></title>
    <url>%2FBlog%2Fmaven%E5%AE%89%E8%A3%85jar%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在使用Maven开发过程中,难免会遇到jar包无法从中央仓库下载的窘境。本博客介绍一种方法,也许能解决遇到的问题。 使用Maven将pom.xml中下载失败的jar安装到本地仓库或私有仓库 以impalaJDBC41文件为例 下载相应的jar文件 原先只需要在maven中增加对ImpalaJDBC41的依赖配置即可 12345678910111213&lt;properties&gt; &lt;impala.version&gt;2.6.3&lt;/impala.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- 有可能下载不到该Jar, 可以到该地址下载相应版本：https://www.cloudera.com/downloads/connectors/impala/jdbc/2-6-3.html --&gt; &lt;!-- https://mvnrepository.com/artifact/com.cloudera/ImpalaJDBC41 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.cloudera&lt;/groupId&gt; &lt;artifactId&gt;ImpalaJDBC41&lt;/artifactId&gt; &lt;version&gt;$&#123;impala.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;dependencies&gt; 不知为何,配置的阿里云镜像库无法下载该jar 改为从下载相应的版本及jar文件 打开Dos窗口,使用如下命令 1mvn install:install-file -DgroupId=com.cloudera -DartifactId=ImpalaJDBC41 -Dversion=2.6.3 -Dpackaging=jar -Dfile=./ImpalaJDBC41-2.6.3.jar DgroupId: pom.xml配置中groupId的值 DartifactId: pom.xml配置中artifactId的值 Dversion: 版本号 Dpackaging: 文件类型 Dfile: 文件路径]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java打印log]]></title>
    <url>%2FBlog%2FJava%2FJava%E6%89%93%E5%8D%B0log%2F</url>
    <content type="text"><![CDATA[初学Java时的Log 九九乘法表 代码块 1234567891011121314/** * @Title: multiplicationTable * @Description: 九九乘法表 * @ReturnType: void */private void multiplicationTable() &#123; // 乘法表 for (int i = 1; i &lt; 10; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(j + " * " + i + " = " + (i * j) + "\t"); &#125; System.out.println(); &#125;&#125; 输出结果 1234567891 * 1 = 1 1 * 2 = 2 2 * 2 = 4 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 直角三角形 代码块 12345678910111213141516/** * @Title: rightAngle * @Description: 直角三角形 * @param side * @ReturnType: void */private void rightTriangle(int side) &#123; // 直角三角形10 for (int i = 0; i &lt;= side; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; System.out.print("*"); &#125; System.out.println(); &#125; &#125; 输出结果 12345678910******************************************************* 镂空直角三角形 代码块 123456789101112131415161718192021/** * @Title: hollowrightTriangle * @Description: 镂空直角三角形 * @param side * @ReturnType: void */private void hollowRightTriangle(int side) &#123; for (int i = 0; i &lt;= side; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (j == 1 || j == i &amp;&amp; i != side) &#123; System.out.print("*"); &#125; if (i == side) &#123; System.out.print("*"); &#125; else &#123; System.out.print(" "); &#125; &#125; System.out.println(); &#125;&#125; 输出结果 12345678910* * * * * * * * * * * * * * * * * *********** 平行四边形1234567891011121314151617/** * @Title: Parallelogram * @Description: 平行四边形 * @param side * @ReturnType: void */private void parallelogram(int side) &#123; for (int i = 0; i &lt; side; i++) &#123; for (int j = i + 1; j &lt; side; j++) &#123; System.out.print(" "); &#125; for (int j = side; j &gt; 0; j--) &#123; System.out.print("*"); &#125; System.out.println(); &#125;&#125; 输出结果 12345678910 ********** ********** ********** ********** ********** ********** ********** ********** ********************]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>print</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript解析XML字符串为JSON]]></title>
    <url>%2FBlog%2FHTML%2FJavaScript%E8%A7%A3%E6%9E%90XML%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BAJSON%2F</url>
    <content type="text"><![CDATA[JavaScript解析XML字符串为JSON JavaScript使用ObjTree.js解析xml文件为JSON对象 插件下载地址http://www.kawa.net/works/js/xml/objtree-e.html#download xml文件内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;Organization&gt; &lt;Department coding="001" name="根节点" modifytime="1436940546" MaxDepID="0" sn="" memo="" deptype="0" depsort="0" isPlatform="0" chargebooth="0"&gt; &lt;Device id="1000019001" type="65537" name="海康106" manufacturer="2" ip="127.0.0.2" prot="61001" unitnum="1" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000018001" type="65548" name="海康106" manufacturer="1" ip="127.0.0.2" prot="61001" unitnum="2" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000017001" type="65548" name="海康106" manufacturer="1" ip="127.0.0.2" prot="61001" unitnum="3" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000016001" type="65548" name="海康106" manufacturer="1" ip="127.0.0.2" prot="61001" unitnum="4" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000015001" type="65548" name="海康106" manufacturer="2" ip="127.0.0.2" prot="61001" unitnum="5" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;/Department&gt; &lt;Department coding="001" name="根节点" modifytime="1436940546" MaxDepID="0" sn="" memo="" deptype="0" depsort="0" isPlatform="0" chargebooth="0"&gt; &lt;Device id="1000019001" type="65537" name="海康106" manufacturer="2" ip="127.0.0.2" prot="61001" unitnum="1" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000018001" type="65548" name="海康106" manufacturer="1" ip="127.0.0.2" prot="61001" unitnum="2" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000017001" type="65548" name="海康106" manufacturer="1" ip="127.0.0.2" prot="61001" unitnum="3" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000016001" type="65548" name="海康106" manufacturer="1" ip="127.0.0.2" prot="61001" unitnum="4" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;Device id="1000015001" type="65548" name="海康106" manufacturer="2" ip="127.0.0.2" prot="61001" unitnum="5" status="2" rights="110000111001111"&gt; &lt;UnitNodes index="0" channelnum="48" streamType="81" type="1" subType="0" zeroChnEncode="0"&gt; &lt;Channel id="10000978001@001$1$0$0" name="GB49_1-" desc="" channelType="1" channelSN="10005"&gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$1" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;Channel id="10000978001@001$1$0$2" name="GB49_1-" desc="" channelType="1" channelSN="10005" &gt;&lt;/Channel&gt; &lt;/UnitNodes&gt; &lt;/Device&gt; &lt;/Department&gt;&lt;/Organization&gt; 压缩xml文件的线上地址http://www.bejson.com/otherformat/xml/ 解析方法 组装自定义的JSON格式数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function parseXMLData(root) &#123; console.info('----------------------------解析组织树数据----------------------------'); var rootTree = []; for (let i = 0; i &lt; root.length; i++) &#123; // console.info(root[i]); let id = root[i]['-coding']; // 组织树编号 let title = root[i]['-name']; // 组织树名称(对应为根节点名称) let device = root[i].Device; //设备树 let children = []; for (let i = 0; i &lt; device.length; i++) &#123; let device_id = device[i]['-id']; let device_ip = device[i]['-ip']; let device_manufacturer = device[i]['-manufacturer']; let device_name = device[i]['-name']; let device_port = device[i]['-port']; let device_type = device[i]['-type']; let device_channels = device[i].UnitNodes.Channel; let channels = []; for (let i = 0; i &lt; device_channels.length; i++) &#123; // console.info(device_channels[i]); let channel_id = device_channels[i]['-id']; let channel_name = device_channels[i]['-name']; let channel_sn = device_channels[i]['-channelSN']; let channel_type = device_channels[i]['-channelType']; channels.push(&#123; "id": channel_id, "title": channel_name, "channelSN": channel_sn, "channelType": channel_type, "isLeaf": true &#125;); &#125; children.push(&#123; "id": device_id, "title": device_name, "children": channels, "ip": device_ip, "port": device_port, "type": device_type, "manufacturer": device_manufacturer &#125;) &#125; rootTree.push(&#123; "id": id, "title": title, "children": children &#125;); &#125; //console.info(rootTree); return rootTree;&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>XML</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程常用函数记录]]></title>
    <url>%2FBlog%2F%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[统计在编程中搜索频率较高的Java常用函数,内容来源于编码日常记录. JavaMath 函数 数值向上取整 123456789101112131415/** * * @Title: formatRMB * @Description: `分`|转为`元`;并且向上取整 * @param amount * @return * String */private String formatRMB(int amount) &#123; double num = Math.ceil(amount / 100); if (num % 1.0 == 0) &#123; return String.valueOf((int) num); &#125; return String.valueOf(num); &#125; 判断（excel）文件类型1234567891011121314151617181920212223242526272829303132 /** * @Title: isExcel2003 * @Description: 是否为2013的excel,返回true是`.xls`文件 * @param filePath * @return * @Return boolean */private boolean isExcel2003(String filePath) &#123; return filePath.matches("^.+\\.(?i)(xls)$");&#125; /** * @Title: isExcelcsv * @Description: 是否为csv,返回true:`.csv`文件 * @param filePath * @return * @Return boolean */private boolean isExcelcsv(String filePath) &#123; return filePath.matches("^.+\\.(?i)(csv)$");&#125; /** * @Title: isExcel2007 * @Description: 是否是2007的excel，返回true是2007 * @param filePath * @return * @Return boolean */private boolean isExcel2007(String filePath) &#123; return filePath.matches("^.+\\.(?i)(xlsx)$");&#125; JavaScript限制文本框上传的文件类型1$('#element input').attr('accept', ['.xls', '.xlsx', '.csv']);]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树_二叉树]]></title>
    <url>%2FBlog%2F%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树、二叉树、二叉搜索树 引用 泥瓦匠BYSocket 树 &amp; 二叉树 树 树是由节点和边构成,存储元素的机会。节点是根节点、父节点、子节点的统称。 如图:根深:4; 5是根节点; 8与3是父子节点关系。 二叉树 二叉树(Binary tree),增加了二叉(binary),意思是在树中做区分。每个节点至多有两个子(child),left child &amp; right child。二叉树在很多例子中使用,比如二叉树标识算术表达式。 如图:1/8 是左节点; 2/3 是右节点. 二叉搜索树 BST(Binary Search Tree) 二叉搜索树 二叉树上增加搜索限制,其要求: 每个节点比其左子树元素大,比其有子树元素小。 如图:每个节点比它左子树的任意节点大,而且比它有子树的任意节点小]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux部署jar文件]]></title>
    <url>%2FBlog%2FLinux%2FLinux%E9%83%A8%E7%BD%B2jar%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[将SpringBoot生成的jar文件,在Linux启动。 Tips windows下的换行符为CRLF,在Linux中无法运行。如果在windows中编写,需要将换行符改为LF 本博客中的server.sh与xx.jar在同级目录,所以将cd folder的命令注释。看官可依据自身实际情况调整,希望能解决你的问题。 脚本文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#description:启动重启server服务#端口号,根据端口号确定PIDPORT=7091#启动命令所在目录# HOME=/opt/xx#启动jar文件名,需要修改为自己jar包的名字APP_NAME=xx.jar#查询出监听了PORT端口TCP协议的程序pid=`netstat -anp|grep $&#123;PORT&#125;|awk '&#123;printf $7&#125;'|cut -d/ -f 1`#检查程序是否在运行is_exist()&#123; #如果不存在返回 1 ,存在返回 0 if [ -z "$&#123;pid&#125;" ]; then return 1 else return 0 fi&#125;start()&#123; is_exist if [ $? -eq "0" ]; then echo "$&#123;APP_NAME&#125; is already running. pid=$&#123;pid&#125;." else # 进去命令所在目录 # cd $&#123;home&#125; # 启动jar文件,设置激活文件为prod。 nohup java -jar $APP_NAME --spring.profiles.active=prod &amp; echo "start at port:$PORT" fi&#125;stop()&#123; is_exist if [ $? -eq "0" ]; then kill -9 $pid echo $&#123;APP_NAME&#125;" is runnig on $&#123;PORT&#125; : $&#123;pid&#125;, execute kill - 9 $&#123;pid&#125;" else echo "$&#123;APP_NAME&#125; is not running." fi&#125;status()&#123; is_exist if [ $? -eq "0" ]; then echo "$&#123;APP_NAME&#125; is runnig on port:$PORT, pid is $&#123;pid&#125;" else echo "$&#123;APP_NAME&#125; is not runnig." fi&#125;restart()&#123; stop start&#125;case "$1" in "start") start ;; "stop") stop ;; "restart") restart ;; "status") status ;; *) usage ;;esacexit 0 ./server.sh无法执行 1chmod 777 xx.sh 可执行命令行 ./server.sh start 启动命令,控制台输出是否启动成功 ./server.sh stop 关闭命令,控制台输出是否关闭成功 ./server.sh restart 应用先关闭,后启动。控制台输出是否成功执行该操作]]></content>
      <categories>
        <category>Blog</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis生成唯一主键]]></title>
    <url>%2Fblog%2FJava%2FRedis%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E4%B8%BB%E9%94%AE%2F</url>
    <content type="text"><![CDATA[使用Redis生成自定义前缀/日期格式自增的唯一主键,例如HTG201810120001、201810120001等自增数。同时每天的零点重新开始生成个位为1的主键 参考博客: https://www.cnblogs.com/jbml-154312/p/7490810.html 前提: 需要连接到Redis 工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package com.sanss.city.util;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.support.atomic.RedisAtomicLong;import org.springframework.stereotype.Service;/** * * @ClassName: RedisGeneratorCode * @Description: 生成日期开头加0001，0002，0003的工具类 * @author Dew * @date 2018/10/09 * &#123;@link https://www.cnblogs.com/jbml-154312/p/7490810.html&#125; */@Servicepublic class RedisGeneratorCode &#123; private static final Logger logger = LoggerFactory.getLogger(RedisGeneratorCode.class); private RedisTemplate&lt;String, Object&gt; redisTemplate; @Autowired public RedisGeneratorCode(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * * @Title: generateCode * @Description: 生成自定义前缀的类似 HTG201810120001格式的自增数 * @param key redis中的key值 * @param prefix 最后编码的前缀 * @param hasExpire redis 是否使用过期时间设置自增id * @param minLength redis 生成的自增id的最小长度，如果小于这个长度前面补0 * @return * String */ public String generateCode(String key, String prefix, boolean hasExpire, Integer minLength) &#123; return this.createGenerateCode(key, prefix, hasExpire, minLength); &#125; /** * * @Title: generateCode * @Description: 生成 类似 201810120001格式的自增数 * @param key redis 中的key值 * @param hasExpire redis 是否使用过期时间设置自增id * @param minLength redis 生成的自增id的最小长度，如果小于这个长度前面补0 * @return * String */ public String generateCode(String key, boolean hasExpire, Integer minLength) &#123; return this.createGenerateCode(key, "", hasExpire, minLength); &#125; /** * * @Title: generateCode * @Description: 组装符合自己规则的id并设置过期时间 * @param key redis中的key值 * @param prefix 最后编码的前缀 * @param hasExpire redis 是否使用过期时间设置自增id * @param minLength redis生成的自增id的最小长度，如果小于这个长度前面补0 * @return * String */ public String createGenerateCode(String key, String prefix, boolean hasExpire, Integer minLength) &#123; try &#123; Date date = null; Long id = null; Calendar calendar = Calendar.getInstance(); if (hasExpire) &#123; calendar.set(Calendar.HOUR_OF_DAY, 23); calendar.set(Calendar.MINUTE, 59); calendar.set(Calendar.SECOND, 59); calendar.set(Calendar.MILLISECOND, 9999); date = calendar.getTime(); &#125; else &#123; calendar.set(Calendar.MINUTE, calendar.get(Calendar.MINUTE) + 10); date = calendar.getTime(); &#125; id = this.generateId(key, date); if (id != null) &#123; return this.format(id, prefix, minLength); &#125; &#125; catch (Exception e) &#123; logger.info("error --&gt; redis 生成自增id出现异常"); logger.error(e.getMessage(), e); &#125; return null; &#125; /** * * @Title: generateId * @Description: 使用RedisAtomicLong自增 * @param key redis中的key值 * @param date 过期时间 * @return * Long */ private Long generateId(String key, Date date) &#123; RedisAtomicLong counter = new RedisAtomicLong(key, redisTemplate.getConnectionFactory()); // 通过key获取自增并设定过期时间 counter.expireAt(date); return counter.incrementAndGet(); &#125; /** * * @Title: format * @Description: 获取 redis 自增后，生成自定义格式的id * @param id redis 获取的 id值 * @param prefix 自定义前缀 * @param minLength 生成数的长度，不满足时 0 补齐 * @return * String */ private String format(Long id, String prefix, Integer minLength) &#123; // 拼接的字符串 StringBuffer sb = new StringBuffer(); // 当前日期 Date date = new Date(); // 自定义前缀 sb.append(prefix); if (date != null) &#123; DateFormat df = new SimpleDateFormat("yyyyMMdd"); sb.append(df.format(date)); &#125; /* 对不满足长度的id值,使用0补齐 */ // redis 生成的id值 String strId = String.valueOf(id); // redis 生成id 的长度 int length = strId.length(); if (length &lt; minLength) &#123; for (int i = 0; i &lt; minLength - length; i++) &#123; sb.append("0"); &#125; sb.append(strId); &#125; else &#123; sb.append(strId); &#125; return sb.toString(); &#125;&#125; 方法中调用123456789101112131415161718/** * * @Title: getGeneratorId * @Description: 获取 yyyyMMdd0001格式,的自增工单id，并每天00:23:59 初始化化为0001 * @return * Long */private Long getGeneratorId() &#123; boolean flag = true; String code = null; int count = 0; while (flag) &#123; System.err.println(++count); code = redisGeneratorCode.generateCode("worksheet_id", "", true, 4); flag = code == null ? true : false; &#125; return Long.parseLong(code);&#125; SpringBoot 配置 依赖项(也可以使用jedis) 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- Redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;&lt;/dependency&gt;``` &gt; 配置`RedisConnection `和`RedisConnectionFactory````javapackage com.dew.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisStandaloneConfiguration;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;/** * @ClassName RedisConfig * @Description &lt;br/&gt; * TODO * @Date 2020/7/17 13:20 * @Version 1.0 **/@Configurationpublic class RedisConfig &#123; @Bean public LettuceConnectionFactory redisConnectionFactory() &#123; // hostName: 可以配置为ip地址(redis是修改host文件后的名称,127.0.0.1 redis) return new LettuceConnectionFactory(new RedisStandaloneConfiguration("redis", 6379)); &#125;&#125; 注:SpringBoot增加以上配置后就能正常访问了]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux安装基本工具]]></title>
    <url>%2FBlog%2FLinux%2FLinux%E5%AE%89%E8%A3%85%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Linux安装基本工具 Linux初始化安装必要程序CentOS 安装yum 下载最新的 yum-3.4.3解压并下载 12345# 下载wget http://yum.baseurl.org/download/3.4/yum-3.4.3.tar.gz# 解压命令tar xvf yum-3.4.3.tar.gz 进入目录,运行安装 123cd yum/yum-3.4.3yummain.py install yum 如果结果提示错误:CRITICAL: yum.cli:Config Error accessing file for config file:///etc/,可能是缺少配置文件。在etc目录下新建yum.conf文件,然后再次运行yummain.py install yum,顺利完成安装。 更新系统 12345yum check-updateyum updateyum clean all 安装lrzsz使用rz、sz命令 安装lrzsz 1yum -y install lrzsz 上传 1rz 上传文件较大或出现错误时,使用rz -be命令 上传并替换rz -y 下载 1sz 上传文件较大或出现错误时,使用sz -be命令 Tomcat 关闭时 Kill 进程可以参照另一篇记录Linux部署war包]]></content>
      <categories>
        <category>Blog</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud在线文档之SwaggerGateWay]]></title>
    <url>%2FSpringCloud%2FSpringCloud%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E4%B9%8BSwaggerGateWay%2F</url>
    <content type="text"><![CDATA[使用SpringCloud构建分布式在线文档 Swagger-service-a 依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.14.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Swagger start --&gt; &lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.7.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Swagger end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置文件 1234567891011server: port: 10010spring: application: name: swagger-service-aeureka: client: service-url: defaultZone: http://localhost:1001/eureka/swagger: base-package: com.learning 启动类 123456789@EnableSwagger2Doc@EnableDiscoveryClient@SpringBootApplicationpublic class SwaggerServiceAApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SwaggerServiceAApplication.class, args); &#125;&#125; Controller 12345678910111213@RestControllerpublic class ApiController &#123; @Autowired DiscoveryClient discoveryClient; @GetMapping("service-a") public String dc() &#123; String services = "Services:" + discoveryClient.getServices(); System.out.println(services); return services; &#125;&#125; 代码地址: https://github.com/ColorCoinK/springcloud-learning/tree/master/swagger-service-a Swagger-service-b 在简化的情况下,代码与Swagger-service-a一致,通过@GetMappning的标识区分两个不同服务 代码地址: https://github.com/ColorCoinK/springcloud-learning/tree/master/swagger-service-b 网关整合 SpringCloud(Dalston.SR5 版本) 集成 Swagger API 文档配置类 需要启动 Eureka-Server 服务注册中心 采用Spring4all社区版的自定义Swagger包,其他版本依赖可能与当前使用方法不一致,请查找其他资料 项目创建 创建SpringBoot项目,本示例选择spring-boot-starter-parent 1.5.12.RELEASE、spring-cloud-dependencies Dalston.SR5; 使用Eureka做服务注册中心 使用zuul 路由配置 导入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.7.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 启动类增加注解123456789@EnableSwagger2Doc@EnableZuulProxy@SpringCloudApplicationpublic class ApiGatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ApiGatewayApplication.class, args); &#125;&#125; 创建配置文件类,配置API文档12345678910111213141516171819202122232425262728/** * API 网关整合 Swagger API 文档配置类 * * @ClassName: DocumentationConfig * @Description: TODO * @Created by Dew on 2018/07/18 */@Component@Primarypublic class DocumentationConfig implements SwaggerResourcesProvider &#123; @SuppressWarnings(&#123;"unchecked", "rawtypes"&#125;) @Override public List&lt;SwaggerResource&gt; get() &#123; List resources = new ArrayList&lt;&gt;(); resources.add(swaggerResource("service-a", "/swagger-service-a/v2/api-docs", "2.0")); resources.add(swaggerResource("service-b", "/swagger-service-b/v2/api-docs", "2.0")); return resources; &#125; private SwaggerResource swaggerResource(String name, String location, String version) &#123; SwaggerResource swaggerResource = new SwaggerResource(); swaggerResource.setName(name); swaggerResource.setLocation(location); swaggerResource.setSwaggerVersion(version); return swaggerResource; &#125;&#125; 配置文件,设置注册中心,项目端口等1234567891011spring: application: name: api-gatewayserver: port: 1101eureka: client: service-url: defaultZone: http://localhost:1001/eureka/ 参考文章 程序猿DD —— Spring Cloud Zuul中使用Swagger汇总API接口文档]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
        <tag>Swagger</tag>
        <tag>GateWay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud鉴权之Token]]></title>
    <url>%2FSpringCloud%2FSpringCloud%E9%89%B4%E6%9D%83%E4%B9%8BToken%2F</url>
    <content type="text"><![CDATA[SpringCloud鉴权之Token 基于 Eureka 搭建鉴权服务(jjwt Token认证) 前提 需要启动服务注册中心,eureka-server,项目地址: 说明 只是码了这部分代码,原理及详细的解释可阅读尾部的链接地址 项目结构123456789101112131415161718192021222324252627282930313233src-main | | java | --- entity | -- dto | -- UserDto Token 刷新时间实体类 | -- UserPO 用户数据库映射实体类 | | enumerate | -- ParseToken Token 包含的内容解析 | repository | -- UserRepository 用户数据库相关操作 | utils | -- JwtUtil 生成、解析、刷新 Token 工具类 | EurekaTokenServerApplication | resources | -- application.yml 主配置文件 -- data.sql 初始化数据SQL -- schema.sql 建表语句SQL 功能概述 Eureka 服务注册中心 签发Token 结构分析 Eureka 服务注册中心 Eureka 客户端 jjwt 签发token H2 内存数据库 JPA 操作数据库 配置相关 依赖配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.19.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.learning&lt;/groupId&gt; &lt;artifactId&gt;eureka-token-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;eureka-token-server&lt;/name&gt; &lt;description&gt;Eureka Token server&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.SR5&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- token starts --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- token end --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.56&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 启动类 向Eureka服务中心注册,需要使用@EnableDiscoveryClient标记为客户端 123456789@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaTokenServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaTokenServerApplication.class, args); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526272829303132333435363738server: port: 1011spring: application: name: token-server datasource: url: jdbc:h2:mem:~/example-app platform: h2 username: sa password: driver-class-name: org.h2.Driver h2: console: enabled: false # 是否启用H2数据库控制台 settings: web-allow-others: false # 允许远程浏览器访问H2 数据库控制台 trace: false jpa: show-sql: true hibernate: ddl-auto: none generate-ddl: false database-platform: org.hibernate.dialect.H2Dialectlogging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACEeureka: instance: instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125; client: service-url: defaultZone: http://localhost:1001/eureka/ 初始化数据 data.sql 12345678910insert into tbl_account (id,name,age,sex,password,role) values (1001,'admin',18,'男','1','ROLE_ADMIN');insert into tbl_account (id,name,age,sex,password,role) values (1002,'zy',25,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1003,'lb',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1004,'lk',22,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1005,'zj',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1006,'lc',21,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1007,'wdd',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1008,'ln',18,'男','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1009,'gy',20,'女','1','ROLE_USER');insert into tbl_account (id,name,age,sex,password,role) values (1010,'dew',35,'男','1','ROLE_USER'); schema.sql 12345678910drop table if exists tbl_account;create table tbl_account( id number(12) primary key not null , name varchar not null, age int(2) not null , sex char(2) not null , password varchar(80) not null , role varchar(10) not null); 代码块 数据映射实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.learning.entity;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;import lombok.Data;import lombok.ToString;/** * @Title 用户 —— 数据库映射实体类 * @ClassName Account * @Description tbl_account * @Author sanss * @Date 2019/2/22 13:57 * @Version 1.0 */@Entity@Data@ToString@Table(name = "tbl_account")public class UserPO &#123; @Id @GeneratedValue private Long id; /** * 姓名 **/ private String name; /** * 年龄 **/ private Integer age; /** * 性别 **/ private String sex; /** * 登录密码 **/ private String password; /** * 角色名称 **/ private String role;&#125; 数据传输实体类 12345678910111213141516171819202122232425262728/** * @Title token 刷新时间数据传输实体类 * @ClassName UserDo * @Description TODO * @Author sanss * @Date 2019/2/22 16:24 * @Version 1.0 */@Datapublic class UserDto extends UserPO &#123; /** * 有效时长(unix 时间戳) **/ private Long expritaion; private String token; public UserDto() &#123; this.expritaion = (long) 1000 * 60 * 10; &#125; public UserDto(String token, Long id, String name) &#123; this.token = token; this.setId(id); this.setName(name); &#125;&#125; 枚举 12345678910111213141516171819202122/** * 解析token,返回什么值 * * @author sanss * @create 2019/2/22 * @since 1.0.0 */public enum ParseToken &#123; /** * 用户编号 **/ UID, /** * 登录名 **/ USER_NAME, /** * 实体类 **/ USER_DTO;&#125; Repository 12345678910111213141516171819202122/** * @Title 用户数据库操作类 * @ClassName UserRepository * @Description TODO * @Author sanss * @Date 2019/2/22 15:11 * @Version 1.0 */@Repositorypublic interface UserRepository extends JpaRepository&lt;UserPO, Long&gt; &#123; /** * @Title findByNameAndPassword * @Description 登录验证 * @Param * @param name 登录名 * @param password 密码 * @return com.learning.entity.Account **/ UserPO findByNameAndPassword(String name, String password);&#125; Token工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import com.learning.entity.dto.UserDto;import com.learning.enumerate.ParseToken;import io.jsonwebtoken.Claims;import io.jsonwebtoken.JwtBuilder;import io.jsonwebtoken.JwtException;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import java.util.Date;import java.util.HashMap;import java.util.Map;/** *@ClassName JwtUtil *@Description &lt;br/&gt; * JSON Web Token 生成、解析、刷新工具类 *@Author Dew *@Date *@Version 1.0 **/public class JwtUtil &#123; /** * token 加密算法 HS256 **/ private final static SignatureAlgorithm ENCRYPT_KEY = SignatureAlgorithm.HS256; /** * 该JWT 所面向的用户 **/ private final static String SUBJECT = "dew"; /** * 私钥 **/ private final static String SECRET_KEY = "secretkey"; /** * @param uid 用户id * @param name 用户名 * @param duration 有效时长(unix时间戳) * @return java.lang.String * @Title createJws * @Description * @Param **/ public static String createJws(Long uid, String name, String password, long duration) &#123; long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); // 自定义token携带的参数值 Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put("uid", uid); claims.put("user_name", name);// claims.put("password", password); JwtBuilder builder = Jwts.builder() // 该JWT 所面向的用户 .setSubject(SUBJECT) // token 携带的参数 .setClaims(claims) // token创建时间,unix时间戳格式 .setIssuedAt(now) .signWith(ENCRYPT_KEY, SECRET_KEY); if (duration &gt;= 0) &#123; // 设置最大有效时间,unix时间戳 long expirationMills = nowMillis + duration; Date expirationTime = new Date(expirationMills); //expire 指定 token 的声明周期,unix 时间戳格式 builder.setExpiration(expirationTime); &#125; return builder.compact(); &#125; /** * @return java.lang.Object * @Title analysisToken * @Description 解析 Token 内容信息 * @Param **/ public static Object analysisToken(String token, ParseToken type) &#123; try &#123; // 解析 token 中携带的信息 Claims claims = parseJWs(token); long now = System.currentTimeMillis(); // token 失效时间(设置的过期时间为 java.util.Date) Date expDate = claims.get("exp", Date.class); long exp = expDate.getTime(); // 用户编号 Long uid = claims.get("uid", Long.class); // 登录名 String userName = claims.get("user_name", String.class); // 1.token 过期 if (exp &lt; now) &#123; throw new JwtException("Token 过期"); &#125; // 2.在有效期内,刷新 token switch (type) &#123; case UID: return uid; case USER_DTO: UserDto userDto = new UserDto(token, uid, userName); exp = now + new UserDto().getExpritaion(); userDto.setExpritaion(exp); return userDto; case USER_NAME: return userName; default: break; &#125; &#125; catch (JwtException e) &#123; throw new JwtException(e.getMessage()); &#125; catch (Exception exception) &#123; throw new RuntimeException("token解析错误"); &#125; return false; &#125; /** * @return io.jsonwebtoken.Claims * @Title parseJWs * @Description 解析 token 字符串 * @Param **/ static Claims parseJWs(String token) throws JwtException &#123; // 解析 token 中携带的信息 Claims claims = Jwts.parser() .setSigningKey(SECRET_KEY) .parseClaimsJws(token) .getBody(); return claims; &#125;&#125; 测试类123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTestpublic class JwtUtilTest &#123; @Test public void jwsTest() &#123; //1001,'admin',18,'男','1','ROLE_ADMIN' System.out.println(JwtUtil.createJws(1001L, "admin", "admin", 1000 * 60 * 10)); &#125; @Test public void analysisJwsTest() &#123; Claims claims = new JwtUtil().parseJWs( "eyJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjEwMDEsInBhc3N3b3JkIjoiYWRtaW4iLCJ1c2VyX25hbWUiOiJhZG1pbiIsImV4cCI6MTU1MDgyMDcwOSwiaWF0IjoxNTUwODIwMTA5fQ.sh0ppz6cDOlK0ewlC0-cCFkyOV_FsVfvCTR4JzrmRTI"); System.out.println(claims); &#125;&#125; 配套代码 代码地址 GitHub: https://github.com/ColorCoinK/springcloud-learning/tree/master/eureka-token-server 参考文章列表 唐亚峰 —— SpringCloud-服务认证(JWT) Java知音 - 单点登录原理与简单实现]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka配置客户端]]></title>
    <url>%2FSpringCloud%2FEureka%E9%85%8D%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Eureka配置客户端 SpringCloud Greenwich 版本集成 Config Client(注册到Eureka Serever)添加相关依赖 加依赖 123456789101112131415161718192021222324&lt;!-- 注册到 Eureka Server 时需要添加的依赖 start --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 注册到 Eureka Server 时需要添加的依赖 end --&gt;&lt;!-- ConfigClient start --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- ConfigClient end --&gt;``` **注:** 需要添加 `spring-boot-starter-web` 否则启动会失败## 添加配置文件- 配置 `application.yml````yamlserver: port: 3011 新建 bootstrap.yml 12345678910111213141516spring: application: name: microservice-foo # 对应 config server 所获取的配置文件的 &#123;application&#125; cloud: config: uri: http://localhost:3001/ # profile 对应 config server 所获取的配置文件中的 &#123;profile&#125; profile: dev # profile 对应 config 所获取的配置文件中的 &#123;profile&#125; label: master # 指定Git 仓库的分支,对应 config server 所获取的配置文件的 &#123;label&#125;# discovery:# enabled: true # 是否从配置中心读取文件# service-id: microservice-config-server # 服务名eureka: client: serviceUrl: defaultZone: http://localhost:1001/eureka/ yml spring.application.name: 对应的 config server 所获取的配置文件的 {application} spring.cloud.uri: 指定Config Server的地址,默认是http://localhost:8888 spring.cloud.config.profile:profile对应Config Server 所获取配置文件的{profile} spring.cloud.config.label:指定Git仓库的分支,对应Config Server所获取配置文件的{label} [KEY POINT]: 注意属性配置文件,以上属性为bootstrap.yml文件内容而不是application.yml文件.如果配置在application.yml中,改部分配置就不能获取配置的正确值.例如:applicaiton.yml默认spring.cloud.config.uri的默认值是http://localhost:8888,而并非是http://localhost:3011 SpringCloud 有一个 “引导上下文” 的概念,这是主应用程序上下文(Application Context) 的父上下文。引导上下文负责从配置服务器加载配置属性,一级解密外部配置文件中的属性。和主应用程序加载application.*(yml或properties)中的属性不同,引导上下文加载bootstrap.*中的属性。配置在bootstrap.*中的属性优先级更高,因此默认情况下他们不能被而本地配置覆盖 从API接口验证是否能够正确获取自定义配置123456789101112@RestControllerpublic class ConfigClientConfigController &#123; // 获取 Config Server 配置文件中的 spring.cloud.config.profile属性值 @Value("$&#123;spring.cloud.config.profile&#125;") private String profile; @GetMapping("/profile") public String getProfile()&#123; return this.profile; &#125;&#125; 注: 如果需要注册到Eureka,需要在启动类SpringcloudConfigClientApplication上添加@EnableEurekaClient注解(注册到Eureka Server) 测试访问地址: http://localhost:3011/profile 配套代码 GitHub: https://github.com/ColorCoinK/springcloud-learning/tree/master/springcloud-config-client 参考博客 程序猿DD —— 分布式配置中心 纯洁的微笑 —— 配置中心服务化和高可用]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka配置中心]]></title>
    <url>%2FSpringCloud%2FEureka%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Eureka配置中心 SpringCloud 搭建配置中心SpringCloud config添加依赖123456789101112131415161718&lt;!-- eureka client start--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- eureka client end--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- config server start --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- config server end --&gt; 注: JDK version: 1.8 SpringBoot version: 2.1.2.RELEASE SpringCloud version: Greenwich.RELEASE SpringCloud 版本兼容 https://spring.io/projects/spring-cloud 配置application.yml1234567891011121314151617server: port: 3001spring: application: name: microservice-config-server # Git configuration cloud: config: server: git: uri: https://github.com/forezp/SpringcloudConfig/ search-paths: respo default-label: master# uri: https://git.oschina.net/itmuch/spring-cloud-config-repo.git # Git 仓库地址# username: # Git 仓库账号# password: # Git 仓库密码 yml spring.cloud.config.server.git.uri: 配置GitHub仓库地址(Gitee地址也可以) spring.cloud.config.server.git.search-paths: 配置仓库路径 spring.cloud.config.label: 配置仓库的分支 spring.cloud.config.server.git.username: 访问GitHub仓库的用户名 spring.cloud.config.server.git.password: 访问GitHub仓库的用户密码 路径规则 Spring Cloud Config Server提供了RESTful API,可用来访问存在Git仓库中的配置文件. 12345/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties 其中的{appliation}、{profile}、{label} 都是占位符. 注 使用的不同配置仓库,可以更改为自己的GitHub仓库地址 公开仓库不需要账号、密码,私有仓库需要填写(本Demo为公开仓库)。 测试访问地址: http://127.0.0.1:3001/foo/dev 配套代码 GitHub: https://github.com/ColorCoinK/springcloud-learning/tree/master/springcloud-config-server TIPS 注册到Eureka Server时,需要添加在 application.yml 添加 eureka.client.service-url.defaultZone=http://localhost:1001/eureka/,同时需要在SpringcloudConfigServerApplication(启动类)添加@EnableEurekaClient注解 参考博客 Spring Cloud Config —— 周立(http://www.itmuch.com/spring-cloud/finchley-19/) Spring Cloud Config —— 方志朋(https://blog.csdn.net/forezp/article/details/81041028)]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka服务消费者Ribbon]]></title>
    <url>%2FSpringCloud%2FEureka%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85Ribbon%2F</url>
    <content type="text"><![CDATA[Eureka使用Ribbon消费RESTful API 基于Eureka搭建Ribbon服务消费者 添加pom 123456789101112131415161718192021&lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix&lt;/artifactId&gt; &lt;version&gt;1.4.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;..&lt;/relativePath&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;main.basedir&gt;$&#123;basedir&#125;/../..&lt;/main.basedir&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改启动类 12345678910111213141516171819@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaRibbonApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; // Ribbon + RestTemplate 的重试 SimpleClientHttpRequestFactory simpleClientHttpRequestFactory =new SimpleClientHttpRequestFactory(); simpleClientHttpRequestFactory.setConnectTimeout(1000); simpleClientHttpRequestFactory.setReadTimeout(1000); return new RestTemplate(simpleClientHttpRequestFactory); &#125; public static void main(String[] args) &#123; SpringApplication.run(EurekaRibbonApplication.class, args); &#125;&#125; application.yml配置文件 123456789101112131415161718192021server: port: 3001spring: application: name: microservice-consumer-ribbon cloud: loadbalancer: retry: enabled: trueeureka: client: service-url: defaultZone: http://localhost:1001/eureka/ instance: instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;# prefer-ip-address: trueribbon: MaxAutoRetries: 1 # 同一实例最大重试次数,不包括首次调用 MaxAutoRetriesNextServer: 2 # 重试其他实例的最大重试次数,不包括首次所选的server OkToRetryOnAllOperations: false # 是否所有操作都进行重试 需要向注册到Eureka服务中心 相关代码块 Entity 123456789101112131415161718192021@Datapublic class Book &#123; private Long id; private String name; private Double price;&#125;@Datapublic class User &#123; private Long id; private String name; private Integer age;&#125; Service 123456789101112131415@Servicepublic class RibbonService &#123; @Autowired private RestTemplate restTemplate; public User queryUserInfoBy(Long id) &#123; return this.restTemplate.getForObject("http://microsevice-provider-user/users/"+id, User.class); &#125; public Book queryBookInfoById(Long id) &#123; return this.restTemplate.getForObject("http://microsevice-provider-user/"+id, Book.class); &#125;&#125; Controller 123456789101112131415161718@RestController@RequestMapping("ribbon")public class RibbonController &#123; @Autowired private RibbonService ribbonService; @GetMapping("/user/&#123;id&#125;") public User queryUserInfoById(@PathVariable Long id) &#123; return this.ribbonService.queryUserInfoBy(id); &#125; @GetMapping("/book/&#123;id&#125;") public Book queryBookInfoById(@PathVariable Long id) &#123; return this.ribbonService.queryBookInfoById(id); &#125;&#125; 注： 使用RestTemplate 调用 API 时,url为服务提供者的 spring.application.name 而不是 ip:port; 调用的 url 需要确保无误,否则会调用失败. 实现了Ribbon + RestTemplate 重试 参考 周立-SpringCloud 各组件重试总结 配套代码 GitHub: https://github.com/ColorCoinK/springcloud-learning/tree/master/eureka-ribbon 参考文章 唐亚峰 —— 服务消费者(Ribbon) 程序猿DD —— 服务消费者(Ribbon)[Dalston版]]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka服务消费者Feign]]></title>
    <url>%2FSpringCloud%2FEureka%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85Feign%2F</url>
    <content type="text"><![CDATA[Eureka使用Feign实现调用API 基于Eureka搭建Feign消费者 添加依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.19.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.SR5&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 启动类增加注解 1234567891011121314151617@EnableFeignClients@EnableCircuitBreaker@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaFeignApplication &#123; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(EurekaFeignApplication.class, args); &#125;&#125; @EnableCircuitBreaker: 服务降级 @EnableFeignClients: Feign客户端 @EnableDiscoveryClient: 注册到Eureka服务中心 上三个注解可以使用@SpringCloud注解代替 配置文件12345678910111213141516171819202122232425262728293031server: port: 4001spring: application: name: microservice-consumer-feigneureka: client: service-url: defaultZone: http://localhost:1001/eureka/ instance: instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;# prefer-ip-address: truefeign: hystrix: enabled: true # 全局启用 Hystrix,默认禁用management: endpoint: web: exposure: include: 'hystrix.stream' health: show-details: always ribbon: eager-load: enabled: true clients: microsevice-provider-user MaxAutoRetries: 1 # 同一实例最大重试次数,不包括首次调用 MaxAutoRetriesNextServer: 2 # 重试其他实例的最大重试次数,不包括首次所选的server OkToRetryOnAllOperations: false # 是否所有操作都进行重试 代码块实体类 Book 123456789101112@Data@NoArgsConstructor@AllArgsConstructorpublic class Book &#123; private Long id; private String name; private Double price;&#125; User 123456789101112@Data@NoArgsConstructor@AllArgsConstructorpublic class User &#123; private Long id; private String name; private Integer age;&#125; Client BookFeignClient 12345678910111213141516171819202122232425262728293031323334353637/** *@ClassName BookFeignClient *@Description &lt;br/&gt; * 获取造成fallback的原因, 同时实现服务降级 *@Author Dew *@Date 2019/2/15 9:50 *@Version 1.0 **/@FeignClient(name = "microsevice-provider-user",fallbackFactory = BookFeignClientFallbackFactory.class)public interface BookFeignClient &#123; @GetMapping("/&#123;id&#125;") Book queryBookInfoById(@PathVariable("id") Long id); /** * @Title * @Description 获得造成fallback的原因 * @return **/ @Component @Slf4j class BookFeignClientFallbackFactory implements FallbackFactory&lt;BookFeignClient&gt; &#123; @Override public BookFeignClient create(Throwable cause) &#123; return new BookFeignClient() &#123; @Override public Book queryBookInfoById(Long id) &#123; log.error("进入回退逻辑", cause); return new Book(id, "领域驱动设计", 89.99); &#125; &#125;; &#125; &#125;&#125; UserFeignClient 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @ClassName UserFeignClient * @Description &lt;br/&gt; * 服务提供者调用类 \n `@FeignClient`的 name、url 等属性支持占位符,例如(`@FeignClient(name * @Author Dew * @Date 2019/2/14 16:33 * @Version 1.0 **/@FeignClient(name = "microsevice-provider-user", fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping("/users/&#123;id&#125;") User queryUserInfoById(@PathVariable("id") Long id); /** * @return com.lerning.entity.User * @Title queryUserInfoByIdAndName * @Description GET 请求多参数的URL写法一 * &lt;link src="http://www.itmuch.com/spring-cloud-sum/feign-multiple-params/" /&gt; * @Param **/ @GetMapping("/users/findByIdAndName") User queryUserInfoByIdAndName(@RequestParam("id") Long id, @RequestParam("username") String userName); @GetMapping("/users/findByIdAndName") User queryUserInfoByIdAndName(@RequestParam Map&lt;String, Object&gt; param); // 服务降级 @Component class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserInfoById(Long id) &#123; return new User(id, "默认用户", 1); &#125; @Override public User queryUserInfoByIdAndName(Long id, String userName) &#123; return new User(id, "默认用户", 1); &#125; @Override public User queryUserInfoByIdAndName(Map&lt;String, Object&gt; param) &#123; return new User(1L, "默认用户", 1); &#125; &#125;&#125; Controller123456789101112131415161718192021222324252627282930313233343536373839404142/** *@ClassName *@Description &lt;br/&gt; * 测试Feign调用Controller *@Author Dew *@Date 2019/2/14 14:42 *@Version 1.0 **/@RestController@RequestMapping("/feign")public class UserController &#123; @Autowired private UserFeignClient userFeignClient; @Autowired private BookFeignClient bookFeignClient; @GetMapping("/user/&#123;id&#125;") public User findById(@PathVariable Long id) &#123; return this.userFeignClient.queryUserInfoById(id); &#125; @GetMapping("/user/findByIdAndName") public User queryUserInfoByIdAndName(@RequestParam("id") Long id, @RequestParam("username") String userName) &#123; // GET 请求多参数的 URL,参数传递方式一 // return this.userFeignClient.queryUserInfoByIdAndName(id, userName); // GET 请求多参数的 URL 参数传递方式二 Map&lt;String, Object&gt; param = new HashMap&lt;String, Object&gt;(); param.put("id", id); param.put("username", userName); return this.userFeignClient.queryUserInfoByIdAndName(param); &#125; @GetMapping("/book/&#123;id&#125;") public Book queryBookInfoById(@PathVariable Long id) &#123; return this.bookFeignClient.queryBookInfoById(id); &#125;&#125; 自定义Feign自定义配置[细粒度配置] 自定义日志级别 默认 Feign 是不打印任何日志的,开启 Feign 日志,Feign 日志有四种级别 NONE[性能最佳,适用于生产]: 不记录任何日志(默认值) BASIC[适用于生产环境追踪问题]: 仅记录请求方法、URL、响应状态码及响应时间 HEADERS: 记录 BASIC 级别的基础上,记录请求和响应的 header FULL[比较适用于开发及测试环境定位问题]: 记录请求和响应的 header、body 和元数据 配置参考博客 Feign配置自定义[细粒度配置] Feign 使用 Hystrix 配置 配置 Feign 相关 Hystrix 配置 配置参考博客 周立-Feign使用Hystrix Ribbon 的饥饿加载(eager-load)模式 Problems: 在使用SpringCloud的Ribbon或Feign来实现服务调用的时候,如果我们的机器或网络环境等原因不是很好,有时候后会出现 : 服务消费方调用服务提供方接口时,第一次请求经常会超时,而之后调用就没有问题了. 解决方式参考 翟永超-Ribbon的饥饿加载模式 Feign 的重试 参考 周立-SpringCloud 各组件重试总结 配套代码 GitHub: https://github.com/ColorCoinK/springcloud-learning/tree/master/eureka-feign 参考博客 周立 —— Feign 推荐阅读 程序员DD(翟永超) —— 服务消费者]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka服务提供者]]></title>
    <url>%2FSpringCloud%2FEureka%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%2F</url>
    <content type="text"><![CDATA[搭建Eureka服务提供者,将服务注册到服务中心 基于 Eureka 搭建服务提供者本项目是一个基于 SpringBoot 1.5.12.RELEASE、SpringCloud Dalston.SR5、H2、Eureka 的服务提供者. 添加pom依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.12.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.SR5&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 配置 SpringBoot 监控功能 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; @EnableDiscoveryClient启动类 123456789@EnableDiscoveryClient@SpringBootApplicationpublic class EurekaProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaProviderApplication.class, args); &#125;&#125; 初始化数据 使用H2内存数据库初始化测试数据 注: SpringBoot 2.x不能像 1.x 一样,使用 spring.datasource.schema/data 指定初始化脚本.否则与 actuator 不能共存 项目中的依赖并不是与[参考的博客一样,自行选择] 项目参考来源http://book.itmuch.com/2 Spring Cloud/2.2 服务提供者.html 建表语句(schema.sql) 123456789101112131415drop table if exists tbl_book;create table tbl_book(id number(12) primary key not null,name varchar not null,price decimal not null);create table t_user(id number(12) primary key not null,name varchar not null,age int not null);-- DELETE FROM tbl_book; 插入初始化数据(data.sql) 12345678910INSERT INTO tbl_book (id, name, price) VALUES (1, 'Spring Boot - Spring Data JPA with Hibernate and H2 Web Console', 0.0);INSERT INTO tbl_book (id, name, price) VALUES (2, 'Spring Boot - Spring Data JPA with Hibernate and H2 Web Console 2', 1.0);INSERT INTO tbl_book (id, name, price) VALUES (3, 'Spring Boot - Spring Data JPA with Hibernate and H2 Web Console 3', 2.0);INSERT INTO tbl_book (id, name, price) VALUES (4, 'Spring Boot - Spring Data JPA with Hibernate and H2 Web Console 4', 3.0);insert into t_user(id, name, age) values(1,'JSON',29);insert into t_user(id, name, age) values(2,'Alibaba',25);insert into t_user(id, name, age) values(3,'Apache',30);insert into t_user(id, name, age) values(4,'GitHub',20);insert into t_user(id, name, age) values(5,'Sun',18); 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041server: port: 2001spring: application: name: microsevice-provider-user datasource: # 指定数据源;默认H2建表脚本(根目录/schema.sql);默认H2的insert脚本(classpath:data.sql) url: jdbc:h2:mem:~/example-app; # 指定数据库,默认 platform: h2 username: sa password: driver-class-name: org.h2.Driver h2: console: enabled: false # 是否启用H2数据库控制台 settings: web-allow-others: false # 允许远程浏览器访问H2 数据库控制台 trace: false jpa: show-sql: true hibernate: ddl-auto: none generate-ddl: false database-platform: org.hibernate.dialect.H2Dialectlogging: level: root: INFO org.hibernate: INFO org.hibernate.type.descriptor.sql.BasicBinder: TRACE org.hibernate.type.descriptor.sql.BasicExtractor: TRACEeureka: client: serviceUrl: defaultZone: http://localhost:1001/eureka/ instance: instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125; # 自定义微服务的 `instance-id`,当前配置的默认值$&#123;spring.cloud.client.ipAddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;# prefer-ip-address: true# lease-expiration-duration-in-seconds: 30# lease-renewal-interval-in-seconds: 10 Entity12345678910111213141516@Entity@Data@Table(name = "tbl_book")public class Book &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column private String name; @Column private Double price;&#125; Repository1234@Repositorypublic interface BookRepository extends JpaRepository&lt;Book,Long&gt; &#123;&#125; Controller123456789101112@RestControllerpublic class BookController &#123; @Autowired private BookRepository bookRepository; @GetMapping("/&#123;id&#125;") public Book findById(@PathVariable Long id) &#123; return this.bookRepository.findOne(id); &#125;&#125; Eureka 常见问题配置参考链接Spring Cloud中，Eureka常见问题总结(周立) 实现监控(SpringBoot Actuator) 添加Actutor 监控(SpringBoot 1.x 版本) 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 参考示例: 周立 —— SpringBoot 集成Actutor 注： SpringBoot 1.x版本访问http://10.18.13.2:2001/health,SpringBoot 2.x访问http://10.18.13.2:2001/actutor/health 通过 spring.appliccation.name:server.port 访问 API 时,需要在 C:\Windows\System32\drivers\etc\hosts 文件夹中添加 1127.0.0.1 microsevice-provider-user]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka服务注册中心]]></title>
    <url>%2FSpringCloud%2FEureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[搭建Eureka(Edgware.SR5版本)服务注册中心 基于 Eureka 搭建高可用(双节点服务注册中心) 添加pom依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.19.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Edgware.SR5&lt;/spring-cloud.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 版本说明 本项目是一个基于 SpringBoot(1.5.19.RELEASE)、SpringCloud(Edgware.SR5)、Eureka 的服务注册中心 启动类 @EnableEurekaServer123456789@EnableEurekaServer@SpringBootApplicationpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class, args); &#125;&#125; 配置文件 application.yml 单个 Eureka 服务注册中心 12345678910111213141516server: port: 1001spring: application: name: eureka-servereureka: instance: hostname: localhost server: enable-self-preservation: false # 设为 false,关闭自我保护 eviction-interval-timer-in-ms: 4000 #清理间隔(单位毫秒,默认是 60*1000) client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ application-colony.yml 双节点注册中心 1234567891011121314151617181920212223242526272829server: port: 1001spring: profiles: server-1eureka: instance: hostname: server-1 client: register-with-eureka: false fetch-registry: false service-url:# defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/$&#123;spring.application.name&#125; defaultZone: http://server-2:1002/eureka-server--- server: port: 1002 spring: profiles: server-2 eureka: instance: hostname: server-2 client: register-with-eureka: false fetch-registry: false service-url: # defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/$&#123;spring.application.name&#125; defaultZone: http://server-1:1001/eureka-server 双节点注册中心示例,实现双向注册从而提高可用性详细可以看注册中心Eureka 默认使用 application.yml 配置文件; 使用application-conlony.yml 配置文件时,需要指定激活的配置项.(例如启动server-1,需运行java -jar xx.jar --spring.profiles.active=server-1) 配套代码GitHub : 服务注册中心Eureka-Server 推荐阅读 翟永超: Eureka服务注册与发现 周立: SpringCloud服务注册与发现Eureka 相关文章 周立——Eureka服务注册与发现深入]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百万数据秒级入库]]></title>
    <url>%2FBlog%2FJava%2F%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E7%A7%92%E7%BA%A7%E5%85%A5%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在项目中经常遇到大数据入库的需求,详细剖析该问题(指定数组大小拆分List,多线程入库,JDBC批量入库) 前言 本文章的来自于作者工作中的真实项目,如果看到文章的你有更好的建议,烦请在文章下留言或私信我。 将List拆分为指定大小的List12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;import java.util.List;/** * @ClassName ArrayUtil * @Description 数组操作工具类 * @Author Dew * @Date 2019/4/1 13:53 * @Version 1.0 **/public class ArrayUtil&lt;T&gt; &#123; /** * @Author Dew * @Description 将List拆分为 groupSize 大小的二维数组 * @Param [values 待分组Array 分组, groupSize 分组大小] * @Date 13:54 2019/4/1 * @Return java.util.List&lt;T&gt; **/ public List&lt;List&lt;T&gt;&gt; spilitGroup(List&lt;T&gt; values, int groupSize) &#123; List&lt;List&lt;T&gt;&gt; listGroup = new ArrayList&lt;&gt;(); // List 长度 int listSize = values.size(); int runSize = (listSize / groupSize) + 1; List&lt;T&gt; value = null; for (int i = 0; i &lt; runSize; i++) &#123; int start = i * groupSize; if (i + 1 == runSize) &#123; int end = listSize; value = values.subList(start, end); &#125; else &#123; int end = (i + 1) * groupSize; value = values.subList(start, end); &#125; listGroup.add(value); &#125; return listGroup; &#125;&#125; 创建数据入库线程123456789101112131415161718192021/** * @ClassName: BatchSaveThread * @Description: 多线程执行入库操作 * @date 2019/03/14 */class BatchSaveThread implements Runnable &#123; private List&lt;AdUserGridDo&gt; list; public BatchSaveThread(List&lt;AdUserGridDo&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; if (list.size() &gt; 0) &#123; advertisingUserDao.batchSaveJDBC(list); &#125; &#125;&#125; List执行批量入库123456789101112131415161718192021222324public void batchSave(List&lt;AdUserGridDo&gt; models, int groupSize) &#123; List&lt;List&lt;AdUserGridDo&gt;&gt; groupList = new ArrayUtil&lt;AdUserGridDo&gt;().spilitGroup(models, groupSize); // 创建线程数 = 数据总数 / groupList int threadPoolSize = groupList.size(); // 最多创建 4 个线程 threadPoolSize = threadPoolSize &gt;= 4 ? 4 : threadPoolSize; log.info("##不为空: &#123;&#125; 地址列表,入库创建的线程数: &#123;&#125;", threadPoolSize); ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize); try &#123; // 拆分网格数据 for (int i = 0, length = groupList.size(); i &lt; length; i++) &#123; logger.error("线程:" + i + "save API"); List&lt;AdUserGridDo&gt; list = groupList.get(i); BatchSaveThread saveThread = new BatchSaveThread(list); executor.execute(saveThread); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; finally &#123; executor.shutdown(); &#125;&#125; Spring 项目批量入库 Repository 内调用 1234public void batchSaveJDBC(List&lt;AdvertisingEntity&gt; list) &#123; BatchSave save = new BatchSave(); save.batchSaveAdvertising(list);&#125; 创建内部类,获取数据连接并执行入库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static Properties properties = new Properties();static &#123; ClassLoader cl = Thread.currentThread().getContextClassLoader(); InputStream in = new BufferedInputStream(cl.getResourceAsStream("jdbc.properties")); try &#123; properties.load(in); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/*** @ClassName: BatchSave* @Description: JDBC 批量入库,解决效率问题* @date 2019/03/14*/class BatchSave &#123; /** * 数据库连接驱动 */ private String JDBC_DRIVER = properties.getProperty("driverClass"); /** * 连接数据库url */ private String JDBC_URL = properties.getProperty("jdbcUrl"); /** * 连接数据库用户 */ private String JDBC_USER = properties.getProperty("user"); /** * 连接数据库密码 */ private String JDBC_PASSWORD = properties.getProperty("password"); private void batchSaveAdvertising(List&lt;AdvertisingEntity&gt; list) &#123; Connection connection = null; PreparedStatement statement = null; try &#123; Class.forName(JDBC_DRIVER); connection = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD); String sql = "insert into t_advertising values(?,?,?,?,?)"; statement = connection.prepareStatement(sql); connection.setAutoCommit(false); AdvertisingEntity value = null; for (int i = 0; i &lt; list.size(); i++) &#123; value = list.get(i); statement.setString(1, value.getName()); statement.setString(2, value.getLongitude()); statement.setString(3, value.getLatitude()); statement.setInt(4, value.getGridX()); statement.setInt(5, value.getGridY()); statement.addBatch(); if (i % 100 == 0) &#123; statement.executeBatch(); statement.clearParameters(); &#125; &#125; statement.executeBatch(); connection.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; finally &#123; try &#123; if (statement != null) &#123; statement.close(); &#125; if (connection != null) &#123; connection.close(); &#125; &#125; catch (SQLException e2) &#123; throw new RuntimeException(); &#125; &#125; &#125;&#125; SpringBoot 批量入库1234567891011121314151617181920212223242526@Repositorypublic class InfoRepository &#123; private final Logger logger = LoggerFactory.getLogger(InfoRepository.class); @Autowired private NamedParameterJdbcTemplate secondaryJdbcTemplate; /** * @Author Dew * @Description 用户网格数据批量入库 * @Param [list 入库的数据] * @Date 14:45 2019/4/1 * @Return void **/ public void batchSaveAdvertising(List&lt;AdUserGridDo&gt; list) &#123; long start = System.currentTimeMillis(); String sql = "insert into info values(:name,:longitude,:latitude)"; SqlParameterSource[] beanSource = SqlParameterSourceUtils.createBatch(list.toArray()); secondaryJdbcTemplate.batchUpdate(sql, beanSource); long end = System.currentTimeMillis(); logger.info("数据入库:\t" + (end - start) + "ms"); &#125;&#125; 注: Point 1. 使用:属性名传参 Point 2. 将百万数据拆分成了2w一组的数据,分批入库减小了数据库压力 Point 3. 入库创建的线程数需要根据服务器的性能进行调整,因为线程数量超过服务器负载能力时会造成不可描述的后果。]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot多数据源——impala连接]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%BF%E7%94%A8impala%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[SpringBoot 2.0 + Impala 多数据源 JDBCTemplateSpringBoot 2.0 + Impala 多数据源 Named SpringBoot 配置多数据源(Hikari连接池)连接Impala 注释: Impala: SpringBoot使用默认的Hikari连接池,连接Impala 增加依赖 123456789101112131415161718192021&lt;!--数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- Impala start --&gt;&lt;!-- 有可能下载不到该Jar, 可以到该地址下载相应版本：https://www.cloudera.com/downloads/connectors/impala/jdbc/2-6-3.html --&gt;&lt;!-- https://mvnrepository.com/artifact/com.cloudera/ImpalaJDBC41 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.cloudera&lt;/groupId&gt; &lt;artifactId&gt;ImpalaJDBC41&lt;/artifactId&gt; &lt;version&gt;$&#123;impala.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Impala end --&gt; 配置application.yml文件 该配置文件为多环境配置,可以参考 SpringBoot多环境配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859server: port: 7001spring: profiles: active: dev servlet: multipart: enabled: true mvc: view: prefix: / suffix: .html favicon: enabled: falselogback: name: template---# developer enviromentspring: profiles: dev datasource: impala: driver-class-name: com.cloudera.impala.jdbc41.Driver jdbc-url: jdbc:impala://xx:21050/default oracle: first: driver-class-name: oracle.jdbc.OracleDriver jdbc-url: jdbc:oracle:thin:@//xx:1521/pdb1.us.oracle.com username: xx password: xx---# developer enviromentspring: profiles: test datasource: impala: driver-class-name: com.cloudera.impala.jdbc41.Driver jdbc-url: jdbc:impala://xx:21050/default oracle: first: driver-class-name: oracle.jdbc.OracleDriver jdbc-url: jdbc:oracle:thin:@//xx:1521/pdb1.us.oracle.com username: xx password: xx---# developer enviromentspring: profiles: prod datasource: impala: driver-class-name: com.cloudera.impala.jdbc41.Driver jdbc-url: jdbc:impala://xx:21050/default oracle: first: driver-class-name: oracle.jdbc.OracleDriver jdbc-url: jdbc:oracle:thin:@//xx:1521/pdb1.us.oracle.com username: xx password: xx 多数据源连接配置类 项目目录结构 1234567891011121314151617181920212223src├───main│ ├───java│ │ └───com│ │ └───template│ │ ├───common # 公共部分│ │ ├───config # 配置、数据源│ │ ├───domain # DO、DTO、VO│ │ ├───repository # 数据库访问层│ │ ├───service # 逻辑层│ │ │ └───impl # 逻辑具体实现│ │ ├───util # 工具类│ │ └───web # api 接口│ └───resources│ ├───static # 静态资源文件│ │ └───js # 页面依赖的javascript 文件│ └───templates # 页面模板文件└───test └───java └───com └───template ├───config └───repository 多数据源配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.template.config;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import com.zaxxer.hikari.HikariDataSource;@Configurationpublic class HikariDataSourceConfig &#123; @Primary @Bean(name = "impalaDataSource") @Qualifier(value = "impalaDataSource") @ConfigurationProperties(prefix = "spring.datasource.impala") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "jdbcTemplateImpala") public JdbcTemplate jdbcTemplateImpala(@Qualifier("impalaDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "namedJdbcTemplateImpala") public NamedParameterJdbcTemplate namedJdbcTemplateImpala( @Qualifier("impalaDataSource") DataSource dataSource) &#123; return new NamedParameterJdbcTemplate(dataSource); &#125; @Bean(name = "secondOracleDataSource") @Qualifier(value = "secondOracleDataSource") @ConfigurationProperties(prefix = "spring.datasource.oracle.first") public DataSource firstOracleDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "jdbcTemplateOracle1") public JdbcTemplate jdbcTemplateOracle1( @Qualifier("secondOracleDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930package com.template.config;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import lombok.extern.slf4j.Slf4j;@Slf4j@SpringBootTest@RunWith(SpringRunner.class)public class HikariDataSourceConfigTest &#123; @Autowired private JdbcTemplate jdbcTemplateImpala; @Test public void testImpalaJdbcTemplate() &#123; log.info("impala jdbctemplate connection start:"); String sql = "select count(1) from t_info_iptvorder"; Integer count = jdbcTemplateImpala.queryForObject(sql, Integer.class); log.info("impalaJdbcTemplate query result :\t" + count); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德地理编码]]></title>
    <url>%2Fapi%2F%E9%AB%98%E5%BE%B7%E5%9C%B0%E7%90%86%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Java使用高德地理编码API API说明地理编码 API是通过 HTTP/HTTPS 协议访问远程服务的接口,提供结构化地址与经纬度之间的相互转化的能力。 地理编码: 将详细的结构化地址转换为高德经纬度坐标。 注: API地址高德 —— 地理编码,同时需要申请key,具体方法查看链接 步骤解析 申请key; 使用RestTemplate 调用RESt API; 返回结果信息,做对应的操作。 前提1234567891011&lt;!-- lombok 插件,使用注解的方式简化实体类get/set 方法生成 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Gson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 部分编码 创建外部配置文件,设置申请的 高德key等配置 配置文件 创建配置文件geocode.properties 123# 高德——地理编码geo.url= http://restapi.amap.com/v3/geocode/geogeo.key= xxx #自己申请的key 修改启动类,增加该配置类注解 1@EnableConfigurationProperties(GeocodingProperties.class) 使用实体类,获取配置文件内容 SpringMVC项目获取配置文件的方式 12345678910111213141516171819202122232425262728293031323334public class GeocodeUtil&#123; static Properties properties = new Properties(); static &#123; ClassLoader cl = Thread.currentThread().getContextClassLoader(); InputStream in = new BufferedInputStream(cl.getResourceAsStream("gaode.properties")); try &#123; properties.load(in); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * API 请求URL */ private final static String GD_URL = properties.getProperty("gaodeUrl"); /** * 高德地图 key */ private final static String GD_KEY = properties.getProperty("gaodeKey");&#125; SpringBoot使用实体类获取自定义配置代码块 配置属性实体类 123456789101112131415161718192021package com.sanss.config;import lombok.Data;import lombok.ToString;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.context.annotation.PropertySource;@Configuration@PropertySource("classpath:geocode.properties")@ConfigurationProperties(prefix = "geo")@Data@ToStringpublic class GeocodingProperties &#123; private String url; private String key;&#125; 工具类代码块 说明 该类中的多个内部实体类,可以独立生成文件; 返回结果获取的实体类属性,可以自己增加或更改成与需求一致; 只是最简单的方式完成请求API,其他操作需根据自身需求进行更改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.sanss.util.geocode;import com.sanss.config.GeocodingProperties;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import javax.annotation.PostConstruct;import lombok.Data;import lombok.ToString;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.client.RestTemplate;/** * @ClassName: GeoDto * @Description: 调用高德地理编码API传递的参数实体类 * @date 2019/03/27 */class GeoDto &#123; private Boolean batch; private String city; private String address; private String url; private String key; public GeoDto() &#123; &#125; public GeoDto(List&lt;String&gt; address, String city, Boolean batch, String url, String key) &#123; StringBuilder addressSb = new StringBuilder(); for (int i = 0, length = address.size(); i &lt; length; i++) &#123; addressSb.append(address.get(i)); addressSb.append("|"); &#125; this.address = addressSb.substring(0, addressSb.lastIndexOf("|")).toString(); this.city = city; this.batch = batch; this.url = url; this.key = key; &#125; @Override public String toString() &#123; return url + "?batch=" + batch + "&amp;key=" + key + "&amp;city=" + city + "&amp;address=" + address; &#125;&#125;/** * @ClassName: Geocodes * @Description: 返回结果实体类, 只获取了location:经纬度 API 地址：https://lbs.amap.com/api/webservice/guide/api/georegeo * 返回结果示例: &#123;"status":"1","info":"OK","infocode":"10000","count":"1","geocodes":[&#123;"formatted_address":"上海市浦东新区东方明珠","country":"中国","province":"上海市","citycode":"021","city":"上海市","district":"浦东新区","township":[],"neighborhood":&#123;"name":[],"type":[]&#125;,"building":&#123;"name":[],"type":[]&#125;,"adcode":"310115","street":[],"number":[],"location":"121.499740,31.239853","level":"兴趣点"&#125;]&#125; * @date 2019/03/27 */@Data@ToStringclass Geocodes &#123; private String location;&#125;@Data@ToStringclass Geocode &#123; private int status; private int count; private List&lt;Geocodes&gt; geocodes;&#125;/** * @ClassName: GeoCodingUtil * @Description: 高德地理编码/逆编码(将地址转换为经度,纬度) API: https://lbs.amap.com/api/webservice/guide/api/georegeo/#scene * @date 2019/03/14 */@Componentpublic class GeoCodingUtil &#123; @Autowired private RestTemplate restTemplate; @Autowired private GeocodingProperties properties; private static GeoCodingUtil geoCodingUtil; @PostConstruct private void init() &#123; geoCodingUtil = this; geoCodingUtil.properties = this.properties; geoCodingUtil.restTemplate = this.restTemplate; &#125; public List&lt;String&gt; getShanghaiGeocoding(List&lt;String&gt; address, boolean batch) &#123; List&lt;String&gt; point = new ArrayList&lt;&gt;(); System.out.println(geoCodingUtil.properties.toString()); GeoDto geoDto = new GeoDto(address, "上海", batch, geoCodingUtil.properties.getUrl(), geoCodingUtil.properties.getKey()); String realUrl = geoDto.toString(); System.out.println(realUrl); try &#123; Geocode geocode = geoCodingUtil.restTemplate.getForObject(realUrl, Geocode.class); int count = geocode.getCount(); if (count &gt; 0) &#123; List&lt;Geocodes&gt; geocodes = geocode.getGeocodes(); Iterator&lt;Geocodes&gt; iterator = geocodes.iterator(); String location; while (iterator.hasNext()) &#123; location = iterator.next().getLocation(); if (location == null) &#123; point.add(""); continue; &#125; point.add(location); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return point; &#125;&#125; 测试类123456789101112131415161718192021222324252627282930313233343536package com.sanss.util;import com.sanss.config.GeocodingProperties;import com.sanss.util.geocode.GeoCodingUtil;import java.util.ArrayList;import java.util.List;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class GeoCodingUtilTest &#123; @Autowired private GeocodingProperties properties; @Test public void propertiesTest() &#123; System.out.println(properties.getKey() + "\t" + properties.getUrl()); &#125; @Test public void getShanghaiGeocodingTest() &#123; // 目前最高支持十个地址查询 List&lt;String&gt; address = new ArrayList&lt;String&gt;(); address.add("东方明珠广播塔"); address.add("虹口足球场"); address.add("徐家汇地铁站"); List&lt;String&gt; points = new GeoCodingUtil().getShanghaiGeocoding(address, true); System.out.println(points); &#125;&#125; 打印结果 1[121.499740,31.239853, 121.480592,31.271447, 121.438133,31.191698]]]></content>
      <categories>
        <category>api</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java导出Excel并下载]]></title>
    <url>%2FBlog%2FJava%E5%AF%BC%E5%87%BAExcel%E5%B9%B6%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Java使用POI生成Excel、下载文件 Java查询结果生成多 Sheet 的页 Excel,提供页面导出功能查询结果直接导出 Excel 思路: 使用 import javax.servlet.http.HttpServletResponse 获取输出流,将文件写入,实现导出 controller 代码 1234567891011121314151617@RequestMapping(value = "xx" method = RequestMethod.POST)public void batchCommonalityQuery(HttpServletResponse response) &#123; try &#123; String fileName = file.getOriginalFilename(); // 文件名称 String name = "xx.xlsx"; response.setContentType("application/octet-stream"); response.addHeader("Content-Disposition", "attachment;filename=\"" + new String(name.getBytes("UTF-8"), "ISO-8859-1")); OutputStream outputStream = response.getOutputStream(); List&lt;List&lt;UserUrlVO&gt;&gt; list = this.commonalityService.batchCommonsQuery(file, outputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; service 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void exportExcel(List&lt;List&lt;T&gt;&gt; list, List&lt;String&gt; sheetName, String[] header, OutputStream out) &#123; HSSFWorkbook workbook = new HSSFWorkbook(); try &#123; for (int i = 0; i &lt; list.size(); i++) &#123; // sheet页名 HSSFSheet sheet = workbook.createSheet(sheetName.get(i)); // list内容 List&lt;T&gt; values = list.get(i); HSSFRow row;// = sheet.createRow(values.size()); // 设置行标题(Excel第一行) row = sheet.createRow(0); for (int h = 0; h &lt; header.length; h++) &#123; row.createCell(h).setCellValue(header[h]); sheet.autoSizeColumn(h, true); sheet.setColumnWidth(h, sheet.getColumnWidth(h) * 17 / 10); &#125; // 写入行 —— 单元格 for (int j = 0; j &lt; values.size(); j++) &#123; row = sheet.createRow(j + 1); Object object = values.get(j); // 遍历实体类属性 Field[] fields = object.getClass().getDeclaredFields(); // 单元格内容 for (int k = 0; k &lt; fields.length; k++) &#123; Field field = fields[k]; field.setAccessible(true); row.createCell(k).setCellValue(field.get(object).toString()); &#125; &#125; &#125; // 响应下载 workbook.write(out); out.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; out.flush(); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 将文件保存到服务器,提供返回下载路径 controller 代码 1234 @RequestMapping(value = "downloadFile")public void downloadFile(@RequestParam(value = "filepath", required = true) String filePath,HttpServletResponse response) &#123; this.commonalityService.downloadFile(filePath, response);&#125; service 代码 将文件写入本地 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final static String EXCEL_PATH = System.getProperty("os.name").toLowerCase().startsWith("win") ? "D:\\fileupload\\excel\\" : "/root/commonality"; // 将文件写入本地 private void writeExcel(List&lt;List&lt;T&gt;&gt; list, List&lt;String&gt; sheetName, String[] header, String fileName) &#123; HSSFWorkbook workbook = new HSSFWorkbook(); try &#123; for (int i = 0; i &lt; list.size(); i++) &#123; // sheet页名 HSSFSheet sheet = workbook.createSheet(sheetName.get(i)); // list内容 List&lt;T&gt; values = list.get(i); HSSFRow row;// = sheet.createRow(values.size()); // 设置行标题(Excel第一行) row = sheet.createRow(0); for (int h = 0; h &lt; header.length; h++) &#123; row.createCell(h).setCellValue(header[h]); sheet.autoSizeColumn(h, true); sheet.setColumnWidth(h, sheet.getColumnWidth(h) * 17 / 10); &#125; // 写入行 —— 单元格 for (int j = 0; j &lt; values.size(); j++) &#123; row = sheet.createRow(j + 1); Object object = values.get(j); // 遍历实体类属性 Field[] fields = object.getClass().getDeclaredFields(); // 单元格内容 for (int k = 0; k &lt; fields.length; k++) &#123; Field field = fields[k]; field.setAccessible(true); row.createCell(k).setCellValue(field.get(object).toString()); &#125; &#125; &#125; // 判断文件夹目录是否存在,不存在则创建 File file = new File(EXCEL_PATH); if (!file.exists()) &#123; // 创建的是多级目录,file.mkdir(); 只能创建一级目录 file.mkdirs(); &#125; // 生成文件保存到服务器 String path = EXCEL_PATH + fileName; FileOutputStream stream = new FileOutputStream(path); workbook.write(stream); stream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 下载文件 123456789101112131415161718192021222324252627282930313233public void downloadFile(String filePath, HttpServletResponse response) &#123; OutputStream outputStream = null; FileInputStream fis = null; try &#123; response.setContentType("application/octet-stream"); response.setCharacterEncoding("UTF-8"); response.addHeader("Content-Disposition", "attachment;filename=\"" + new String(filePath.getBytes("UTF-8"), "ISO-8859-1")); outputStream = response.getOutputStream(); fis = new FileInputStream(EXCEL_PATH + filePath); byte[] bytes = new byte[1024]; int lengtth = 0; while ((lengtth = fis.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, lengtth); &#125; outputStream.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (outputStream != null) &#123; outputStream.close(); &#125; if (fis != null) &#123; fis.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 公共方法 1234567891011121314151617181920212223242526272829// @描述：是否是2003的excel，返回true是2003private boolean isExcel2003(String filePath) &#123; return filePath.matches("^.+\\.(?i)(xls)$");&#125;// @描述：是否是2007的excel，返回true是2007private boolean isExcel2007(String filePath) &#123; return filePath.matches("^.+\\.(?i)(xlsx)$");&#125;private Object getCellFormatValue(Cell cell) &#123; Object cellValue = null; if (cell != null) &#123; switch (cell.getCellType()) &#123; case Cell.CELL_TYPE_NUMERIC: cellValue = NumberToTextConverter.toText(cell.getNumericCellValue()); break; case Cell.CELL_TYPE_STRING: cellValue = cell.getRichStringCellValue().getString().trim(); break; default: cellValue = ""; break; &#125; &#125; else &#123; cellValue = ""; &#125; return cellValue;&#125;]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百万数据转换地理编码]]></title>
    <url>%2FBlog%2FJava%2F%E7%99%BE%E4%B8%87%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2%E5%9C%B0%E7%90%86%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[导入地址信息文件,调用地理编码信息(高德地理编码) 批量地址数据获取地理编码信息(数据量可达百万) 本文章的来自于作者工作中的真实项目,如果看到文章的你有更好的建议,烦请在文章下留言或私信我。 逻辑梳理 获取上传的文件内容,转换为程序可操作的数据; 地址为空的数据,可以直接保存; 将地址转为需要入库的数据结构; 地址为数组,当地理编码数据异常时需要将当前数组保存为错误数据(目前是保存到文件中) 调用批量地理编码接口时,需要注意地址的格式 数据入库。 正常数据可使用分批入库,节省操作时间; 为空数据直接入库; 调用批量地理编码接口查询错误的数据,需要逐一查询确认查询结果无异议后,统一入库。 前言本文只阐述了作者在开发中的需求和实现,肯定和读者的境况有些不同需要读者自行调整和修改部分代码。对读者有帮助的可能是文件读取、多线程查询、指定大小截取二维数组、多线程入库等部分代码块,文章主要是为有困惑的读者提供部分思路,实际问题需要具体分析和解决。 配置文件 pom.xml 123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; application.yml 数据源配置可以参考作者的另一个篇文章,文章地址SpringBoot配置多数据源 12345678910111213141516171819202122232425262728293031323334spring: profiles: active: dev servlet: multipart: enabled: true max-file-size: 104857600 # 上传文件大小设置 max-request-size: 104857600geo: url: https://restapi.amap.com/v3/geocode/geo key: # 申请的keyjasypt: encryptor: password: 484bef877405a9c8---# developer environmentspring: profiles: dev datasource: primary: driver-class-name: com.cloudera.impala.jdbc41.Driver jdbc-url: jdbc:impala://127.0.0.1:21050/default secondary: driver-class-name: oracle.jdbc.OracleDriver # 不加密 jdbc-url: jdbc:oracle:thin:@//127.0.0.1:1521/testdb username: username password: pwd12563fileupload: geocode: path: # 文件保存地址 D:/fileupload/ name: # 保存的文件名 data.txt 配置文件实体类 错误数据保存地址 1234567891011121314151617181920212223242526272829import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import lombok.Data;import lombok.ToString;/** * @ClassName: GeocodeFileProperties * @Description: 高德地理编码查询失败文件保存地址 * @author Dew * @date 2019/08/09 */@Data@ToString@Configuration@ConfigurationProperties(prefix = "fileupload.geocode")public class GeocodeFileProperties /** * 文件保存路径 */ private String path; /** * 文件保存名称 */ private String name; &#125; 高德地理编码配置文件 12345678910111213141516171819import lombok.Data;import lombok.ToString;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;@Data@ToString@Primary@Configuration@ConfigurationProperties(prefix = "geo")public class GeocodingProperties &#123; private String url; private String key;&#125; SpringBoot使用RestTemplate调用RESRful1234567891011121314151617181920212223import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.ClientHttpRequestFactory;import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;import org.springframework.web.client.RestTemplate;@Configurationpublic class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate(ClientHttpRequestFactory factory) &#123; return new RestTemplate(factory); &#125; @Bean public ClientHttpRequestFactory simplClientHttpRequestFactory() &#123; HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(); factory.setConnectionRequestTimeout(10000); factory.setConnectTimeout(10000); factory.setReadTimeout(10000); return factory; &#125;&#125; 实体类 文件内容对应的实体类 123456789101112131415161718192021222324252627282930313233import java.io.Serializable;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;/** * @ClassName: AddressUserDTO * @Description: 用户上传文件对应实体类 * @date 2019/04/18 */@Data@NoArgsConstructor@AllArgsConstructorpublic class AddressUserDTO implements Serializable &#123; /** * 用户AD */ private String name; /** * 用户地址 */ private String address; @Override public String toString() &#123; return "&#123;\"name\":\"" + name + "\", \"address\":\"" + address + "\"&#125;"; &#125;&#125; 入库的实体类 12345678910111213141516171819202122232425262728293031323334import java.io.Serializable;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;/** * @ClassName: GDPoint * @Description: 将经纬度转换为 数据库经纬度 50m 栅格编码 : X= trunc( 经度/0.000129 ), Y= trunc(纬度/0.00245) 取整 * @date 2019/02/20 */@Data@ToString@NoArgsConstructorpublic class GDPoint implements Serializable &#123; private final double X = 0.000129, Y = 0.00245; /** * 经度 */ private Integer longitude; /** * 维度 */ private Integer latitude; public GDPoint(String longitude, String latitude) &#123; double lng = Double.parseDouble(longitude); double lat = Double.parseDouble(latitude); this.longitude = (int) Math.ceil(lng / X); this.latitude = (int) Math.ceil(lat / Y); &#125;&#125; 网格数据实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import lombok.Data;import lombok.ToString;/** * @Title 网格数据库实体类映射 * @Description 数据入库实体类 * @Author Dew * @Date 2019/3/29 15:56 * @Version 1.0 */@Data@ToStringpublic class AddressGridDO &#123; /** * 地址 */ private String address; /** * 经度 */ private String longitude; /** * 纬度 */ private String latitude; /** * 网格编号X */ private Integer gridX; /** * 网格编号Y */ private Integer gridY; public AddressGridDO() &#123; &#125; public AddressGridDO(String address) &#123; this.address = address; this.gridX = 0; this.gridY = 0; this.longitude = ""; this.latitude = ""; &#125; public AddressGridDO(String address, String longitude, String latitude, Integer gridX, Integer gridY) &#123; this.address = address; this.longitude = longitude; this.latitude = latitude; this.gridX = gridX; this.gridY = gridY; &#125; &#125; Repository 数据库使用的是Oracle,如果是使用MySQL或其他数据库烦请自行百度.暂时没有添加相关代码。 数据源配置可以参考作者的另一个篇文章,文章地址SpringBoot配置多数据源 地址转换为网格后的数据入库 1234567891011121314151617181920212223242526272829303132333435import java.util.List;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;import org.springframework.jdbc.core.namedparam.SqlParameterSource;import org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils;import org.springframework.stereotype.Repository;@Slf4j@Repositorypublic class AddressRepository &#123; @Autowired private NamedParameterJdbcTemplate secondaryJdbcTemplate; /** * @Description 用户网格数据批量入库 * @Param [list 入库的数据] * @Date 14:45 2019/4/1 * @Return void **/ public void batchSaveAdvertising(List&lt;AddressGridDO&gt; list) &#123; long start = System.currentTimeMillis(); // merge into 语法是存在则替换,需要特别注意数据更新的条件.以免出现数据被批量更新为同一记录! String sql = "merge into t_address_grid t1 using(select :address address,:longitude longitude,:latitude latitude,:gridX gridX,:gridY gridY from dual) t2 on (t1.address = t2.address) when matched then update set t1.longitude=t2.longitude , t1.latitude = t2.latitude , t1.grid_x = t2.gridx , t1.grid_y = t2.gridy when not matched then insert (t1.address,t1.longitude,t1.latitude,t1.grid_x,t1.grid_y) values (t2.address,t2.longitude,t2.latitude,t2.gridx,t2.gridy)"; SqlParameterSource[] beanSource = SqlParameterSourceUtils.createBatch(list.toArray()); secondaryJdbcTemplate.batchUpdate(sql, beanSource); long end = System.currentTimeMillis(); log.info("数据入库时间:\t&#123;&#125;,入库数据大小:\t&#123;&#125;", (end - start), list.size()); &#125;&#125; Service逻辑实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677import java.io.BufferedInputStream;import java.io.BufferedReader;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.nio.file.FileAlreadyExistsException;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;/** * @ClassName: GeocodeServiceImpl * @Description: 地址信息网格化 * @date 2019/04/16 */@Slf4j@Servicepublic class GeocodeServiceImpl implements SynchronizeInformationService &#123; private GeocodeFileProperties geocodeFileProperties; private AddressRepository addressRepository; @Autowired public GeocodeServiceImpl(GeocodeFileProperties geocodeFileProperties, AddressRepository addressRepository) &#123; this.geocodeFileProperties = geocodeFileProperties; this.addressRepository = addressRepository; &#125; @Override public Object synchronizationInformation(MultipartFile file) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put("success", false); Long timestamp = System.currentTimeMillis(); try &#123; AnalysisText analysisText = new AnalysisText(); // 读取文件内容,并且拆分为10个一组的list Map&lt;String, List&lt;List&lt;AddressUserDTO&gt;&gt;&gt; txtList = analysisText.txt2List(file); List&lt;List&lt;AddressUserDTO&gt;&gt; models = txtList.get("group"); log.info("不为空地址数量:\t" + ((models.size() - 1) * 10 + (models.get(models.size() - 1)).size())); this.batchSaveByAddressNotEmpty(models, true, timestamp); List&lt;List&lt;AddressUserDTO&gt;&gt; emptys = txtList.get("emptyList"); log.info("为空地址请求列表数:" + emptys.get(0).size()); this.batchSaveByAddressNotEmpty(emptys, false, timestamp); // 读取查询地理编码错误地址内容,入库 this.saveErrorData(timestamp); result.put("success", true); result.put("msg", "导入成功"); &#125; catch (FileAlreadyExistsException e) &#123; log.info("不存在错误地址"); &#125; catch (IOException e) &#123; result.put("msg", "系统错误,请重试或联系管理员"); e.printStackTrace(); &#125; catch (Exception e) &#123; result.put("msg", "文件内容有误,请联系管理员"); e.printStackTrace(); &#125; return result; &#125; /** * @param models txt文本数据 * @param flag true: 地址不为空 false: 地址为空 void * @Title: batchSave * @Description: 批量保存地址信息数据,创建的线程数取决于机器的配置。需要根据自身情况增加或减少,如果引起宕机等后果本人概不负责………… */ private void batchSaveByAddressNotEmpty(List&lt;List&lt;AddressUserDTO&gt;&gt; models, boolean flag, Long timestamp) &#123; // 10w 二维数组长度List List&lt;List&lt;AddressGridDO&gt;&gt; groupList = new AnalysisText().groupList(models, 3000, flag, timestamp); log.info("##查询分组数据大小: &#123;&#125;", groupList.size()); // 100w 数据待保存,最多创建4个线程 // 创建线程数 = 数据总数 / groupList int threadPoolSize = groupList.size(); // 最多创建 4 个线程 threadPoolSize = threadPoolSize &gt;= 4 ? 4 : threadPoolSize; log.info("##不为空: &#123;&#125; 地址列表,入库创建的线程数: &#123;&#125;", threadPoolSize); ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize); try &#123; // 拆分网格数据 for (int i = 0, length = groupList.size(); i &lt; length; i++) &#123; List&lt;AddressGridDO&gt; list = groupList.get(i); BatchSaveThread saveThread = new BatchSaveThread(list); executor.execute(saveThread); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; finally &#123; executor.shutdown(); log.info("##不为空: &#123;&#125;,地址列表入库完成", flag); &#125; &#125; /** * @Title: saveErrorData * @Description: 保存查询错误的地址信息 void */ private void saveErrorData(Long timestamp) throws FileAlreadyExistsException &#123; String path = geocodeFileProperties.getPath() + "/" + timestamp + "_" + geocodeFileProperties.getName(); FileReader reader = null; BufferedReader br = null; try &#123; // 校验文件是否存在 File file = new File(path); if (!file.exists()) &#123; log.info("无错误数据"); throw new FileNotFoundException(); &#125; reader = new FileReader(path); br = new BufferedReader(reader); // 读取文件内容 String line; List&lt;AddressUserDTO&gt; models = null; List&lt;AddressUserDTO&gt; list = new ArrayList&lt;&gt;(); while ((line = br.readLine()) != null) &#123; models = JSON.parseArray(line, AddressUserDTO.class); list.addAll(models); &#125; // 错误数据List log.info("错误地址数据量:\t" + list.size()); List&lt;AddressGridDO&gt; geocode = new ArrayList&lt;&gt;(); AddressGridDO value = null; // 地理编码——经纬度 String[] array; // 用户AD、用户地址、经度,纬度 String name, address, longitude, latitude; GeoCodingUtil geoCodingUtil = new GeoCodingUtil(); for (AddressUserDTO advertisingModel : list) &#123; name = advertisingModel.getName(); address = advertisingModel.getAddress(); String point = geoCodingUtil.getShanghaiGeocoding(address); if ("[]".equals(point)) &#123; value = new AddressGridDO(advertisingModel.getName(), "", "", 0, 0); geocode.add(value); continue; &#125; // 获取经纬度 array = point.split(","); longitude = array[0]; latitude = array[1]; GDPoint gdPoint = new GDPoint(longitude, latitude); value = new AddressGridDO(name, longitude, latitude, gdPoint.getLongitude(), gdPoint.getLatitude()); geocode.add(value); &#125; // 多线程 执行数据入库 this.saveBatchErrorData(geocode, 1000); &#125; catch (FileNotFoundException fileNotFoundException) &#123; log.error("当前导入的文件中没有错误数据"); &#125; catch (Exception e) &#123; log.error("存错误地址信息方法错误,错误内容:\t" + e.getMessage()); e.printStackTrace(); &#125; finally &#123; try &#123; if (reader != null) &#123; reader.close(); &#125; if (br != null) &#123; br.close(); &#125; // 删除文件 File file = new File(path); if (file.exists() &amp;&amp; file.isFile()) &#123; file.delete(); log.info("删除文件路径:\t" + path); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* * @Title saveBatchErrorData * @Description 批量保存错误地址编码 * @Param * @param geocode * @return void **/ private void saveBatchErrorData(List&lt;AddressGridDO&gt; geocode, int groupSize) &#123; // 批量入库 AnalysisText analysisText = new AnalysisText(); List&lt;List&lt;AddressGridDO&gt;&gt; geocodeList = analysisText.spilitGroup(geocode, groupSize * 10); int threadPoolSize = geocodeList.size(); threadPoolSize = threadPoolSize &gt;= 4 ? 4 : threadPoolSize; ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize); try &#123; // 拆分网格数据 for (int i = 0, length = geocodeList.size(); i &lt; length; i++) &#123; List&lt;AddressGridDO&gt; list = geocodeList.get(i); BatchSaveThread saveThread = new BatchSaveThread(list); executor.execute(saveThread); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; finally &#123; executor.shutdown(); log.info("不为空地址列表入库完成"); &#125; &#125; /** * @ClassName: BatchSaveThread * @Description: 多线程执行入库操作 * @date 2019/03/14 */ class BatchSaveThread implements Runnable &#123; private List&lt;AddressGridDO&gt; list; public BatchSaveThread(List&lt;AddressGridDO&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; if (list.size() &gt; 0) &#123; addressRepository.batchSaveAdvertising(list); &#125; &#125; &#125; /** * @ClassName: BatchRestAPIThread * @Description: 多线程查询API, 地理编码操作 * @date 2019/03/18 */ class BatchRestAPIThread implements Callable&lt;List&lt;AddressGridDO&gt;&gt; &#123; AnalysisText analysisText = new AnalysisText(); private Long timestamp; private List&lt;List&lt;AddressUserDTO&gt;&gt; list; public BatchRestAPIThread(Long timestamp, List&lt;List&lt;AddressUserDTO&gt;&gt; list) &#123; this.timestamp = timestamp; this.list = list; &#125; @Override public List&lt;AddressGridDO&gt; call() throws Exception &#123; List&lt;AddressGridDO&gt; result = new ArrayList&lt;&gt;(); for (int i = 0, length = list.size(); i &lt; length; i++) &#123; result.addAll(analysisText.geocodes(list.get(i), timestamp)); &#125; return result; &#125; &#125; /** * @ClassName: AnalysisText * @Description: 解析批量导入的txt文件 * @date 2019/03/14 */ class AnalysisText &#123; /* * @Title txt2List * @Description txt 文件解析为两组list : &#123;"group":地址不为空的List&lt;List&lt;AddressUserDTO&gt;&gt;,"emptyList": address 为空的List&#125; * @Param * @param file * @return java.util.Map&lt;java.lang.String,java.util.List&lt;java.util.List&lt;com.sanss.entity.dto.AddressUserDTO&gt;&gt;&gt; **/ private Map&lt;String, List&lt;List&lt;AddressUserDTO&gt;&gt;&gt; txt2List(MultipartFile file) throws IOException &#123; Map&lt;String, List&lt;List&lt;AddressUserDTO&gt;&gt;&gt; result = new HashMap&lt;&gt;(); InputStreamReader reader = null; BufferedReader br = null; List&lt;List&lt;AddressUserDTO&gt;&gt; group = new ArrayList&lt;&gt;(); List&lt;List&lt;AddressUserDTO&gt;&gt; emptyList = new ArrayList&lt;&gt;(); AddressUserDTO value = null; // 地址不为空的数据 List&lt;AddressUserDTO&gt; list = new ArrayList&lt;&gt;(10); // 地址为空的数据 List&lt;AddressUserDTO&gt; empty = new ArrayList&lt;&gt;(); try &#123; String encoding = this.getEncoding(file); log.info("文件编码格式:\t&#123;&#125;", encoding); // 设置字符编码,中文乱码 // reader = new InputStreamReader(file.getInputStream(), "UTF-8"); reader = new InputStreamReader(file.getInputStream(), encoding); // reader = new InputStreamReader(file.getInputStream(), "GBK"); // 缓存读取文件 br = new BufferedReader(reader); String line = null; // 内数组大小 int i = 0; int j = 0; String[] split; String userAD, address; while ((line = br.readLine()) != null) &#123; if (!"".equals(line)) &#123; // 设置行内分隔符"，" split = line.split(","); // 用户AD userAD = split[0]; // 用户地址,示例："世纪大道地铁站***" address = split[1]; address = address.trim().replaceAll("\\*", ""); // 地址为空与不为空拆分开 if (!"".equals(address)) &#123; value = new AddressUserDTO(userAD, address); list.add(value); ++i; &#125; else &#123; value = new AddressUserDTO(userAD, ""); empty.add(value); continue; &#125; // 十个一组分成若干小组 if (i % 10 == 0 &amp;&amp; i &gt; 0) &#123; group.add(j, list); list = new ArrayList&lt;&gt;(10); j++; &#125; &#125; &#125; // 行数对10取余不足10的部分 if (!"[]".equals(list.toString()) &amp;&amp; list != null) &#123; group.add(j, list); &#125; // Empty list 不进行 10 分组 emptyList.add(empty); result.put("group", group); result.put("emptyList", emptyList); return result; &#125; catch (IOException e) &#123; result.put("group", group); result.put("emptyList", emptyList); return result; &#125; finally &#123; reader.close(); br.close(); log.info("文件读完:\t" + new Date()); &#125; &#125; /* * @Title getEncoding * @Description 获取文件编码 * @Param * @param file * @return java.lang.String **/ private String getEncoding(MultipartFile file) throws IOException &#123; BufferedInputStream inputStream = new BufferedInputStream(file.getInputStream()); int p = (inputStream.read() &lt;&lt; 8) + inputStream.read(); String encoding = null; switch (p) &#123; case 0xefbb: encoding = "UTF-8"; break; case 0xfffe: encoding = "Unicode"; break; case 0xfeff: encoding = "UTF-16BE"; break; case 0x5c75: encoding = "ANSI|ASCII"; break; default: encoding = "GBK"; break; &#125; return encoding; &#125; /** * @param groupSize 分组区间 * @param flag true:地址不为空|false:地址为空 * @Title: groupList * @Description: 地址为空、地址不为空 —— 地理编码 */ private List&lt;List&lt;AddressGridDO&gt;&gt; groupList(List&lt;List&lt;AddressUserDTO&gt;&gt; list, int groupSize, boolean flag, Long timestamp) &#123; // if (flag) &#123; return this.groupNotEmpty(list, groupSize, timestamp); &#125; if (flag) &#123; return this.groupNotEmptySinglethread(list, groupSize, timestamp); &#125; return this.groupEmpty(list, groupSize); &#125; /** * @param modelGroup 10个地址为一组的List * @param groupSize 分组大小 * @param timestamp 访问API接口的时间戳 * @Title: groupNotEmptySinglethread * @Description: 不为空地址列表使用单线程查询API, 获取返回结果 */ private List&lt;List&lt;AddressGridDO&gt;&gt; groupNotEmptySinglethread(List&lt;List&lt;AddressUserDTO&gt;&gt; modelGroup, int groupSize, Long timestamp) &#123; List&lt;AddressGridDO&gt; list = new ArrayList&lt;&gt;(); List&lt;List&lt;AddressGridDO&gt;&gt; listGroup = new ArrayList&lt;&gt;(); try &#123; AnalysisText analysisText = new AnalysisText(); for (int i = 0, length = modelGroup.size(); i &lt; length; i++) &#123; list.addAll(analysisText.geocodes(modelGroup.get(i), timestamp)); &#125; // 10w 数组查询 API后返回的是100w 数据,数据按 groupSize * 10 一组拆分 listGroup = this.spilitGroup(list, groupSize * 10); return listGroup; &#125; catch (Exception e) &#123; e.printStackTrace(); return listGroup; &#125; &#125; /* * @Title groupNotEmptyMultithreading * @Description groupNotEmptyMultithreading 多线程方法,当前机器使用多线程速率反而更慢 * 不为空地址列表使用多线程查询API, 获取返回结果 * @Param * @param modelGroup 10个地址为一组的List * @param groupSize 分组大小 * @param timestamp 访问API接口的时间戳 * @return java.util.List&lt;java.util.List&lt;com.sanss.entity.AddressGridDO&gt;&gt; **/ @Deprecated private List&lt;List&lt;AddressGridDO&gt;&gt; groupNotEmptyMultithreading(List&lt;List&lt;AddressUserDTO&gt;&gt; modelGroup, int groupSize, Long timestamp) &#123; List&lt;AddressGridDO&gt; list = new ArrayList&lt;&gt;(); List&lt;List&lt;AddressGridDO&gt;&gt; listGroup = new ArrayList&lt;&gt;(); ExecutorService executor = null; try &#123; // List 长度 int listSize = modelGroup.size(); int runSize = (listSize / groupSize) + 1; List&lt;List&lt;AddressUserDTO&gt;&gt; value = null; List&lt;List&lt;List&lt;AddressUserDTO&gt;&gt;&gt; models = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; runSize; i++) &#123; int start = i * groupSize; if (i + 1 == runSize) &#123; int end = listSize; value = modelGroup.subList(start, end); &#125; else &#123; int end = (i + 1) * groupSize; value = modelGroup.subList(start, end); &#125; models.add(value); &#125; // 创建多线程查询API int threadPoolSize = models.size(); executor = Executors.newFixedThreadPool(threadPoolSize); threadPoolSize = threadPoolSize &gt;= 4 ? 4 : threadPoolSize; log.info("查询API线程数:\t" + threadPoolSize); for (int i = 0, length = models.size(); i &lt; length; i++) &#123; BatchRestAPIThread apiThread = new BatchRestAPIThread(timestamp, models.get(i)); Future&lt;List&lt;AddressGridDO&gt;&gt; values = executor.submit(apiThread); list.addAll(values.get()); &#125; // 10w 数组查询 API后返回的是100w 数据,数据按1000一组拆分 listGroup = this.spilitGroup(list, groupSize * 10); return listGroup; &#125; catch (Exception e) &#123; e.printStackTrace(); return listGroup; &#125; finally &#123; if (executor != null) &#123; executor.shutdown(); &#125; &#125; &#125; /** * @Title: groupEmpty * @Description: 地址为空的数据拆分 */ private List&lt;List&lt;AddressGridDO&gt;&gt; groupEmpty(List&lt;List&lt;AddressUserDTO&gt;&gt; modelList, int groupSize) &#123; List&lt;AddressGridDO&gt; adList = new ArrayList&lt;&gt;(); // 数组下标为0 List&lt;AddressUserDTO&gt; models = modelList.get(0); AddressGridDO adUserGridDO = null; String name; for (int i = 0; i &lt; models.size(); i++) &#123; AddressUserDTO model = models.get(i); name = model.getName(); adUserGridDO = new AddressGridDO(name, "", "", 0, 0); adList.add(adUserGridDO); &#125; return this.spilitGroup(adList, groupSize * 10); &#125; /** * @param values List 数组 * @param groupSize 数组分组大小 * @Title: spilitGroup * @Description: 数据分成 groupSize 大的数组,多线程执行入库 */ private List&lt;List&lt;AddressGridDO&gt;&gt; spilitGroup(List&lt;AddressGridDO&gt; values, int groupSize) &#123; List&lt;List&lt;AddressGridDO&gt;&gt; listGroup = new ArrayList&lt;&gt;(); // List 长度 int listSize = values.size(); int runSize = (listSize / groupSize) + 1; List&lt;AddressGridDO&gt; value = null; for (int i = 0; i &lt; runSize; i++) &#123; int start = i * groupSize; if (i + 1 == runSize) &#123; int end = listSize; value = values.subList(start, end); &#125; else &#123; int end = (i + 1) * groupSize; value = values.subList(start, end); &#125; listGroup.add(value); &#125; return listGroup; &#125; /** * @return List&lt;AddressGridDO&gt; * @Title: geocodes * @Description: 将地址转为 网格,只取address不为空的数据 */ private List&lt;AddressGridDO&gt; geocodes(List&lt;AddressUserDTO&gt; adUserDto, Long timestamp) &#123; List&lt;AddressGridDO&gt; result = new ArrayList&lt;&gt;(); try &#123; // 高德地理编码,批量请求地址参数 List&lt;String&gt; address = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; adUserDto.size(); i++) &#123; address.add(adUserDto.get(i).getAddress()); &#125; // 查询地理编码 —— 上海 List&lt;String&gt; points = new GeoCodingUtil().getShanghaiGeocoding(address); // 查询的地址个数返回结果不等于地址个数时,抛出异常 if (points.size() != adUserDto.size()) &#123; /// log.error("查询地址个数不等于返回个数:\t" + JSON.toJSONString(adUserDto) + "\t返回结果:\t" + points); throw new Exception(); &#125; AddressGridDO value = null; // 地理编码——经纬度 String[] array; // 经度,纬度 String longitude, latitude; // 用户编号 String name; for (int i = 0; i &lt; points.size(); i++) &#123; name = adUserDto.get(i).getName(); /** 将地理编码转换为50m栅格编码*/ String point = points.get(i); // point:[[],[121.389822,31.258292]] if ("[]".equals(point)) &#123; value = new AddressGridDO(name, "", "", 0, 0); result.add(value); continue; &#125; // 获取经纬度 array = point.split(","); longitude = array[0]; latitude = array[1]; GDPoint gdPoint = new GDPoint(longitude, latitude); value = new AddressGridDO(name, longitude, latitude, gdPoint.getLongitude(), gdPoint.getLatitude()); result.add(value); &#125; return result; &#125; /* catch (SocketTimeoutException e) &#123; this.appendDataFile(adUserDto, timestamp); &#125; catch (NullPointerException e) &#123; this.appendDataFile(adUserDto, timestamp); &#125; */ catch (Exception e) &#123; this.appendDataFile(adUserDto, timestamp); &#125; return result; &#125; /** * @param models void * @Title: createDataFile * @Description: 查询异常的用户地址保存为文件 */ private void appendDataFile(List&lt;AddressUserDTO&gt; models, Long timestamp) &#123; StringBuilder sb = new StringBuilder(); // models.toString() 方法是返回JSON字符串,并不是普通的toString()方法 sb.append(JSON.toJSONString(models) + System.getProperty("line.separator")); FileWriter fw = null; PrintWriter pw = null; String txtName = timestamp + "_" + geocodeFileProperties.getName(); String txtPath = geocodeFileProperties.getPath(); try &#123; File file = new File(txtPath); if (!file.exists()) &#123; file.mkdirs(); &#125; fw = new FileWriter(file + "/" + txtName, true); pw = new PrintWriter(fw); pw.print(sb.toString()); pw.flush(); fw.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; pw.close(); fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 高德地理编码API工具类 二维数组拆分为指定大小 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.List;/** * @ClassName ArrayUtil * @Description &lt;br/&gt; 数组操作工具类 * @Author Dew * @Date 2019/4/1 13:53 * @Version 1.0 **/public class ArrayUtil&lt;T&gt; &#123; /** * @Author Dew * @Description 拆分二维数组为指定大小 * @Param [values 待分组Array 分组, groupSize 分组大小] * @Date 13:54 2019/4/1 * @Return java.util.List&lt;T&gt; **/ public List&lt;List&lt;T&gt;&gt; spilitGroup(List&lt;T&gt; values, int groupSize) &#123; List&lt;List&lt;T&gt;&gt; listGroup = new ArrayList&lt;&gt;(); // List 长度 int listSize = values.size(); int runSize = (listSize / groupSize) + 1; List&lt;T&gt; value = null; for (int i = 0; i &lt; runSize; i++) &#123; int start = i * groupSize; if (i + 1 == runSize) &#123; int end = listSize; value = values.subList(start, end); &#125; else &#123; int end = (i + 1) * groupSize; value = values.subList(start, end); &#125; listGroup.add(value); &#125; return listGroup; &#125;&#125; 高德地理编码API调用实例 注: 在非 controller 中读取配置文件时获取不到配置类的属性值,欲了解详情可以看下我的另一篇博客SpringBoot配置文件详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185import java.util.ArrayList;import java.util.Iterator;import java.util.List;import javax.annotation.PostConstruct;import lombok.Data;import lombok.ToString;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.client.RestTemplate;/** * @ClassName: GeoDto * @Description: 调用高德地理编码API传递的参数实体类 * @date 2019/03/27 */@Dataclass GeoDto &#123; private Boolean batch; private String city; private String address; private String url; private String key; public GeoDto() &#123; &#125; public GeoDto(List&lt;String&gt; address, String city, Boolean batch, String url, String key) &#123; StringBuilder addressSb = new StringBuilder(); for (int i = 0, length = address.size(); i &lt; length; i++) &#123; addressSb.append(address.get(i)); addressSb.append("|"); &#125; this.address = addressSb.substring(0, addressSb.lastIndexOf("|")).toString(); this.city = city; this.batch = batch; this.url = url; this.key = key; &#125; @Override public String toString() &#123; return url + "?batch=" + batch + "&amp;key=" + key + "&amp;city=" + city + "&amp;address=" + address; &#125;&#125;/** * @ClassName: Geocodes * @Description: 返回结果实体类, 只获取了location:经纬度 API 地址：https://lbs.amap.com/api/webservice/guide/api/georegeo 返回结果示例: * &#123;"status":"1","info":"OK","infocode":"10000","count":"1","geocodes":[&#123;"formatted_address":"上海市浦东新区东方明珠","country":"中国","province":"上海市","citycode":"021","city":"上海市","district":"浦东新区","township":[],"neighborhood":&#123;"name":[],"type":[]&#125;,"building":&#123;"name":[],"type":[]&#125;,"adcode":"310115","street":[],"number":[],"location":"121.499740,31.239853","level":"兴趣点"&#125;]&#125; * @date 2019/03/27 */@Data@ToStringclass Geocodes &#123; private String location;&#125;/** * @Title * @Description 高德地理编码API返回JSON实体类, 部分需要的属性, 完整的返回值在上方 * @return **/@Data@ToStringclass Geocode &#123; private int status; private int count; private List&lt;Geocodes&gt; geocodes;&#125;/** * @ClassName: GeoCodingUtil * @Description: 高德地理编码/逆编码(将地址转换为经度,纬度) API: https://lbs.amap.com/api/webservice/guide/api/georegeo/#scene * @date 2019/03/14 */@Slf4j@Componentpublic class GeoCodingUtil &#123; @Autowired private RestTemplate restTemplate; @Autowired private GeocodingProperties properties; private static GeoCodingUtil geoCodingUtil; private static Long index = 0L; @PostConstruct private void init() &#123; geoCodingUtil = this; geoCodingUtil.properties = this.properties; geoCodingUtil.restTemplate = this.restTemplate; log.info("请求API地址:\t&#123;&#125;", properties.getUrl()); &#125; /** * @param address 地址List * @param city 城市名称,例如:上海,北京 * @Title: getGeocoding * @Description: 获取批量地址地理编码 * @Return List&lt;String&gt; */ public List&lt;String&gt; getGeocoding(List&lt;String&gt; address, String city) throws Exception &#123; return getGeocoding(address, city, true); &#125; /** * @param address 地址List * @Title: getShanghaiGeocoding * @Description: 获取上海地区批量地址的地理编码 * @ReturnType: List&lt;String&gt; */ public List&lt;String&gt; getShanghaiGeocoding(List&lt;String&gt; address) throws Exception &#123; return getGeocoding(address, "上海", true); &#125; /** * @param address 地址 * @Title: getShanghaiGeocoding * @Description: 获取上海地区单个地址的地理编码 * @ReturnType: String */ public String getShanghaiGeocoding(String address) throws Exception &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(address); list = getGeocoding(list, "上海", false); String empty = new ArrayList&lt;&gt;().toString(); if (empty.equals(list.toString())) &#123; return list.toString(); &#125; return list.get(0); &#125; /** * @param address 最多支持十个地址拼接 * @param city 城市 * @param batch 是否批量 * @Title: getGeocoding * @Description: 上海地区的高德地理编码获取 * @Return List&lt;String&gt; */ private List&lt;String&gt; getGeocoding(List&lt;String&gt; address, String city, boolean batch) throws Exception &#123; List&lt;String&gt; point = new ArrayList&lt;&gt;(); GeoDto geoDto = new GeoDto(address, city, batch, geoCodingUtil.properties.getUrl(), geoCodingUtil.properties.getKey()); String realUrl = geoDto.toString(); Geocode geocode = geoCodingUtil.restTemplate.getForObject(realUrl, Geocode.class); int count = geocode.getCount(); if (count &gt; 0) &#123; List&lt;Geocodes&gt; geocodes = geocode.getGeocodes(); Iterator&lt;Geocodes&gt; iterator = geocodes.iterator(); String location; while (iterator.hasNext()) &#123; location = iterator.next().getLocation(); if (location == null) &#123; point.add(""); continue; &#125; point.add(location); &#125; &#125; return point; &#125;&#125; 常见问题RestTemplate 调用API超时 解决方案 配置类RestTemplateConfig中不设置connectTimeout、readTimeout 将超时时间变长,timeout时间单位为 毫秒 实现多线程有返回值的执行123456789101112131415161718192021/** * @ClassName: BatchRestAPIThread * @Description: 多线程查询API,地理编码操作 * @date 2019/03/18 */ class BatchRestAPIThread implements Callable&lt;List&lt;InfoDo&gt;&gt; &#123; private List&lt;List&lt;InfoDto&gt;&gt; list; public BatchRestAPIThread(List&lt;List&lt;InfoDto&gt;&gt; list) &#123; this.list = list; &#125; @Override public List&lt;InfoDo&gt; call() throws Exception &#123; List&lt;InfoDo&gt; result = new ArrayList&lt;&gt;(); // 执行代码块 return result; &#125; &#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用正则表达式仅获取中文]]></title>
    <url>%2FBlog%2FJava%2FJava%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%85%E8%8E%B7%E5%8F%96%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[Java 使用正则表达式获取字符串中的中文,将字母、数字、下划线等去除.字符串为现网电视剧订购series_order Java 代码1234567891011121314public static void main(String[] args) &#123; String jsonStr = "[&#123;\"number\":16,\"name\":\"现网电视剧订购series_order\"&#125;,&#123;\"number\":17,\"name\":\"电影详情页movie_detail\"&#125;,&#123;\"number\":19,\"name\":\"限免专区biz_30127402\"&#125;,&#123;\"number\":19,\"name\":\"综艺详情variety_detail\"&#125;,&#123;\"number\":24,\"name\":\"电视剧记录与收藏series_fav\"&#125;,&#123;\"number\":24,\"name\":\"热门推荐biz_79818028\"&#125;,&#123;\"number\":38,\"name\":\"电影专区biz_17101799\"&#125;,&#123;\"number\":49,\"name\":\"电视剧详情页series_detail\"&#125;,&#123;\"number\":53,\"name\":\"现网电视剧播放series_play\"&#125;,&#123;\"number\":103,\"name\":\"热门推荐biz_87847639\"&#125;]"; List&lt;rank&gt; result = JSONArray.parseArray(jsonStr, rank.class); System.out.println(result); String name = ""; String regex = "[a-zA-Z]"; String[] array = new String[3]; for (rank rank : result) &#123; name = rank.getname(); array = name.split(regex); rank.setname(array[0]); &#125; System.out.println(result.toString());&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Java</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ext4.2.4上传文件]]></title>
    <url>%2FBlog%2FExt%2FExt4.2.4%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用Ext 4.2.4版本导入.xls、xlsx文件内容到数据库 页面内容12 js 内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Ext.onReady(function () &#123; Ext.create('Ext.window.Window', &#123; id: "importInfo", title: "导入广告平台用户", autoShow: true, modal: true, constrainHeader: true, resizable: false, height: 250, width: 550, layout: "fit", items: [&#123; xtype: 'form', width: 400, bodyPadding: 10, items: [&#123; xtype: 'filefield', name: 'file', fieldLabel: '文件上传', labelWidth: 80, msgTarget: 'side', allowBlank: false, anchor: '100%', buttonText: '选择文件' &#125;], buttons: [&#123; text: '上传', handler: function () &#123; var form = this.up('form').getForm(); if (form.isValid()) &#123; form.submit(&#123; url: '../user/importADInformation.do', method: 'POST', waitMsg: '文件正在上传', success: function (form, action) &#123; Ext.Msg.alert('Success', '广告用户信息导入成功'); Ext.getCmp("importInfo").close(); &#125;, failure: function(form, action)&#123; var result = Ext.JSON.decode(action.response.responseText) Ext.Msg.alert('Failed', result.msg); Ext.getCmp("importInfo").close(); &#125; &#125;); &#125; &#125; &#125;] &#125;] &#125;);&#125;); Java 后端代码123456789101112131415161718--top | --Controller | ---AdvertisingController | --Repository | ---AdvertisingUserDao | --Entity | ---AdvertisingEntity ---AdvertisingModel | --listeners | ---ImportAdvertisingUserExcelListener Controller123456789101112131415161718192021222324252627282930313233343536373839404142@ResponseBody@RequestMapping(value = "importADInformation", consumes = "multipart/*", headers = "content-type=multipart/form-data", method = RequestMethod.POST)@MethodLog(remark = "批量导入用户数据")public Object synchronizationInformation(@RequestParam(value = "file", required = false) MultipartFile file) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put("success", false); // 1. 获取Excel 内容,将Excel转换为List InputStream inputStream = null; try &#123; inputStream = new BufferedInputStream(file.getInputStream()); // 引用 easyexcel jar 代码地址：https://github.com/alibaba/easyexcel/ // 使用 EasyExcel 读取 excel 文件内容,将 excel 转为 List&lt;Object&gt; ImportAdvertisingUserExcelListener excelListener = new ImportAdvertisingUserExcelListener(); // 读excel数据,返回List&lt;Object&gt;.将 地址信息转为 50m 栅格编码,并将结果返回 EasyExcelFactory.readBySax(inputStream, new Sheet(1, 1, AdvertisingModel.class), excelListener); List&lt;Object&gt; data = excelListener.getData(); // 2. 获取入库的List List&lt;AdvertisingEntity&gt; list = JSONArray.parseArray(JSONObject.toJSONString(data), AdvertisingEntity.class); System.out.println(JSONObject.toJSONString(list)); this.advertisingUserDao.batchSave(list); result.put("success", true); result.put("msg", "数据导入成功"); &#125; catch (IllegalArgumentException GDException) &#123; result.put("msg", "文件格式错误"); &#125; catch (IOException e) &#123; result.put("msg", "IO异常"); &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; result.put("msg", "IO异常"); &#125; catch (Exception e) &#123; result.put("msg", "文件类型错误(应为*.xls或*.xlsx)"); e.printStackTrace(); &#125; &#125; return result;&#125; Repository1234567891011121314151617181920public void batchSave(List&lt;AdvertisingEntity&gt; list) &#123; Session session = null; try &#123; session = this.getSession(); Transaction transaction = session.beginTransaction(); for (int i = 0; i &lt; list.size(); i++) &#123; AdvertisingEntity adverst = list.get(i); session.saveOrUpdate(adverst); if (i % 100 == 0) &#123; session.flush(); session.clear(); &#125; &#125; transaction.commit(); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; session.close(); &#125;&#125;]]></content>
      <categories>
        <category>Blog</category>
        <category>Ext</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Ext 4.2.4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ext3.4.x上传文件]]></title>
    <url>%2FBlog%2FExt%2FExt3.4.x%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用Ext 3.4.x版本实现上传.txt文件(文件内为id值),删除table_a对应记录 要求: 上传一个txt文件,根据文件内的id删除对应的记录。 需求分析: 使用 Ext 3.4.0 上传文件; Java 解析前端上传的文件,得到待删除 List&lt;Long&gt;; 使用 jdbctemplate 批量删除接口,完成删除操作。 js 页面(表单代码)页面出现连个按钮123456789101112131415161718192021222324252627282930313233&lt;style type=text/css&gt;.upload-icon &#123; background: url('../images/image_add.png') no-repeat 0 0 !important;&#125;.x-form-file-wrap &#123; position: relative; height: 22px;&#125;.x-form-file-wrap .x-form-file &#123; position: absolute; right: 0; -moz-opacity: 0; filter: alpha(opacity : 0); opacity: 0; z-index: 2; height: 22px;&#125;.x-form-file-wrap .x-form-file-btn &#123; position: absolute; right: 0; z-index: 1;&#125;.x-form-file-wrap .x-form-file-text &#123; position: absolute; left: 0; z-index: 3; color: #777;&#125;&lt;/style&gt; 文件类型不支持,需要引用fileuploadfield组件 css 文件内容 12345678910111213141516171819202122232425262728293031323334.upload-icon &#123; // 文件路径需要根据自己需要调整 // 这张为 ext 图片上传png /* https://docs.sencha.com/extjs/4.2.4/extjs-build/examples/shared/icons/fam/image_add.png */ background: url('../images/image_add.png') no-repeat 0 0 !important;&#125;.x-form-file-wrap &#123; position: relative; height: 22px;&#125;.x-form-file-wrap .x-form-file &#123; position: absolute; right: 0; -moz-opacity: 0; filter: alpha(opacity : 0); opacity: 0; z-index: 2; height: 22px;&#125;.x-form-file-wrap .x-form-file-btn &#123; position: absolute; right: 0; z-index: 1;&#125;.x-form-file-wrap .x-form-file-text &#123; position: absolute; left: 0; z-index: 3; color: #777;&#125; js 文件内容 以下 javascript 代码的样式可以自己修改,主要内容是 xtype : &#39;fileuploadfield&#39;、xtype:&#39;button&#39;。同时,提交方式也可以自行替换(Ajax等) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Ext.onReady(function () &#123; var fileForm = new Ext.FormPanel(&#123; title: '删除H码文件', frame: true, fileUpload: true, // required parameter collapsible: true, region: 'north', labelWidth: 40, height: 100, width: '100%', margins: '0 120', items: [&#123; layout: 'form', border: false, items: [&#123; items: &#123; labelWidth: 100, xtype: 'fieldset', labelAlign: 'right', autoHeight: true, items: [&#123; xtype: 'panel', layout: 'column', border: false, items: [&#123; layout: 'column', border: false, items: [&#123; layout: 'form', items: [&#123; xtype: 'fileuploadfield', // 需要引用 fileuploadfield.js文件 id: 'form-file', width: 200, emptyText: '请选择一个文件', fieldLabel: '删除H码文件', buttonText: '', name: 'hcodeFile', buttonCfg: &#123; iconCls: 'upload-icon' &#125; &#125;] &#125;, &#123; layout: 'form', items: [&#123; layout: 'form', xtype: 'button', text: '上传', width: 50, style:&#123; marginLeft: '20px' &#125;, handler: function () &#123; if (fileForm.getForm().isValid()) &#123; var filename = Ext.getCmp('form-file').getValue(); if (filename.indexOf('txt') &gt; -1) &#123; &#125; else &#123; msg('错误', '上传的文件不是txt文件类型,请重新选择!'); return; &#125; fileForm.getForm().submit(&#123; url: '../delete',// 请求 API 地址 waitMsg: '正在上传...', waitTitle: '请等待', success: function (form, action) &#123; msg('提示', action.result.msg); fileForm.getForm().reset(); // 刷新表格数据 // gridReload(); &#125;, failure: function (form, action) &#123; msg('错误', action.result.msg); fileForm.getForm().reset(); // 刷新表格数据 // gridReload(); &#125; &#125;); &#125; &#125; &#125;] &#125;] &#125;] &#125;] &#125; &#125;] &#125;] &#125;); // 提示框内容 var msg = function (title, msg) &#123; Ext.Msg.show(&#123; title: title, msg: msg, minWidth: 200, modal: true, icon: Ext.Msg.INFO, buttons: Ext.Msg.OK &#125;); &#125;;&#125;); 文件上传 Java 后端代码Controller —— 获取传递的参数,获取文件123456789101112131415161718import org.springframework.web.multipart.MultipartFile;@RequestMapping(value = "delet", method = RequestMethod.POST)public void deleteHcode(@RequestParam("hcodeFile") MultipartFile hcodeFile, HttpServletResponse response) throws IOException &#123; // 设置 response.setCharsetEncoding("utf-8") 时在当前代码中依然无效,所以改为设置 ContentType response.setContentType("text/html;charset=utf-8"); // Service 中的方法名 Map&lt;String, Object&gt; result = this.hcodeService.removeHcodeList(hcodeFile); // 返回 JSON 时,前端显示异常.需要改为 PrintWiter PrintWriter out = response.getWriter(); out.write("&#123;success:" + result.get("success") + ",msg:'" + result.get("msg") + "'&#125;"); out.flush(); out.close();&#125; Service —— 将 file 转为 list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import org.springframework.web.multipart.MultipartFile;public Map&lt;String, Object&gt; removeHcodeList(MultipartFile file) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); result.put("success", false); try &#123; // 获取上传 H码文件中的 hcode list List&lt;Long&gt; hcodeList = this.readHcodeFile(file); hcodeDao.removeHcodeList(hcodeList); result.put("success", true); result.put("msg", "删除成功"); &#125; catch (IllegalArgumentException fileException) &#123; result.put("msg", "删除失败,文件内容错误,请检查文件的准确性..."); &#125; catch (IOException e) &#123; result.put("msg", "删除失败,系统IO异常,请稍后重试"); &#125; catch (Exception e) &#123; result.put("msg", "删除失败,系统异常,请稍后重试"); e.printStackTrace(); &#125; return result;&#125;/** * * @Title: readHcodeFile * @Description: 读取文件的方式可以根据文件内容进行调整 * @param file(*.txt 文件) * @return * Set&lt;Long&gt; * @throws IOException */private List&lt;Long&gt; readHcodeFile(MultipartFile file) throws IOException &#123; InputStreamReader reader = null; BufferedReader br = null; try &#123; reader = new InputStreamReader(file.getInputStream(), "UTF-8"); br = new BufferedReader(reader); Set&lt;Long&gt; hcodeList = new HashSet&lt;Long&gt;(); String line = ""; while ((line = br.readLine()) != null &amp;&amp; line.length() &gt; 1) &#123; line = line.trim(); if (line == null) &#123; continue; &#125; hcodeList.add(Long.parseLong(line)); hcodeList.add(Long.parseLong(line)); &#125; return new ArrayList&lt;Long&gt;(hcodeList); &#125; catch (Exception e) &#123; throw new IllegalArgumentException("文件内容错误"); &#125; finally &#123; reader.close(); br.close(); &#125;&#125; 注： 当前方法读取的文件如下图所示 Repository 批量删除的方法 —— jdbctemplae 方式12345678910111213141516171819import org.springframework.jdbc.core.BatchPreparedStatementSetter;public void removeHcodeList(final List&lt;Long&gt; hcodeList) &#123; String sql = "delete from table_a t where t.hcode = ?"; // batchUpdate 为批量操作方法 this.getJdbcTemplate().batchUpdate(sql, new BatchPreparedStatementSetter() &#123; @Override public void setValues(PreparedStatement preparedstatement, int i) throws SQLException &#123; Long hcode = hcodeList.get(i); preparedstatement.setLong(1, hcode); &#125; @Override public int getBatchSize() &#123; return hcodeList.size(); &#125; &#125;);&#125; 常见异常 不支持文件上传 1org.springframework.web.bind.MissingServletRequestParameterException: Required MultipartFile parameter 'hcodeFile' is not present 方法: 在 applicationContext.xml 文件中实例化 bean,添加如下内容 1234&lt;!-- 支持文件上传 --&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>Ext</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Ext 3.4.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面跳转url传参的参数获取]]></title>
    <url>%2FBlog%2FHTML%2F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%ACurl%E4%BC%A0%E5%8F%82%E7%9A%84%E5%8F%82%E6%95%B0%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[页面跳转url传参的参数获取 #]]></content>
      <categories>
        <category>Blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图获取行政区边界坐标]]></title>
    <url>%2Fblog%2FHTML%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E8%8E%B7%E5%8F%96%E8%A1%8C%E6%94%BF%E5%8C%BA%E8%BE%B9%E7%95%8C%E5%9D%90%E6%A0%87%2F</url>
    <content type="text"><![CDATA[百度地图获取行政区边界坐标 输入行政区名称,获取相应的行政区边界坐标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no" /&gt; &lt;style type="text/css"&gt; body, html, #allmap &#123; width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: "微软雅黑"; &#125; &lt;/style&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=ed696RjHQMSM2nBkDDFFuXtV"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/2.1.1/jquery.js"&gt;&lt;/script&gt; &lt;title&gt;添加行政区划&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="getCity" style="margin: 1% 40%;"&gt; &lt;input type="text" placeholder="请输入行政区名字" /&gt; &lt;button id="city"&gt;获取行政区边界坐标&lt;/button&gt; &lt;/div&gt; &lt;div id="allmap"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type="text/javascript"&gt; // 百度地图API功能 var map = new BMap.Map("allmap"); map.centerAndZoom(new BMap.Point(116.403765, 39.914850), 5); map.enableScrollWheelZoom(); $('#city').click(function() &#123; var city = $(':input').val(); var bdary = new BMap.Boundary(); bdary.get(city, function(rs) &#123; //获取行政区域 map.clearOverlays(); //清除地图覆盖物 var count = rs.boundaries.length; //行政区域的点有多少个 if(count === 0) &#123; alert('未能获取当前输入行政区域'); return; &#125; var pointArray = []; for(var i = 0; i &lt; count; i++) &#123; var ply = new BMap.Polygon(rs.boundaries[i], &#123; strokeWeight: 2, strokeColor: "#ff0000" &#125;); //建立多边形覆盖物 var str = JSON.stringify(ply.ia); //将BMap获取的行政区边界经纬度转为字符串 spiltStr(str); map.addOverlay(ply); //添加覆盖物 pointArray = pointArray.concat(ply.getPath()); &#125; map.setViewport(pointArray); //调整视野 &#125;); &#125;); //字符串封装为json function spiltStr(city) &#123; //console.log(city+'---') var str = "121.34277300108,31.300726938605;121.34023490295,31.30656768649;121.34101430412,31.321852305581;121.34532986852,31.32373744307;121.34507562469,31.326325179418;121.34279680099,31.327430729214;121.33368722478,31.352486594706;121.32863323993,31.355946076452;121.3306342856,31.389518049891;121.32683032531,31.41448550211;121.33644426228,31.420048486776;121.33796679321,31.419826266008;121.33974283911,31.427986737928;121.33898864558,31.440913595385;121.33444416932,31.453434852669;121.32712127167,31.459698918395;121.32359337774,31.475180614573;121.31526712011,31.489321129362;121.31449534014,31.502646507446;121.29513460234,31.511763775428;121.28658896966,31.509453948404;121.27854782016,31.503306859672;121.25459705023,31.498569551283;121.21061795124,31.479894989687;121.20080623465,31.473441396056;121.19227370437,31.461329066124;121.18074389625,31.455132109974;121.17248676891,31.457784975575;121.15417124487,31.449591888376;121.15190698691,31.44485092269;121.16995564339,31.438369269356;121.15641170403,31.42808158186;121.16368200305,31.418036455773;121.15615209913,31.408916433233;121.15389894579,31.396855643986;121.14636752368,31.389519869487;121.1216241984,31.381207905131;121.126436312,31.375522857236;121.11327467502,31.372544843095;121.11504878311,31.358515688821;121.12543166,31.355738088985;121.12517943556,31.350576427542;121.13706169265,31.348468587078;121.13626008815,31.30993641992;121.14684967884,31.308793560918;121.15113791549,31.315474234933;121.16066357022,31.29917558545;121.16692386311,31.291073907869;121.16166696203,31.285625519425;121.16718195826,31.276446521814;121.17544355574,31.279163976083;121.18898716896,31.263877724792;121.20505391684,31.260119976477;121.21562156159,31.267376880475;121.27097267115,31.262577404004;121.27425078362,31.26044885246;121.29337239048,31.249760859417;121.29940623897,31.238478630296;121.32079145614,31.233202075819;121.34077824014,31.238325554883;121.34559319768,31.244083837124;121.3549768665,31.248019413486;121.36690797737,31.246319504389;121.37222869771,31.253136099939;121.3863911862,31.256071762754;121.3808205898,31.26662893588;121.36689179338,31.268484647818;121.36561439598,31.274102752167;121.35038733712,31.278662550346;121.34277300108,31.300726938605"; var points = []; $.each(str.split(";"), function(index, value) &#123; var point = &#123;&#125;; point.lng = value.split(',')[0]; point.lat = value.split(',')[1]; points.push(point); &#125;); var data = JSON.stringify(points); if(city == data) &#123; console.log('true'); &#125; //console.log(data); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>BMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 常用函数]]></title>
    <url>%2Fblog%2FSQL%2FSQL%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SQL 常用函数 SQL 常用函数及错误记录 获取sysdate前几个月时间 1234567-- 时间发生在 2019/1/29,查询(ORA-01839:指定月份的日期无效)-- 关键在于其他之前时间查询都没问题,就1月不行.有待解答select to_char(sysdate - interval '11' month, 'yyyy/mm') from dual /* 替代SQL */select to_char(sysdate - interval '11' month, 'yyyy/mm') from dual MySQL 与Oracle 的函数字符串转datetime MySQL 1234str_to_date('2020-01-14 15:00:00','%Y-%m-%d %H:%i:%s')-- exampleselect * from table_name where datetime_column between str_to_date('2020-01-13 15:00:00', '%Y-%m-%d %H:%i:%s') and str_to_date('2020-01-14 15:00:00', '%Y-%m-%d %H:%i:%s'); Oracle 1234to_date('2020-01-14 15:00:00','yyyy-mm-dd hh24:mi:ss')-- exampleselect * from table_name where datetime_column between to_date('2020-01-13 15:00:00','yyyy-mm-dd hh24:mi:ss') and to_date('2020-01-14 15:00:00','yyyy-mm-dd hh24:mi:ss'); datetime转为指定格式字符串 MySQL 1234date_format(datetime_column, '%Y-%m-%d %H') -- exmpleselect date_format(now(), '%Y-%m-%d %H') from dual; Oracle 1234to_char(datetime_column, 'yyyy-mm-dd hh24') -- exmpleselect date_format(now(), 'yyyy-mm-dd hh24') from dual; 注: %Y-%m-%d %H可以使用其他的格式类型,比如: %Y-%m-%d %H:%i:%s yyyy-mm-dd hh24 可以使用其他的格式类型,比如: yyyy-mm-dd hh24:mi:ss MySQL 字符串查找函数 find_in_set与regexp函数 123456select * from t_media_resource where 1 = 1 and if(not find_in_set('0', '1,2'), instr('1,2', media_type), 1 = 1) and if('综合|KOL推荐' is not null, media_classify regexp ('综合|KOL推荐'), 1 = 1) and if('大表哥' != '', media_name regexp ('大表哥'), 1 = 1); MySQL 拼接多个字符串 可以自定义拼接的字符,例如: | 1select concat_ws('|', column_1, column_2,...) MESSAGE from t_tablename;]]></content>
      <categories>
        <category>blog</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pom 文件常用配置]]></title>
    <url>%2Fblog%2FMaven%2FPom%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Pom 文件常用配置 pom.xml 常用的配置值properties123456&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;swagger.version&gt;2.7.0&lt;/swagger.version&gt;&lt;/properties&gt; plugin1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        <category>blog</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>pom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件详解]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SpringBoot自定义配置文件内容获取 SpringBoot配置文件内容获取 前提 添加以下依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 新建实体类获取application.yml/applicaiton.properties配置文件内容 @Component、@ConfigurationProperties 注解 application.yml配置文件 12345server: port: 9099user: name: markdown age: 10 实体类 12345678910111213import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix = "user")public class UserConfig implements Serializable &#123; private String name; private String age; /** 省略get/set 方法 */&#125; 测试类 测试是否能够正确获取配置文件内容 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class UserConfigTest &#123; @Autowired private UserConfig properties; @Test public void propertiesTest() &#123; System.out.println(properties.name() + "\t" + properties.getAge()); &#125;&#125; @Component、@Value 注解 application.yml/application.properties 文件内容不变 实体类 1234567891011121314import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Componentpublic class User2Config implements Serializable &#123; @Value(value = "$&#123;user.url&#125;") private String name; @Value(value = "$&#123;user.age&#125;") private String age; /** 省略get/set 方法 */&#125; 测试类 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class User2ConfigTest &#123; @Autowired private User2Config properties; @Test public void propertiesTest() &#123; System.out.println(properties.name() + "\t" + properties.getAge()); &#125;&#125; 创建实体类获取自定义(xx.properties)配置文件内容 注: 自定义配置文件最好还是使用.properties格式的文件,注解方式还不支持手动加载.yml格式文件的功能 @Configuration注解替换@Component注解,@PropertySource(&quot;classpath:xx.properties&quot;) 创建自定义配置文件my.properties 123# 高德——地理编码geo.url= http://restapi.amap.com/v3/geocode/geogeo.key= 11111 实体类 123456789101112@Configuration@PropertySource("classpath:geocode.properties")public class GeocodingProperties &#123; @Value(value = "$&#123;geo.url&#125;") private String url; @Value(value = "$&#123;geo.key&#125;") private String name; /*省略get/set方法*/&#125; 测试类 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class GeoCodingUtilTest &#123; @Autowired private GeocodingProperties properties; @Test public void propertiesTest() &#123; System.out.println(properties.getKey() + "\t" + properties.getUrl()); &#125;&#125; 配置文件可创建在resource中的文件夹下,使用相对根目录的文件夹即可(默认resources/为根目录) @Configuration、@PropertySource、@ConfigurationProperties 注: 使用@configuration与@ConfigurationProperties注解时,需要在启动类(Application.java)中增加@EnableConfigurationProperties(PhoneProperties.class)注解。 配置文件 配置文件路径resources/properties/phone.properties&quot;) 123phone.model= iPhone 8 Plusphone.price= 5266phone.system= iOS 12.2.x 启动类 123456789@SpringBootApplication@EnableConfigurationProperties(PhoneProperties.class)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 配置文件实体类 12345678910111213@Configuration@PropertySource(value = "classpath:properties/phone.properties")@ConfigurationProperties(prefix = "phone")public class PhoneProperties &#123; private String model; private Double price; private String system; /*省略get/set、toString()方法*/&#125; 测试类 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class PhonePropertiesTest &#123; @Autowired private PhoneProperties phoneProperties; @Test public void phonePropertiesTest() &#123; System.out.println(phoneProperties.toString()); &#125;&#125; 使用Environment方法获取配置文件的值 注解说明 @Component 将普通的pojo实例化到Spring容器中,相当于xml配置文件中的&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;; 泛指组件,当组件不好归类的的时候,可以使用这个组件。 @Configutration 用于定义配置类; @Configuration 中所有带@Bean注解的方法都会被动态代理,因此调用该方法返回的都是同一个实例。 @Component 与 @Component 区别详细介绍,Spring @Configuration 和 @Component区别 @PropertySource 通过注解的方式将properties配置文件中的值存储到Spring的Enviroment中,Environment接口提供方法去读取配置文件中的值,参数时properties文件中定义的key值。 @ConfigurationProperties 将同类的配置信息封装成实体类; 与@ConfigurationProperties一起使用时,需要在启动类增加@EnableConfigurationProperties注解并制定该实体类为配置类 或 使用@Component注解替代@Configuration注解。 @Value @value属性名,在属性名上添加该注解; 默认读取的配置文件是application.yml/application.properties,可在@RestController/@Controller中获取配置。 常见问题在非Controller 中无法获取配置类 或 注入相应注解 在工具类中,获取RestTemplate注解以及自定义配置文件为例 1234567891011121314151617181920212223242526// Point 1: 使用类注解`@Conponent`@Componentpublic class GeoCodingUtil &#123; @Autowired private RestTemplate restTemplate; @Autowired private GeocodingProperties properties; // Point 2: 将本类设置为属性 private static GeoCodingUtil geoCodingUtil; @PostConstruct private void init() &#123; geoCodingUtil = this; geoCodingUtil.properties = this.properties; geoCodingUtil.restTemplate = this.restTemplate; &#125; // 调用示例 public void getProperties()&#123; System.out.println(geoCodingUtil.properties.getUrl()); &#125;&#125; 注解说明 @PostConstruct 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行,并且只会被服务器调用一次，类似于Servlet的init()方法。被@PostContruct修饰的方法会在构造函数之后,init()方法之前运行。 @PostContruct 注释的init()方法,会在@Configuration配置之前运行。例如: 在执行预加载函数前,需要加载配置项则需要implements CommandLineRunner接口,若使用@PostContruct则只有在init()方法执行完才能获取@Configuration注解的自定义配置项。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell log]]></title>
    <url>%2Fblog%2FShell%2FShell%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Shell log 12345678910111213141516171819202122232425262728#!/bin/bashyou_name="runoob.com";echo "Hello : "$&#123;you_name&#125;;# 只读变量的值不能被改变myUrl="http://www.baidu.com";readonly myUrl;# myUrl="http://runoob.com";# 删除变量unset you_name;echo $&#123;you_name&#125;;# 获取字符串长度string="abcd";echo $&#123;#string&#125;;# 查找子字符串string="runoob is a great site";echo `expr index "$&#123;string&#125;" sg`;# 定义数组track=("min" "mid" "max");track[5]="io流";valuen=$&#123;track[5]&#125;;echo $&#123;valuen&#125;;echo $&#123;#track[@]&#125;;]]></content>
      <categories>
        <category>blog</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 获取 自定义时间格式时间、上周(周一、周日)、上个月(第一天、最后一天)]]></title>
    <url>%2Fblog%2FJava%2FJava%E6%97%A5%E6%9C%9F%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java 获取 自定义时间格式时间、上周(周一、周日)、上个月(第一天、最后一天) 获取时间格式工具类获取当前时间格式的时间1234567891011121314151617181920212223/** * @return String * @Title: yyyyMMddCurrentDay * @Description: 获取当前时间为 yyyyMMdd 格式的时间 */public static String yyyyMMddCurrentDay() &#123; return getCurrentDate("yyyyMMdd");&#125;/** * @param formatStr 格式化样式 例如： yyyyMMdd/yyyyMMddHH/yyyyMMddHHmm * @return String * @Title: getCurrentDay * @Description: 获取自定义格式的 Date 字符串 */public static String getCurrentDate(String formatStr) &#123; SimpleDateFormat format = new SimpleDateFormat(formatStr); Long today = System.currentTimeMillis(); return format.format(today);&#125; 当前日期多少天前的时间12345678910111213141516/** * * @Title: getBeforeDay * @Description: 获取自定义格式的 ; 多天前时间 * @param before ：多少天之前,例如：3 * @param formatStr:时间格式 * 例如： yyyyMMdd | yyyyMMddHH | yyyyMMddHHmm * @return * String */public static String getBeforeDay(int before, String formatStr) &#123; Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.DATE, -before); SimpleDateFormat format = new SimpleDateFormat(formatStr); return format.format(calendar.getTime());&#125; 获取当前三天前时间12345678/** * @return String * @Title: getBefore3Day * @Description: 获取 三天前的时间： 例如： 当前时间为：2018/11/07;.获取的三天前时间为 20181105 */public static String getBefore3Day() &#123; return getBeforeDay(3, "yyyyMMdd");&#125; 获取昨天的时间12345678/** * @return String * @Title: getBeforeDay * @Description: 昨天的日期 */public static String getBeforeDay() &#123; return getBeforeDay(1, "yyyyMMdd");&#125; 获取当前日期/指定日期的 上周(周一、周日) 时间 List12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * * @Title: getLastWeekMondayAndSunday * @Description: 获取指定日期的 上周:周一、周日 时间 * @param date 指定日期 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastWeekMondayAndSunday(Date date) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); // 获取指定日期的 上个星期周一、周日时间 if (date != null) &#123; calendar.setTime(date); &#125; // 一周七天 calendar.add(Calendar.DAY_OF_WEEK, -7); // 设置每周第一天为 周一 calendar.setFirstDayOfWeek(Calendar.MONDAY); calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); String monday = df.format(calendar.getTime()); list.add(monday); calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY); String sunday = df.format(calendar.getTime()); list.add(sunday); return list;&#125;/** * * @Title: getLastWeekMondayAndSunday * @Description: 获取当前时间,上周：周一、周日时间 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastWeekMondayAndSunday() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); // 一周七天 calendar.add(Calendar.DAY_OF_WEEK, -7); // 设置每周第一天为 周一 calendar.setFirstDayOfWeek(Calendar.MONDAY); calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY); String monday = df.format(calendar.getTime()); list.add(monday); calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY); String sunday = df.format(calendar.getTime()); list.add(sunday); return list;&#125; 获取当前/指定日期的 上个月(第一天、最后一天) 时间 List1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * * @Title: getLastMonthFirstDayAndLastDay * @Description: 获取当前时间,上个月:第一天、最后一天 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastMonthFirstDayAndLastDay() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); // 时间格式 SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); // 上个月的最后一天 calendar.set(Calendar.DAY_OF_MONTH, 0); String lastDay = df.format(calendar.getTime()); // 上个月的第一天 calendar.set(Calendar.DAY_OF_MONTH, 1); String firstDay = df.format(calendar.getTime()); list.add(firstDay); list.add(lastDay); return list;&#125;/** * * @Title: getLastMonthFirstDayAndLastDay * @Description: 获取指定日期,上个月:第一天、最后一天 * @param date * 指定日期 * @return * List&lt;String&gt; */public static List&lt;String&gt; getLastMonthFirstDayAndLastDay(Date date) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(2); // 时间格式 SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd"); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); // 上个月的最后一天 calendar.set(Calendar.DAY_OF_MONTH, 0); String lastDay = df.format(calendar.getTime()); // 上个月的第一天 calendar.set(Calendar.DAY_OF_MONTH, 1); String firstDay = df.format(calendar.getTime()); list.add(firstDay); list.add(lastDay); return list;&#125; 获取当前日期 0时0分0秒 时间123456789101112131415161718/** * * @Title: todayZero * @Description: 获取当前日期0时0分0秒时间 * @param formartStr(时间格式:yyyyMMdd等) * @return * String */public static String getTodayZero(String formartStr) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(new Date()); calendar.set(Calendar.HOUR_OF_DAY, 0); calendar.set(Calendar.MINUTE, 0); calendar.set(Calendar.SECOND, 0); SimpleDateFormat format = new SimpleDateFormat(formartStr); return format.format(calendar.getTime());&#125; 指定日期的N天之后的日期12345678910111213141516/** * * @Title: getAfterMonth * @Description: 获取N天之后日期 * @param number * @return * Long */public static Date getAfterDay(Date date, int number) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTime(date); calendar.add(Calendar.DATE, number); return calendar.getTime();&#125; 获取上个月月份123456789101112/** * @return String * @Title: getLastMonth * @Description: 上个月月份 */public static String getLastMonth() &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyyMM"); Calendar calendar = Calendar.getInstance(); calendar.add(Calendar.MONTH, -1); String month = sdf.format(calendar.getTime()); return month;&#125;]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Calendar</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历 Java 实体类属性及值]]></title>
    <url>%2Fblog%2FJava%2FJava%E9%81%8D%E5%8E%86%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[遍历 Java 实体类属性及值 遍历Java实体类属性及值 核心代码 12345678910111213141516171819202122232425262728293031323334353637import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(HcodeRepository.class);/** * * @Title: getPostParams * @Description: 将实体类clazz的属性转换为url参数 * @param clazz 参数实体类 * @return * String */private String getPostParams(Object clazz) &#123; Field[] fields = clazz.getClass().getDeclaredFields(); StringBuilder requestURL = new StringBuilder(); try &#123; boolean flag = true; String property, value; for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; // 允许访问私有变量 field.setAccessible(true); // 属性名 property = field.getName(); // 属性值 value = field.get(clazz).toString(); System.out.println(property+":"+value); &#125; &#125; catch (Exception e) &#123; logger.error("用户播放轨迹查询Qos 日志失败,参数为：" + clazz.toString()); &#125; return requestURL.toString();&#125; 示例 将查询参数封装为url12345678910111213141516171819202122232425262728293031323334353637383940414243import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(HcodeRepository.class);/** * * @Title: getPostParams * @Description: 将实体类clazz的属性转换为url参数 * @param clazz 参数实体类 * @return * String */private String getPostParams(Object clazz) &#123; // 遍历属性类、属性值 Field[] fields = clazz.getClass().getDeclaredFields(); StringBuilder requestURL = new StringBuilder(); try &#123; boolean flag = true; String property, value; for (int i = 0; i &lt; fields.length; i++) &#123; Field field = fields[i]; // 允许访问私有变量 field.setAccessible(true); // 属性名 property = field.getName(); // 属性值 value = field.get(clazz).toString(); String params = property + "=" + value; if (flag) &#123; requestURL.append(params); flag = false; &#125; else &#123; requestURL.append("&amp;" + params); &#125; &#125; &#125; catch (Exception e) &#123; logger.error("URL参数为：" + clazz.toString()); &#125; return requestURL.toString();&#125; 获取父类的属性及属性值注: 以下代码中使用Intellij IDEA并使用了lombok,可以使用get/set替代@Data注解;可以重写toString()方法替代@ToString注解;可以使用构造方法,替代@AllArgsConstructor注解。 TextMailDTO父类 1234567891011121314151617181920212223242526272829303132import lombok.AllArgsConstructor;import lombok.Data;import lombok.ToString;/** * @ClassName TextMailDTO * @Description &lt;br/&gt; 文本邮件实体类 * @Author Dew * @Date 2019/11/7 9:56 * @Version 1.0 **/@Data@ToString@AllArgsConstructorpublic class TextMailDTO &#123; /** * 主题 */ private String subject; /** * 文本内容 */ private String text; /** * 接收者邮箱 */ private String receiver;&#125; info子类 1234567891011121314151617181920212223import lombok.Data;/** * @ClassName Info * @Description &lt;br/&gt; 信息内容 * @Author Dew * @Date 2019/12/3 10:03 * @Version 1.0 **/@Datapublic class Info extends TextMailDTO &#123; private String description; public Info(String subject, String text, String receiver) &#123; super(subject, text, receiver); &#125; public Info(String subject, String text, String receiver, String description) &#123; super(subject, text, receiver); this.description = description; &#125;&#125; 实现获取父类属性及属性值的方法代码块 1234567891011121314151617181920212223242526272829303132333435363738/** * 获取父类的属性及属性值方法 */private String getAllFields(Object object) &#123; Class clazz = object.getClass(); List&lt;Field&gt; fieldList = new ArrayList&lt;&gt;(); while (clazz != null) &#123; Field[] fields = clazz.getDeclaredFields(); fieldList.addAll(new ArrayList&lt;&gt;(Arrays.asList(fields))); clazz = clazz.getSuperclass(); &#125; StringBuilder requestURL = new StringBuilder(); try &#123; boolean flag = true; String property, value; for (int i = 0; i &lt; fieldList.size(); i++) &#123; Field field = fieldList.get(i); // 允许访问私有变量 field.setAccessible(true); // 属性名 property = field.getName(); // 属性值 value = field.get(object).toString(); log.info(property + ":\t &#123;&#125;", value); &#125; &#125; catch (Exception e) &#123; log.error("参数为:\t&#123;&#125;", clazz.toString()); &#125; return requestURL.toString();&#125;]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Entity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 配置定时任务]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[SpringBoot 配置定时任务 SpringBoot 创建定时任务要求 * 已创建SpringBoot项目 * JDK 版本 1.8 及以上(非必须) * Maven 版本 3.2+ 添加依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 注: 进行 选中项目右键 &gt; Maven &gt; Update Project 操作后如果 JDK 版本被修改，在pom.xml中添加 1234567891011121314&lt;java.version&gt;1.8&lt;/java.version&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt; &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 启动类添加注解12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;//定时任务注解@EnableScheduling@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 创建定时任务实现类 定时任务 12345678910111213import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class SyncingTask &#123; private int count = 0; @Scheduled(cron = "*/6 * * * * ?") public void process() &#123; System.out.println("this is scheduler task runing" + (count++)); &#125;&#125; 定时任务 1234567891011121314151617import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class PrintTask &#123; private static final SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss"); @Scheduled(fixedRate = 6000) public void reportCurrentTime() &#123; System.out.println("现在时间：" + sdf.format(new Date())); &#125;&#125; 运行程序即可在控制台看到类似输出 12345678910112018-07-16 16:44:57.045 INFO 9352 --- [ restartedMain] s.a.ScheduledAnnotationBeanPostProcessor : No TaskScheduler/ScheduledExecutorService bean found for scheduled processing现在时间：16:44:572018-07-16 16:44:57.045 INFO 9352 --- [ restartedMain] com.learning.Application : Started Application in 0.49 seconds (JVM running for 0.931)this is scheduler task runing0现在时间：16:45:03this is scheduler task runing1现在时间：16:45:09this is scheduler task runing2现在时间：16:45:15this is scheduler task runing3现在时间：16:45:21 示例可参见官方地址 Scheduling Tasks @Scheduled注解说明 @Scheduled(fixedRate = 5000)：上次开始执行时间点之后5秒再执行 @Scheduled(fixedDelay = 5000)：上次执行完毕时间点之后5秒再执行 @Scheduled(initialDelay = 1000, fixedRate = 5000)：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次 @Scheduled(cron = &quot;*/6 * * * * *&quot;)：通过 cron 表达式定义规则]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>EnableScheduling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 基础]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SpringBoot 基础 参数校验统一用户认证(token | session)返回结果统一数据库访问多数据源前后端分离(前端页面展示)文件上传(本地 | 七牛云)富文本编辑器分页组件表格、表单]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 整合在线API(Swagger2)]]></title>
    <url>%2FSpringBoot%2FSwagger2%2FSpringBoot%E6%95%B4%E5%90%88Swagger2%2F</url>
    <content type="text"><![CDATA[SpringBoot 整合在线API(Swagger2) SpringBoot 整合 Swagger2创建SpringBoot 项目 第一步：创建SpringBoot项目，启动应用看是否能够启动 第二步：修改 pom.xml 为项目增加Swagger2支持 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 配置类 第三步：配置 Swagger2 配置类 12345678910111213141516171819202122232425262728293031@Configuration@EnableSwagger2public class Swagger2 extends WebMvcConfigurerAdapter &#123;//配置需要扫描的注解包路径private String basePackage="com.swagger.learing.controller";@Beanpublic Docket creatRestApi()&#123;return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.basePackage(this.basePackage)).paths(PathSelectors.any()).build();&#125;/*** 文档创建描述* @return*/private ApiInfo apiInfo()&#123;return new ApiInfoBuilder() .title("API文档标题") .description("xx相关API") .termsOfServiceUrl("http://127.0.0.1:xx/swagger-ui.html";) .contact(new Contact("name","url";,"email")) .version("版本号") .build(); &#125;&#125; 注解说明： @Configuration 声明类为配置类 @EnableSwagger2 用于开启Swagger注解 设置 Controller 层注解 第四步: 为UserVo(返回结果实体)类添加 Swagger2 注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.swagger.learing.domain;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(value = "用户模型实体类")public class UserVo &#123;@ApiModelProperty(value = "账户", required = true)private String account;@ApiModelProperty(value = "姓名", required = true)private String name;@ApiModelProperty(value = "昵称", required = true)private String nickName;public UserVo() &#123;&#125;public UserVo(String account, String name, String nickName) &#123; this.account = account; this.name = name; this.nickName = nickName;&#125;public String getAccount() &#123; return account;&#125;public void setAccount(String account) &#123; this.account = account;&#125;public String getName() &#123; return name;&#125;public void setName(String name) &#123; this.name = name;&#125;public String getNickName() &#123; return nickName;&#125;public void setNickName(String nickName) &#123; this.nickName = nickName;&#125;@Overridepublic String toString() &#123; return "UserVo&#123;" + "account='" + account + '\'' + ", name='" + name + '\'' + ", nickName='" + nickName + '\'' + '&#125;'; &#125;&#125; 第五步：为Controller添加 Swagger2 生成在线API文档注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.swagger.learing.controller;import com.alibaba.fastjson.JSON;import com.swagger.learing.domain.UserVo;import io.swagger.annotations.*;import org.springframework.web.bind.annotation.*;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.List;@RestController@RequestMapping("user")@Api("userController相关Api")@EnableSwagger2 // 设置可被swagger识别显示public class UserController &#123; /** * 获取用户list * @param userName * @param password * @return */ @ApiOperation("获取用户相关信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "userName", dataType = "String", required = true, value = "用户的姓名", defaultValue = "张飞"), @ApiImplicitParam(paramType = "query", name = "password", dataType = "String", required = true, value = "用户的密码", defaultValue = "wangga") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "/getUser", method = RequestMethod.POST) public List&lt;UserVo&gt; getUser(@RequestParam("userName") String userName, @RequestParam("password") String password) &#123; System.out.print("logger.in:getUser---------"); UserVo info = new UserVo("test01", "测试账户一", "士兵"); UserVo info2 = new UserVo("test02", "测试账户二", "将领"); UserVo info3 = new UserVo("test03", "测试账户三", "元帅"); List&lt;UserVo&gt; list = new ArrayList&lt;&gt;(); list.add(info); list.add(info2); list.add(info3); return list; &#125; /** * 查询用户详细信息 * @param id * @return */ @ApiOperation(value = "查询用户详细信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "queryUserInfo/&#123;id&#125;", method = RequestMethod.POST) public UserVo queryUserInfo(@PathVariable("id") Long id) &#123; UserVo info = new UserVo("test" + id, "00" + id, "鼠标" + id); return info; &#125; /** * 修改用户信息 * @param id * @param userVo * @return */ @ApiOperation(value = "修改用户信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1"), @ApiImplicitParam(paramType = "body", name = "User", dataType = "User", value = "修改的用户信息") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者跳转页面错误") &#125;) @RequestMapping(value = "modifyUserInfo", method = RequestMethod.POST) public String modifyUserInfo(@RequestParam("id") Long id, @RequestBody UserVo userVo) &#123; System.out.print("-----------modifyUserInfo:" + userVo.toString()); userVo.setAccount(++id + ""); return JSON.toJSONString(userVo); &#125; /** * 删除用户信息 * @param id * @return */ @ApiOperation(value = "删除用户信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径异常,或者跳转页面错误") &#125;) @RequestMapping(value = "delUserById/&#123;id&#125;", method = RequestMethod.DELETE) public String delUserById(@PathVariable(value = "id", required = true) Long id) &#123; System.err.print("-----del"); return "success"; &#125;&#125; 按上述步骤配置，项目启动后访问地址：http://localhost:8080/swagger-ui.html 页面访问效果如下：]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>Swagger2</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 多环境配置]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot 多环境配置 SpringBoot 多环境配置在开发环境、生产环境、测试环境中使用的配置也许有些不同，使用同一个配置文件时每次package前都需要修改成指定的环境配置。写该笔记已解决上述困，坑又被填平了一个….真好。 当前开发环境: SpringBoot适用场景: 多环境指定配置参数 划重点 命名规范application-xx.properties或appliction-xx.yml 使用当前配置构建的 jar 文件包含多环境的配置文件，可以通过java -jar xx.jar --spring.profiles.active=prod命令加载指定的配置文件 多配制文件(推荐)主文件 application.yml1234567891011spring: profiles: active: dev #指定应用`pacakage`时加载的文件名 mvc: static-path-pattern: /** view: prefix: /WEB-INF/jsp/ suffix: .jsp resources: static-locations: - classpath:/static,classpath:/templates,file:$&#123;web.upload-path&#125; 开发环境 application-dev.yml123456789101112server: port: 8090spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@192.168.203.158:1521/test username: test password: test jpa: hibernate: ddl-auto: validate show-sql: true 生产环境 application-prod.yml123456789101112server: port: 8090spring: datasource: driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@127.0.0.1:1521/test username: 数据库用户名 password: 数据库密码 jpa: hibernate: ddl-auto: validate show-sql: true 单配置文件 application-conlony.yml 1234567891011121314151617181920212223242526272829server: port: 1001spring: profiles: server-1eureka: instance: hostname: server-1 client: register-with-eureka: false fetch-registry: false service-url:# defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/$&#123;spring.application.name&#125; defaultZone: http://server-2:1002/eureka-server--- server: port: 1002 spring: profiles: server-2 eureka: instance: hostname: server-2 client: register-with-eureka: false fetch-registry: false service-url: # defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/$&#123;spring.application.name&#125; defaultZone: http://server-1:1001/eureka-server 启动 1使用`application-conlony.yml` 配置文件时,需要指定激活的配置项.(例如启动`server-1`,需运行`java -jar xx.jar --spring.profiles.active=server-1`)]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误]]></title>
    <url>%2Fblog%2FIntellij-IDEA%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AEweb.xml%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 背景 intellij IDEA 将应用打成war包可以正常运行及显示 eclipse 使用同样的tomcat | JDK运行正常 intellij IDEA 使用tomcat运行失败 错误信息 Intellij IDEA 控制台信息 12java.io.FileNotFoundException: Could not resolve XML resource [null] with public ID [-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN], system ID [http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd] and base URI [jar:file:/D:/Code/IDE-workspace/iptvView/target/WEB-INF/lib/standard-1.1.2.jar!/META-INF/c-1_0-rt.tld] to a known, local entity.at org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(LocalResolver.java:155) Chrome 浏览器页面信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP Status 500 - The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationtype Exception reportmessage The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationdescription The server encountered an internal error that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:55) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:277) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:75) org.apache.jasper.compiler.TagLibraryInfoImpl.generateTldResourcePath(TagLibraryInfoImpl.java:250) org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:125) org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:421) org.apache.jasper.compiler.Parser.parseDirective(Parser.java:479) org.apache.jasper.compiler.Parser.parseElements(Parser.java:1435) org.apache.jasper.compiler.Parser.parse(Parser.java:139) org.apache.jasper.compiler.ParserController.doParse(ParserController.java:227) org.apache.jasper.compiler.ParserController.parse(ParserController.java:100) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:201) org.apache.jasper.compiler.Compiler.compile(Compiler.java:358) org.apache.jasper.compiler.Compiler.compile(Compiler.java:338) org.apache.jasper.compiler.Compiler.compile(Compiler.java:325) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:580) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:363) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238) org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:263) org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827) javax.servlet.http.HttpServlet.service(HttpServlet.java:687) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)note The full stack trace of the root cause is available in the Apache Tomcat/8.0.52 logs.Apache Tomcat/8.0.52 项目 xxx/WEB-INF/lib 中不存在相关jar包 可以从 mavenrepository地址 中找到相应jar包,添加相关依赖到pom.xml文件中并重新编译，查看问题是否解决。 注： 通过添加缺失jar可以解决的就不用往下看了 项目依赖中存在相关依赖,依然无法正常显示页面 找到项目配置的 tomcat 下 xx\apache-tomcat-8.0.52\conf\context.xml文件 修改文件,添加如下内容 &lt;Context xmlBlockExternal=”false” &gt; 注： 只需要添加下划线中的 xmlBlockExternal=&quot;false&quot; 到 Context 标签即可 总结： 出现jsp页面显示错误,一般都是缺少 jar 包所致。可检查在tomcat或编译后的文件夹中是否能够找到相关依赖。 上述异常中缺失的jar有,然而本次并不是缺少jar的错误 1standard-1.1.2.jar、jstl-1.2.jar、jersey-server-1.9.jar、jstl-impl.jar 本博客无法解决疑问时,可简练相关关键字再搜索。 参考博客 新版Tomcat无法解析web.xml]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Intellij IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jquery 使用日志]]></title>
    <url>%2FBlog%2FJQuery%2FJquery%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Jquery 使用日志 Jquery 使用笔记文件加载后进行初始化123456789101112131415161718192021222324$(function () &#123; // 本月产品类型 monthTypes(); //本月产品订购次数排名 monthRanked(); //最近24小时订购次数 h24Rank(); //本月产品订购收入排名 mpincomeRank(); /** * 定时刷新数据 */ setInterval(function () &#123; setTimeout(monthTypes(), Math.random() * 100); setTimeout(monthRanked(), Math.random() * 100); setTimeout(h24Rank(), Math.random() * 100); setTimeout(mpincomeRank(), Math.random() * 100); &#125;, 1000 * 60 * 5);&#125;) list遍历 each 1234$.each(result, function(index, item) &#123; // result[index] = item console.log(index);&#125;); map 123result.map(function(item)&#123; console.log(item)&#125;) for 数字滚动插件 GitHub 地址 参照博客数字滚动显示插件地址 延迟加载*.js文件123456789101112131415&lt;script type="text/javascript"&gt; function downloadJSAtOnload() &#123; var element = document.createElement("script"); element.src = "*.js";//相对路径 document.body.appendChild(element); &#125; if (window.addEventListener) &#123; window.addEventListener("load", downloadJSAtOnload, false); &#125; else if (window.attachEvent) &#123; window.attachEvent("onload", downloadJSAtOnload); &#125; else &#123; window.onload = downloadJSAtOnload; &#125;&lt;/script&gt; 获取省市联动的中国行政区数据123456789101112131415161718192021222324252627282930313233$.getJSON('http://datavmap-public.oss-cn-hangzhou.aliyuncs.com/areas/csv/100000_province.json?order=asc&amp;_=1583116330692', function (result) &#123; const total = result.total; for (let i = 0; i &lt; total; i++) &#123; var provices = []; let name = result.rows[i].name; let adcode = result.rows[i].adcode; // console.info('name:\t' + name + 'adcode:\t' + adcode); $.getJSON('http://datavmap-public.oss-cn-hangzhou.aliyuncs.com/areas/csv/' + adcode + '_city.json?order=asc&amp;_=' + new Date().getTime(), function (city_result) &#123; var city = []; for (let j = 0; j &lt; city_result.total; j++) &#123; const value = city_result.rows[j]; // console.info(value) const city_name = value.name; city.push(&#123; value: city_name, label: city_name &#125;); &#125; provices.push(&#123; value: name, label: name, children: city &#125;) if(provices.length == total)&#123; console.info(JSON.stringify(provices)); &#125; &#125;); &#125;&#125;);]]></content>
      <categories>
        <category>Blog</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 使用记录]]></title>
    <url>%2FBlog%2FLinux%2FLinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux 使用记录 Linux 命令使用记录查看已经在使用的端口1netstat -nultp 检查端口是否被占用1netstat -anp|grep 7090 删除文件夹1rm -rf xx 删除文件1rm -f xx.log 查看 tomcat 相关的进程1ps -ef|grep tomcat 查看 tomcat 实时输出日志1tail -f /opt/tomcat/logs/catalina.out 查看内存信息参考地址 12345678[root@CentOS7 apache-tomcat-8.0.52]# cat /proc/cpuinfo | grep &apos;physical id&apos; | uniq -- cpu 个数physical id : 0physical id : 2[root@CentOS7 apache-tomcat-8.0.52]# cat /proc/cpuinfo | grep &apos;cpu cores&apos; | uniq -- cpu 核数cpu cores : 1[root@CentOS7 apache-tomcat-8.0.52]# cat /proc/cpuinfo | grep &apos;model name&apos; | uniq -- cpu 型号model name : Intel(R) Xeon(R) CPU E7-4809 v2 @ 1.90GHz[root@CentOS7 apache-tomcat-8.0.52]# 某个进程 CPU 占用1top -p 8104 Linux 下 Tomcat 开启查看 GC 信息 在 tomcat 的安装目录下,找到 bin/catalina.sh文件 修改前： 1JAVA_OPTS=&apos;-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m&apos; 修改后： 123456# create gc log monitor# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -Xloggc:/opt/apache-tomcat-8.0.52/logs/tomcat_gc.log'# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC' Linux 下查看 Tomcat 并发数1netstat -anp|grep 7090|grep ESTABLISHED -c 统计字符串出现次数1cat ./logs/error.iptv-meshing.log | grep &apos;parameter error&apos; | wc -l 统计端口TCP连接状态数量1netstat -anp|grep 7090 | grep ESTABLISHED -c TCP连接状态 导入MySQL数据库数据1234561. 连接mysqlmysql -u用户名 -p密码2. 连接你要导入的数据库的名字mysql&gt; use 数据库名3. 导入sql文件mysql&gt; source /tmp/database.sql;]]></content>
      <categories>
        <category>Blog</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impala 使用记录]]></title>
    <url>%2Fblog%2FImpala%2FImpala%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[impala 使用记录 impala 使用记录基本命令 进入 impala impala-shell 退出 impala exit; 展示所有表 show tables; 描述表结构 desc table_name; 注: 每个SQL语句结束时需要加 ‘;’,当数据量大时可以使用limit; 查询时尽量使用数据分区字段,可以有效减少查询时间时间 函数总结 form_unixtime 12-- 时间戳转为制定格式的字符串 select from_unixtime(unix_timestamp()-3*24*3600,'yyyyMMdd') daytime; |———-|| daytime ||———-|| 20200626 | unix_timestamp 12-- 获取当前时间戳select unix_timestamp() as time; |————|| time ||————|| 1593441066 |]]></content>
      <categories>
        <category>blog</category>
        <category>Impala</category>
      </categories>
      <tags>
        <tag>Impala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误]]></title>
    <url>%2Fblog%2FIntellij-IDEA%E8%BF%90%E8%A1%8Cweb%E9%A1%B9%E7%9B%AE%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 错误信息 Intellij IDEA 控制台信息12java.io.FileNotFoundException: Could not resolve XML resource [null] with public ID [-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN], system ID [http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd] and base URI [jar:file:/D:/Code/IDE-workspace/iptvView/target/WEB-INF/lib/standard-1.1.2.jar!/META-INF/c-1_0-rt.tld] to a known, local entity.at org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(LocalResolver.java:155) Chrome 浏览器页面信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP Status 500 - The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationtype Exception reportmessage The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationdescription The server encountered an internal error that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:55) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:277) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:75) org.apache.jasper.compiler.TagLibraryInfoImpl.generateTldResourcePath(TagLibraryInfoImpl.java:250) org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:125) org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:421) org.apache.jasper.compiler.Parser.parseDirective(Parser.java:479) org.apache.jasper.compiler.Parser.parseElements(Parser.java:1435) org.apache.jasper.compiler.Parser.parse(Parser.java:139) org.apache.jasper.compiler.ParserController.doParse(ParserController.java:227) org.apache.jasper.compiler.ParserController.parse(ParserController.java:100) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:201) org.apache.jasper.compiler.Compiler.compile(Compiler.java:358) org.apache.jasper.compiler.Compiler.compile(Compiler.java:338) org.apache.jasper.compiler.Compiler.compile(Compiler.java:325) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:580) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:363) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238) org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:263) org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827) javax.servlet.http.HttpServlet.service(HttpServlet.java:687) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)note The full stack trace of the root cause is available in the Apache Tomcat/8.0.52 logs.Apache Tomcat/8.0.52 项目 xxx/WEB-INF/lib 中不存在相关jar包; 可以从 mavenrepository地址 中找到相应jar包,添加相关依赖到pom.xml文件中并重新编译，查看问题是否解决。 注： 通过添加缺失jar可以解决的就不用往下看了 项目依赖中存在相关依赖,依然无法正常显示页面 找到项目配置的 tomcat 下 xx\apache-tomcat-8.0.52\conf\context.xml文件 修改文件,添加如下内容 &lt;Context xmlBlockExternal=”false” &gt; 注： 只需要添加下划线中的 xmlBlockExternal=&quot;false&quot; 到 Context 标签即可 总结: 出现jsp页面显示错误,一般都是缺少 jar 包所致。可检查在tomcat或编译后的文件夹中是否能够找到相关依赖。 上述异常中缺失的jar有,然而本次并不是缺少jar的错误 1standard-1.1.2.jar、jstl-1.2.jar、jersey-server-1.9.jar、jstl-impl.jar 本博客无法解决疑问时,可简练相关关键字再搜索。 参考博客 新版Tomcat无法解析web.xml]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Intellij IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误]]></title>
    <url>%2FBlog%2FIntellij%20IDEA%E8%BF%90%E8%A1%8Cweb%E9%A1%B9%E7%9B%AE%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 错误信息 Intellij IDEA 控制台信息12java.io.FileNotFoundException: Could not resolve XML resource [null] with public ID [-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN], system ID [http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd] and base URI [jar:file:/D:/Code/IDE-workspace/iptvView/target/WEB-INF/lib/standard-1.1.2.jar!/META-INF/c-1_0-rt.tld] to a known, local entity.at org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(LocalResolver.java:155) Chrome 浏览器页面信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP Status 500 - The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationtype Exception reportmessage The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationdescription The server encountered an internal error that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:55) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:277) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:75) org.apache.jasper.compiler.TagLibraryInfoImpl.generateTldResourcePath(TagLibraryInfoImpl.java:250) org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:125) org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:421) org.apache.jasper.compiler.Parser.parseDirective(Parser.java:479) org.apache.jasper.compiler.Parser.parseElements(Parser.java:1435) org.apache.jasper.compiler.Parser.parse(Parser.java:139) org.apache.jasper.compiler.ParserController.doParse(ParserController.java:227) org.apache.jasper.compiler.ParserController.parse(ParserController.java:100) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:201) org.apache.jasper.compiler.Compiler.compile(Compiler.java:358) org.apache.jasper.compiler.Compiler.compile(Compiler.java:338) org.apache.jasper.compiler.Compiler.compile(Compiler.java:325) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:580) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:363) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238) org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:263) org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827) javax.servlet.http.HttpServlet.service(HttpServlet.java:687) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)note The full stack trace of the root cause is available in the Apache Tomcat/8.0.52 logs.Apache Tomcat/8.0.52 项目 xxx/WEB-INF/lib 中不存在相关jar包; 可以从 mavenrepository地址 中找到相应jar包,添加相关依赖到pom.xml文件中并重新编译，查看问题是否解决。 注： 通过添加缺失jar可以解决的就不用往下看了 项目依赖中存在相关依赖,依然无法正常显示页面 找到项目配置的 tomcat 下 xx\apache-tomcat-8.0.52\conf\context.xml文件 修改文件,添加如下内容 &lt;Context xmlBlockExternal=”false” &gt; 注： 只需要添加下划线中的 xmlBlockExternal=&quot;false&quot; 到 Context 标签即可 总结: 出现jsp页面显示错误,一般都是缺少 jar 包所致。可检查在tomcat或编译后的文件夹中是否能够找到相关依赖。 上述异常中缺失的jar有,然而本次并不是缺少jar的错误 1standard-1.1.2.jar、jstl-1.2.jar、jersey-server-1.9.jar、jstl-impl.jar 本博客无法解决疑问时,可简练相关关键字再搜索。 参考博客 新版Tomcat无法解析web.xml]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Intellij IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle 使用笔记]]></title>
    <url>%2Fblog%2FOracle%2FOracle%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Oracle 使用笔记 Oracle使用笔记触发器 查询 t_device表是否有关联触发器,查 all_triggers 表得到 trigger_name select trigger_name from all_triggers where table_name = &#39;XX&#39;; 根据 trigger_name 查询出触发器详细信息 select text from all_source where type = &#39;TRIGGER&#39; AND name = &#39;TR_XXX&#39;; SQL查看CLOB类型内容SQL : select dbms_lob.substr(t.boundary_point) from t_station_boundary t; 说明 :dbms_lob.substr将大文本转换字符类型读出来 引用地址：Oracle的CLOB大数据字段类型 SQL按月份统计数据 引用地址: Oracle按月统计数据 Oracle时间转换为5分钟粒度1234select to_char(watchtime, 'yyyy/MM/dd hh24') || ':' || lpad(floor(to_char(watchtime, 'mi') / 5) * 5, 2, 0) watchtime, num from tm_num_watch order by watchtime asc; Oracle将一个字段拆分为两个字段在同行显示结果12345-- 获取行政区中心点坐标select station_name, regexp_substr(t.central_point, '[^,]+', 1, 1) lat, regexp_substr(t.central_point, '[^,]+', 1, 2) lng from t_station_boundary t; 时间计算查询1234567891011121314-- 相差月份查询select ceil((months_between(sysdate,'26-7月-2014'))) months from dual-- 天数查询select ceil((to_date('2018/5/24','yyyy/mm/dd') - to_date('2014/7/26','yyyy/mm/dd'))) days from dual -- 小时查询select ceil((to_date('2018/5/24', 'yyyy/mm/dd') - to_date('2014/7/26', 'yyyy/mm/dd'))*24) hoursfrom dual;-- 相差时间查询select * from ( (select ceil((months_between(sysdate, '26-7月-2014'))) as "相差月数" from dual)), (select ceil(sysdate - to_date('2014/7/26', 'yyyy/mm/dd')) as "相差天数" from dual), (select ceil((sysdate - to_date('2014/7/26', 'yyyy/mm/dd')) * 24) as "相差小时" from dual); 引用 [Oracle 两个时间相减][oracle_date_difference] [oracle_date_difference][https://blog.csdn.net/redarmy_chen/article/details/7351410] 注： Oracle 两个时间相减默认的是天数; 两个时间相减的差 * 24 是得到的是 小时(hours),依次类推得到的相应的时间差. 查询加上前缀12-- concat 函数select concat('_',USER_AD) USER_AD, longitude, latitude, grid_x, grid_y from t_advertising; Oracle使用merge into 索引 12345-- 创建索引create index meshing_user_ad_idx on T_MESHING(USER_AD);-- 删除索引drop index meshing_user_ad_idx; merge into语法 12345678910111213merge into t_meshing t1using (select :name user_ad, :longitude longitude, :latitude latitude, :gridX gridX, :gridY gridY from dual) t2on (t1.user_ad = t2.user_ad)when matched then update set t1.longitude=t2.longitude, t1.latitude = t2.latitude, t1.grid_x = t2.gridx, t1.grid_y = t2.gridywhen not matched then insert (t1.user_ad, t1.longitude, t1.latitude, t1.grid_x, t1.grid_y) values (t2.user_ad, t2.longitude, t2.latitude, t2.gridx, t2.gridy);]]></content>
      <categories>
        <category>blog</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 手动部署 war 包]]></title>
    <url>%2FBlog%2FLinux%2FLinux%E9%83%A8%E7%BD%B2war%E5%8C%85%2F</url>
    <content type="text"><![CDATA[执行 shutdown.sh 时关闭 Tomcat 与 进程, XShell 连接 安装 lrzsz yum -y install lrzsz 上传 Tomcat 到 linux 下载 Linux 版本 tomcat 进入官网Tomcat，下载历史版本选择则 Download 中的 Archives选项1https://archive.apache.org/dist/tomcat/tomcat-8/v8.0.52/bin/ 注： 文件夹为 bin 而不是 src 上传文件到 linux 当前目录下 123# rz 打开文件对话框(出现错误)# rz -be 能够正确上传 解压 tomcat 文件 1tar zxvf apache-tomcat-8.0.52.tar.gz 解压xx.tar文件 1tar xvf xx.tar 12进入../bin 目录，执行该命令chmod u+x *.sh 清空catalina.out日志文件 引用linux清空 catalina.out 日志 不需要重启 tomcat 123[root@CDH46 logs]# du -h catalina.out # 查看日志文件大小17M catalina.out [root@CDH46 logs]# &gt;catalina.out # 重定向清空文件 分配 JVM 内存空间，记录 GC 日志 1234567编辑 catalina.sh 文件,增加# create gc log monitor# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC -Xloggc:/opt/apache-tomcat-8.0.52/logs/tomcat_gc.log'# OS specific support. $var _must_ be set to either true or false.JAVA_OPTS='-Xms2048m -Xmx2048m -XX:PermSize=256m -XX:MaxNewSize=512m -XX:MaxPermSize=512m -XX:ParallelGCThreads=8 -XX:+UseConcMarkSweepGC' 指定tomcat依赖的 jdk 版本 找到 catalina.sh 与 setclasspath.sh 文件路径 123[root@cdh02 bin]# pwd/opt/iptvOrder/apache-tomcat-8.0.52/bin[root@cdh02 bin]# vi ./catalina.sh 在catalina.sh文件头部加入以下配置,指定 jdk 及 jre 路径 123# specify jdk versionJAVA_HOME=/usr/java/jdk1.8.0_101JRE_HOME=/usr/java/jdk1.8.0_101/jre shutdown 命令 kill 进程 修改catalina.sh文件 12345export JAVA_HOME=/usr/java/jdk1.8.0_101export JRE_HOME=/usr/java/jdk1.8.0_101/jreexport CATALINA_HOME=/opt/apache-tomcat-8.0.52export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH 需要注意JAVA_HOME、JRE_HOME、CATALINA_HOME路径配置 修改catalina.sh文件,设置记录CATALINA_PID(catalina.sh) 12345# Get standard environment variablesPRGDIR=`dirname "$PRG"`if [ -z "$CATALINA_PID" ]; then CATALINA_PID=$PRGDIR/CATALINA_PIDfi 注: 设置会在启动时候bin下新建一个CATALINA_PID文件 关闭时候从CATALINA_PID文件找到pid，kill。。。同时删除CATALINA_PID文件 修改shutdown.sh 12345# 这是 8.0.50 版本最后一行exec "$PRGDIR"/"$EXECUTABLE" stop -force "$e@"# 这是 8.5.38 版本最后一行exec "$PRGDIR"/"$EXECUTABLE" stop -force "$@"]]></content>
      <categories>
        <category>Blog</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>War</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 图片上传]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[SpringBoot 图片上传 SpringBoot 实现图片上传功能 SpringBoot 是为了简化Spring应用的创建、运行、测试、调试、部署等一系列问题而诞生的产物，自动装配的特性让我们可以更好的关注业务本事而不是外部的xml配置，我们只需遵循规范，引入相关的依赖就可以轻易搭建出一个web工程 说明 文件上传控件较多，本文以引用LayUI图片上传控件为例 页面上传插件使用Layui的图片上传控件，点击跳转 文件上传使用JQuery 的Ajax请求对应图片上传API，API返回包含图片路径格式的JSON数据 上传图片路径并非在项目文件夹中，需配置静态资源文件路径 配置文件上传控件 第一步：添加 Layui 的文件上传控件 将Layui库添加进项目的静态资源文件夹中，在src/main/resources/satic文件夹下创建layui文件夹存放Layui库等资源文件; HTML页面引用js及css文件，图片上传控件需要用到的资源有jquery.mini.js/jquery.js、layer.js、layui.js、layui.css。相关资源文件路径需要配置为项目具体引用路径或使用在线配置路径layui，详细内容可到layui官网查看。 初始化插件及样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script type="text/javascript"&gt;layui.use('upload',function() &#123; var $ = layui.jquery, upload = layui.upload; //普通图片上传 var uploadInst = upload.render(&#123; url : '../picture/uploadImg'//图片上传action路径配置 ,data : &#123; folder : 'hotel/' &#125;, before : function(obj) &#123; //预读本地文件示例，不支持ie8 obj.preview(function(index, file, result) &#123; $('#imgSrc').attr('src', result); //图片链接（base64）,显示缩略图 &#125;); &#125;, done : function(data) &#123; if (data.data.message == 'success') &#123; $('#hotelPicture').val( data.data.picUrl);//设置图片相对路径，表单提交时提交图片url return layer.msg('上传成功!') &#125; &#125;, error : function() &#123; //演示失败状态，并实现重传 var demoText = $('#demoText'); demoText .html('&lt;span style="color: #FF5722;"&gt;上传失败&lt;/span&gt; &lt;a class="layui-btn layui-btn-mini demo-reload"&gt;重试&lt;/a&gt;'); demoText.find('.demo-reload').on( 'click', function() &#123; uploadInst.upload(); &#125;); &#125; &#125;);&#125;);&lt;/script&gt;``` ## 修改配置文件 &gt; 第二步: 修改配置文件 ```properties# file write static resource pathweb.upload-path=F:/temp/springboot/spring.mvc.static-path-pattern=/**spring.resources.static-locations=classpath:/templates/,classpath:/META-INF/resources/,classpath:/resources/,\ classpath:/static/,classpath:/public/,file:$&#123;web.upload-path&#125; 注： web.upload-path 为图片保存路径，若使用linux系统部署需要将绝对路径替换为相对路径。 例如： API 接口 在SpringBoot 2.x版本中,页面静态资源配置无法实现。故采用配置文件的方式实现了，可以忽略本文中的页面显示配置或采用其他的方式。 第三步：文件上传API 1234567891011# 配置外部文件夹可通过HTTP访问图片,即配置静态资源路径spring: mvc: static-path-pattern: /** web: resources: static-locations: classpath:/static/,file:/temp/fileupload/image# 上传文件路径配置web: upload: image: /temp/fileupload/image 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Value("$&#123;web.upload.image&#125;")private String imageUrl;/** * @Title uploading &lt;br&gt; * @Description 上传背景图片&lt;br&gt; * @Param * * @param file * @param groupId * @return java.lang.Object */@PostMapping(value = "uploading")public Object uploading(MultipartFile file) &#123; // 图片保存到数据库的相对路径 String filePath = this.saveImages(file); // 根据实际情况修改返回值 Map&lt;String ,Object&gt; result = new HashMap&lt;&gt;(); s.put("filePath",filePath) return new ResponseDTO&lt;&gt;(Boolean.TRUE, result);&#125;/** * @Title saveImages &lt;br&gt; * @Description 保存视频文件 &lt;br&gt; * @Param * * @param image * @return java.lang.String 例如(image/20210122/20210122130940421.jpg) */private String saveImages(MultipartFile image) &#123; // 获取原文件名 String name = image.getOriginalFilename(); // 获取文件后缀 String subffix = name.substring(name.lastIndexOf(".") + 1, name.length()); // 日期文件夹 String nowFolder = new SimpleDateFormat("yyyyMMdd").format(new Date()); // 新的文件名以日期命名: String fileName = new SimpleDateFormat("yyyyMMddHHmmssSSS").format(new Date()) + "." + subffix; // 获取项目路径到webapp String filepath = imageUrl + "/" + nowFolder; File file = new File(filepath); // 文件路径不存在时,创建文件夹(可创建多层文件夹) if (!file.exists()) &#123; file.mkdirs(); &#125; // 实际保存路径 filepath += ("/" + fileName); // 保存文件 try &#123; image.transferTo(new File(filepath)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 保存数据库的相对路径 String relativePath = "image/" + nowFolder + "/" + fileName; return relativePath;&#125; 页面显示配置 第四步：图片在前端页面显示路径配置，不配置显示不了图片 12345678910111213141516171819202122232425262728import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;public class WebAppConfig extends WebMvcConfigurerAdapter &#123; @Value("$&#123;web.upload.image&#125;") private String imgPath;//application.properties中的文件资源位置 /** * 图片访问方法 */ @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if(imgPath.equals("") || imgPath.equals("$&#123;web.upload.image&#125;"))&#123; String imagesPath = WebAppConfig.class.getClassLoader().getResource("").getPath(); if(imagesPath.indexOf(".jar")&gt;0)&#123; imagesPath = imagesPath.substring(0, imagesPath.indexOf(".jar")); &#125;else if(imagesPath.indexOf("classes")&gt;0)&#123; imagesPath = "file:"+imagesPath.substring(0, imagesPath.indexOf("classes")); &#125; imagesPath = imagesPath.substring(0, imagesPath.lastIndexOf("/"))+"/images/"; imgPath = imagesPath; &#125; LoggerFactory.getLogger(WebAppConfig.class).info("imagesPath="+imgPath); registry.addResourceHandler("/images/**").addResourceLocations(imgPath); super.addResourceHandlers(registry); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>EnableScheduling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置单个 maven 项目 pom 依赖仓库地址]]></title>
    <url>%2FBlog%2FMaven%2FPom%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[配置单个 maven 项目 pom 依赖仓库地址 pom.xml 配置 maven 仓库地址，不需要改 setting pom.xml文件中加入repositories配置 12345678910111213141516171819202122232425&lt;!--配置maven阿里云仓库开始,不用去改maven的setting --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;local private nexus&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;local private nexus&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;&lt;!--配置maven阿里云结束 --&gt;]]></content>
      <categories>
        <category>Blog</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[impala 使用记录]]></title>
    <url>%2Fblog%2FJava%2FResultSet%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[impala 使用记录 大数据量查询,使用 ResultSet 出现 JVM 内存溢出 解决方案 修改前代码 1statement = connection.prepareStatement(sql); 修改后代码 1statement = connection.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); ResultSet枚举类 枚举值 数值 描述 FETCH_FORWARD 1000 FETCH_REVERSE 1001 FETCH_UNKNOWN 1002 TYPE_FORWARD_ONLY 1003 只能向前滚动(默认值) TYPE_SCROLL_INSENSITIVE 1004 TYPE_SCROLL_SENSITIVE 1005 CONCUR_READ_ONLY 1007 CONCUR_UPDATABLE 1008]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Memory Overflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除 List 中的重复数据]]></title>
    <url>%2Fblog%2FJava%2FJava%E5%AF%B9List%E7%9A%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[去除 List 中的重复数据 从List&lt;Object&gt; 中取相同列，转为另一个list123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142private static List&lt;UserUrl&gt; initData() &#123; List&lt;UserUrl&gt; list = new ArrayList&lt;&gt;(); UserUrl url = new UserUrl("20181107153500", "1", 120); list.add(url); url = new UserUrl("20181107153500", "2", 120); list.add(url); url = new UserUrl("20181107153500", "3", 156); list.add(url); url = new UserUrl("20181107153500", "4", 120); list.add(url); url = new UserUrl("20181107153500", "5", 156); list.add(url); url = new UserUrl("20181107153500", "6", 120); list.add(url); url = new UserUrl(); url = new UserUrl("20181107153000", "1", 120); list.add(url); url = new UserUrl("20181107153000", "2", 156); list.add(url); url = new UserUrl("20181107153000", "3", 120); list.add(url); url = new UserUrl("20181107153000", "4", 156); list.add(url); url = new UserUrl("20181107153000", "5", 156); list.add(url); url = new UserUrl("20181107153000", "6", 120); list.add(url); // 校验时间格式 String reg = "(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)"; List&lt;UserUrl&gt; result = new ArrayList&lt;&gt;(); for (UserUrl userUrl : list) &#123; String time = userUrl.getProcess_time(); // 更改时间格式 time = time.replaceAll(reg, "$2-$3 $4:$5"); userUrl.setProcess_time(time); result.add(userUrl); &#125; System.err.println(result); return result;&#125;/** * * @Title: queryActiveTrend * @Description: 活跃用户趋势 * 应用Map中键唯一的特性，将相同统计时间节点的数据合并为一个object * @param @return * @return Object * @throws */public static List&lt;ActiveTrendVO&gt; queryActiveTrend() &#123; // 1.得到查询结果:process_time,type,user_num List&lt;UserUrl&gt; list = initData();// userCountDao.queryActiveUserTrend(); System.out.println(list.toString()); // 2.将统计时间相同的数据封装为 ActiveTrendVO List&lt;ActiveTrendVO&gt; result = new ArrayList&lt;&gt;(); /** /// 嵌套的 list List&lt;ActiveUserVO&gt; nestvo = new ArrayList&lt;&gt;(); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); /// 第一条数据结果缺失,采用第二种方案 for (UserUrl userUrl : list) &#123; if (map.containsKey(userUrl.getProcess_time())) &#123; ActiveUserVO user = new ActiveUserVO(userUrl.getType(), userUrl.getUser_num()); nestvo.add(user); &#125; else &#123; ActiveTrendVO trend = new ActiveTrendVO(userUrl.getProcess_time(), nestvo); result.add(trend); nestvo.clear(); &#125; map.put(userUrl.getProcess_time(), userUrl.getProcess_time()); &#125; */ TreeMap&lt;String, List&lt;UserUrl&gt;&gt; tm = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; UserUrl userUrl = list.get(i); String time = userUrl.getProcess_time(); if (tm.containsKey(time)) &#123; ArrayList&lt;UserUrl&gt; tempList = (ArrayList&lt;UserUrl&gt;) tm.get(time); tempList.add(userUrl); &#125; else &#123; ArrayList&lt;UserUrl&gt; temlist = new ArrayList&lt;&gt;(); temlist.add(userUrl); tm.put(time, temlist); &#125; &#125; for (String key : tm.keySet()) &#123; List&lt;UserUrl&gt; userList = tm.get(key); ArrayList&lt;ActiveUserVO&gt; nestList = new ArrayList&lt;&gt;(); for (UserUrl userUrl : userList) &#123; ActiveUserVO active = new ActiveUserVO(userUrl.getType(), userUrl.getUser_num()); nestList.add(active); &#125; ActiveTrendVO trend = new ActiveTrendVO(key, nestList); result.add(trend); &#125; return result;&#125;public static void main(String[] args) &#123; List&lt;UserUrl&gt; list = initData(); // 2.将统计时间相同的数据封装为 ActiveTrendVO List&lt;ActiveTrendVO&gt; result = new ArrayList&lt;&gt;(); /// 嵌套的 list TreeMap&lt;String, List&lt;UserUrl&gt;&gt; tm = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; UserUrl userUrl = list.get(i); String time = userUrl.getProcess_time(); if (tm.containsKey(time)) &#123; ArrayList&lt;UserUrl&gt; tempList = (ArrayList&lt;UserUrl&gt;) tm.get(time); tempList.add(userUrl); &#125; else &#123; ArrayList&lt;UserUrl&gt; temlist = new ArrayList&lt;&gt;(); temlist.add(userUrl); tm.put(time, temlist); &#125; &#125; for (String key : tm.keySet()) &#123; List&lt;UserUrl&gt; userList = tm.get(key); ArrayList&lt;ActiveUserVO&gt; nestList = new ArrayList&lt;&gt;(); for (UserUrl userUrl : userList) &#123; ActiveUserVO active = new ActiveUserVO(userUrl.getType(), userUrl.getUser_num()); nestList.add(active); &#125; ActiveTrendVO trend = new ActiveTrendVO(key, nestList); result.add(trend); &#125; System.out.println(JSON.toJSONString(result));&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182private static List&lt;UserAccountStatus&gt; initData() &#123; List&lt;UserAccountStatus&gt; list = new ArrayList&lt;&gt;(); UserAccountStatus userAccountStatus = new UserAccountStatus(4822, "1", "四月"); list.add(userAccountStatus); userAccountStatus = new UserAccountStatus(352, "2", "四月"); list.add(userAccountStatus); UserAccountStatus userAccountStatus1 = new UserAccountStatus(44, "1", "五月"); list.add(userAccountStatus1); userAccountStatus1 = new UserAccountStatus(0, "2", "五月"); list.add(userAccountStatus1); UserAccountStatus userAccountStatus2 = new UserAccountStatus(406, "1", "六月"); list.add(userAccountStatus2); userAccountStatus2 = new UserAccountStatus(27, "2", "六月"); list.add(userAccountStatus2); UserAccountStatus userAccountStatus3 = new UserAccountStatus(15, "1", "七月"); list.add(userAccountStatus3); userAccountStatus3 = new UserAccountStatus(0, "2", "七月"); list.add(userAccountStatus3); UserAccountStatus userAccountStatus4 = new UserAccountStatus(0, "1", "八月"); list.add(userAccountStatus4); userAccountStatus4 = new UserAccountStatus(0, "2", "八月"); list.add(userAccountStatus4); UserAccountStatus userAccountStatus5 = new UserAccountStatus(1, "1", "九月"); list.add(userAccountStatus5); userAccountStatus5 = new UserAccountStatus(0, "2", "九月"); list.add(userAccountStatus5); UserAccountStatus userAccountStatus6 = new UserAccountStatus(511, "1", "十月"); list.add(userAccountStatus6); userAccountStatus6 = new UserAccountStatus(6, "2", "十月"); list.add(userAccountStatus6); UserAccountStatus userAccountStatus7 = new UserAccountStatus(15, "1", "十一月"); list.add(userAccountStatus7); userAccountStatus7 = new UserAccountStatus(1, "2", "十一月"); list.add(userAccountStatus7); System.err.println(JSON.toJSONString(list)); return list;&#125;/** * * @Title: queryOpenAccountGrowth * @Description: 开户用户历史增长情况 * @return * Object */public List&lt;ActiveTrendVO&gt; queryOpenAccountGrowth() &#123; // 1.查询数据库得按 月、类型 分组的用户统计数 List&lt;UserAccountStatus&gt; userAccountStatusList = initData(）//userCountDao.queryUserAccuontStatusGroupByMonth(); List&lt;ActiveTrendVO&gt; result = new ArrayList&lt;&gt;(); LinkedHashMap&lt;String, List&lt;UserAccountStatus&gt;&gt; linkMap = new LinkedHashMap&lt;&gt;(); // 2.使用 process_time 作为键 for (UserAccountStatus userAccountStatus : userAccountStatusList) &#123; String time = userAccountStatus.getProcessTime(); if (linkMap.containsKey(time)) &#123; ArrayList&lt;UserAccountStatus&gt; tempList = (ArrayList&lt;UserAccountStatus&gt;) linkMap.get(time); tempList.add(userAccountStatus); &#125; else &#123; ArrayList&lt;UserAccountStatus&gt; temList = new ArrayList&lt;&gt;(); temList.add(userAccountStatus); linkMap.put(time, temList); &#125; &#125; // 3.遍历key,转换实体类 for (String key : linkMap.keySet()) &#123; System.err.println("process_time:" + key); List&lt;UserAccountStatus&gt; list = linkMap.get(key); ArrayList&lt;ActiveUserVO&gt; nestList = new ArrayList&lt;&gt;(); for (UserAccountStatus userAccountStatus : list) &#123; ActiveUserVO activeUserVO = new ActiveUserVO(userAccountStatus.getType(), userAccountStatus.getUserNum()); nestList.add(activeUserVO); &#125; ActiveTrendVO trend = new ActiveTrendVO(key, nestList); result.add(trend); &#125; return result;&#125; 对连续数据取最后一条作为结果显示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private List&lt;UserUrl&gt; formartPlayTrackResult(List&lt;UserUrl&gt; list) &#123; // 数组下标 int index = 0; for (UserUrl userUrl : list) &#123; userUrl.setIndex(index++); &#125; List&lt;UserUrl&gt; result = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(list)); // set去重后恢复排序 UserUrl[] temp = new UserUrl[result.size()]; result.toArray(temp); Arrays.sort(temp, new Comparator&lt;UserUrl&gt;() &#123; @Override public int compare(UserUrl userUrl1, UserUrl userUrl2) &#123; return userUrl1.getIndex() - userUrl2.getIndex(); &#125; &#125;); result = Arrays.asList(temp); result = new ArrayList&lt;&gt;(result); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm"); try &#123; for (int i = 0; i &lt; result.size(); i++) &#123; for (int j = i + 1; j &lt; result.size();) &#123; // 第一条播放记录的播放时间,示例值： 2018-11-13 14:05 String firstTime = result.get(i).getProcess_time(); // 第二条播放记录播放时间 String secondTime = result.get(j).getProcess_time(); String firstName = result.get(i).getChannel_name(); String secondName = result.get(j).getChannel_name(); // 两条记录的时间间隔 long difference = sdf.parse(secondTime).getTime() - sdf.parse(firstTime).getTime(); difference = difference / (1000 * 60); // 时间间隔为5分钟 if (difference == 5 &amp;&amp; firstName.equals(secondName)) &#123; result.remove(i); &#125; else &#123; j++; &#125; &#125; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return result;&#125; Java数组转List 可实现方式 123456// 常见方式,不能addList list = Arrays.asList(strArray);// 数组转List后,支持增删改查的方式ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(strArray));list.add("1"); 通过集合工具类Collections.addAll()(推荐实现方式) 12345678910111213// 关键代码ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(strArray.length);Collections.addAll(arrayList,strArray);// 测试private void array2List()&#123; String[] strArray = new String[2]; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(strArray.length); Collections.addAll(arrayList,strArray); arrayList.add("1"); System.out.println(arrayList);&#125; 注:Collections.addAll()源码 123456public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) &#123; boolean result = false; for (T element : elements) result |= c.add(element);// result和c.add(element)按位或运算,然后赋值给result return result;&#125; Java8可通过stream流将3中基本类型数组转为List 如果JDK版本在1.8以上，可以使用流stream来将下列3种数组快速转为List，分别是int[]、long[]、double[]，其他数据类型比如short[]、byte[]、char[]，在JDK1.8中暂不支持。由于这只是一种常用方法的封装，不再纳入一种崭新的数组转List方式，暂时算是java流送给我们的常用工具方法吧。 转换代码示例 1234List&lt;Integer&gt; intList= Arrays.stream(new int[] &#123; 1, 2, 3, &#125;).boxed().collect(Collectors.toList());List&lt;Long&gt; longList= Arrays.stream(new long[] &#123; 1, 2, 3 &#125;).boxed().collect(Collectors.toList());List&lt;Double&gt; doubleList= Arrays.stream(new double[] &#123; 1, 2, 3 &#125;).boxed().collect(Collectors.toList()); 如果是String数组,可以使用Stream流转 12String[] arrays = &#123;"tom", "jack", "kate"&#125;;List&lt;String&gt; stringList= Stream.of(arrays).collect(Collectors.toList());]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误]]></title>
    <url>%2FBlog%2FIntellij%20IDEA%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AEweb.xml%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 Intellij IDEA 部署 Web 项目时,web.xml 无法正常解析导致 jsp 显示错误 背景 intellij IDEA 将应用打成war包可以正常运行及显示 eclipse 使用同样的tomcat | JDK运行正常 intellij IDEA 使用tomcat运行失败 错误信息 Intellij IDEA 控制台信息 12java.io.FileNotFoundException: Could not resolve XML resource [null] with public ID [-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN], system ID [http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd] and base URI [jar:file:/D:/Code/IDE-workspace/iptvView/target/WEB-INF/lib/standard-1.1.2.jar!/META-INF/c-1_0-rt.tld] to a known, local entity.at org.apache.tomcat.util.descriptor.LocalResolver.resolveEntity(LocalResolver.java:155) Chrome 浏览器页面信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546HTTP Status 500 - The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationtype Exception reportmessage The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this applicationdescription The server encountered an internal error that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: The absolute uri: http://java.sun.com/jsp/jstl/core cannot be resolved in either web.xml or the jar files deployed with this application org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:55) org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:277) org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:75) org.apache.jasper.compiler.TagLibraryInfoImpl.generateTldResourcePath(TagLibraryInfoImpl.java:250) org.apache.jasper.compiler.TagLibraryInfoImpl.&lt;init&gt;(TagLibraryInfoImpl.java:125) org.apache.jasper.compiler.Parser.parseTaglibDirective(Parser.java:421) org.apache.jasper.compiler.Parser.parseDirective(Parser.java:479) org.apache.jasper.compiler.Parser.parseElements(Parser.java:1435) org.apache.jasper.compiler.Parser.parse(Parser.java:139) org.apache.jasper.compiler.ParserController.doParse(ParserController.java:227) org.apache.jasper.compiler.ParserController.parse(ParserController.java:100) org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:201) org.apache.jasper.compiler.Compiler.compile(Compiler.java:358) org.apache.jasper.compiler.Compiler.compile(Compiler.java:338) org.apache.jasper.compiler.Compiler.compile(Compiler.java:325) org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:580) org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:363) org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396) org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238) org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:263) org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208) org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827) javax.servlet.http.HttpServlet.service(HttpServlet.java:687) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812) javax.servlet.http.HttpServlet.service(HttpServlet.java:790) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)note The full stack trace of the root cause is available in the Apache Tomcat/8.0.52 logs.Apache Tomcat/8.0.52 项目 xxx/WEB-INF/lib 中不存在相关jar包 可以从 mavenrepository地址 中找到相应jar包,添加相关依赖到pom.xml文件中并重新编译，查看问题是否解决。 注： 通过添加缺失jar可以解决的就不用往下看了 项目依赖中存在相关依赖,依然无法正常显示页面 找到项目配置的 tomcat 下 xx\apache-tomcat-8.0.52\conf\context.xml文件 修改文件,添加如下内容 &lt;Context xmlBlockExternal=”false” &gt; 注： 只需要添加下划线中的 xmlBlockExternal=&quot;false&quot; 到 Context 标签即可 总结： 出现jsp页面显示错误,一般都是缺少 jar 包所致。可检查在tomcat或编译后的文件夹中是否能够找到相关依赖。 上述异常中缺失的jar有,然而本次并不是缺少jar的错误 1standard-1.1.2.jar、jstl-1.2.jar、jersey-server-1.9.jar、jstl-impl.jar 本博客无法解决疑问时,可简练相关关键字再搜索。 参考博客 新版Tomcat无法解析web.xml]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Intellij IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doc 常用命令记录]]></title>
    <url>%2FBlog%2FDoc%2FDOS%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Doc 常用命令记录 DOC 命令 log删除文件夹及文件夹下所有文件和文件夹1rd /s /q folder 删除指定后缀的文件1del /a /f /q file path\*.xx 查看当前文件加下所有文件夹及文件列表1dir 清空 DOS 界面1cls 文件夹 进入某个文件夹内 1cd xxx/xxx/folder 返回上级目录 1cd ../ 有多少层级目录就写多少个../便返回相应的某一层 统计字符串出现次数1cat ./logs/error.iptv-meshing.log | grep &apos;parameter error&apos; | wc -l 统计端口TCP连接状态数量1netstat -anp|grep 7090 | grep ESTABLISHED -c TCP连接状态 生成文件夹的目录结构 查看命令 tree /? 1234567D:\&gt;tree /?以图形显示驱动器或路径的文件夹结构。 TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 生成当前目录中指定文件夹下的目录树,列出文件夹中文件的名称 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 生成文件命令D:\Code\sts-work-workspace\iptvMeshing&gt;tree ./src /f &gt;iptv_meshing.txt# 生成文件的内容卷 Development 的文件夹 PATH 列表卷序列号为 8C4A-90ABD:\SRC├─main│ ├─java│ │ └─com│ │ └─sanss│ │ │ Application.java│ │ │ │ │ ├─config│ │ │ GeocodingProperties.java│ │ │ HikariDataSourceConfig.java│ │ │ RestTemplateConfig.java│ │ │ │ │ ├─controller│ │ │ AdUserController.java│ │ │ Decetion.java│ │ │ OrderController.java│ │ │ │ │ ├─entity│ │ │ │ AdUserGridDO.java│ │ │ │ OrderDO.java│ │ │ │ │ │ │ └─dto│ │ │ AdUserDTO.java│ │ │ GDPoint.java│ │ │ │ │ ├─repository│ │ │ AdUserRepository.java│ │ │ OrderRepository.java│ │ │ │ │ ├─service│ │ │ │ GeocodeService.java│ │ │ │ OrderService.java│ │ │ │ SynchronizeInformationService.java│ │ │ │ │ │ │ └─impl│ │ │ GeocodeServiceImpl.java│ │ │ OrderServiceImpl.java│ │ │ SynchronizeInformationServiceImpl.java│ │ │ │ │ └─util│ │ │ ArrayUtil.java│ │ │ HttpServletRequestReader.java│ │ │ │ │ └─geocode│ │ GeoCodingUtil.java│ │ │ ├─resources│ │ application.yml│ │ geocode.properties│ │ logback-spring.xml│ │ │ └─webapp└─test └─java └─com └─sanss │ ApplicationTest.java │ ├─config │ HikariDataSourceConfigTest.java │ └─util GeoCodingUtilTest.java]]></content>
      <categories>
        <category>Blog</category>
        <category>Doc</category>
      </categories>
      <tags>
        <tag>Doc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ext 4.0 使用笔记]]></title>
    <url>%2Fblog%2FExt%204.0%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Ext 4.0 使用笔记 Ext 4.0 使用笔记获取Grid 当前选中行数据 获取行数据 123var record = Ext.getCmp('now_alarm').getSelectionModel().getSelection();//获取选中单行的某列值 var deviceName = record[0].data.DEVICE_NAME; 列宽自动适应12forceFit:true,//注意不要用autoFill:true;那样设置当GridPanel的大小变化(比如resize了它)时不会自动调整column的宽度scrollOffset:0//不加这个的话,会在grid的最右边有个空白,留作滚动条的位置 load store12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 //查询参数 var getParams = function() &#123; return &#123; sheetIds : Ext.getCmp('sheetId').getValue(), station : Ext.getCmp('station').getValue(), maintain : Ext.getCmp('maintainer').getValue(), startTime : Ext.util.Format.date(Ext.getCmp('startTime').getValue(),'Y-m-d'), //status : state,// Ext.getCmp('status').getValue(), endTime : Ext.util.Format.date(Ext.getCmp('endTime').getValue(),'Y-m-d'), worksheettype : Ext.getCmp('worksheetType').getValue() &#125; &#125; // 条件查询 function reportLoad()&#123; var params = getParams();// console.log(params); for ( var key in params) &#123; if (params[key] == null || params[key] == "") &#123; delete params[key]; continue; &#125; &#125; reportStore.setProxy(&#123; type : 'ajax', url: '../centerSheet/getWorkSheet', extraParams : params, reader:&#123; type:'json', root:'records', totalProperty:'totalCount' &#125; &#125;); switch (state) &#123; case 0: Ext.getCmp('no_confirm').getStore().load(); break; case 1: Ext.getCmp('no_repair').getStore().load(); break; case 2: Ext.getCmp('no_statements').getStore().load(); break; case 4: Ext.getCmp('statements').getStore().load(); break; default: break; &#125; &#125; 创建window1234567891011121314151617181920212223242526272829303132Ext.create('Ext.window.Window', &#123; title : '问题单信息录入', labelWidth : 75, // label settings here cascade unless overridden url : 'save-form.php', frame : true, bodyStyle : 'padding:5px 5px 0', width : document.body.clientWidth * 0.58, renderTo : Ext.getBody(), layout : 'column', // arrange fieldsets side by side xtype : 'form', defaults : &#123; bodyPadding : 4 &#125;, items : [ &#123; xtype : 'fieldset', columnWidth : 1, title : '告警基本信息', collapsible : true, defaultType : 'textfield', defaults : &#123; anchor : '100%' &#125;, layout : 'anchor', items : [ &#123; fieldLabel : 'Field 1', name : 'field1' &#125;, &#123; fieldLabel : 'Field 2', name : 'field2' &#125; ] &#125; ]&#125;).show(); 获取选中行displayField的值1Ext.getCmp('distributeUserName').getRawValue(), 获取点击行数据Ext.getCmp(&#39;now_alarm&#39;).getStore().getAt(index).data Store load 第一种 12345678910historyStore.setProxy(&#123; type : 'ajax', url : newUrl, reader:&#123; type:"json", root:'root', totalProperty:'totalCount' &#125; &#125;);Ext.getCmp('history_alarm').getStore().load(); 第二种 123// now_alarm : GridPanelvar gridStore = Ext.getCmp('now_alarm').getStore();gridStore.reload(gridStore.lastOptions); store加载传参 proxy 设置 extraParams 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748xtype : 'combo',fieldLabel : '维保人员',id : 'sendOperUser',name : 'sendOperUser',style:&#123; margin : '10px 10px 10px 50px'&#125;,resizable : false,store : Ext.create('Ext.data.Store',&#123; autoLoad : true, fields : [ &#123; name : 'id', mapping :'ID', &#125;, &#123; name : 'name', mapping :'NAME', &#125;], proxy : &#123; type : "ajax", url : '../alarm/getMaintainer', extraParams : &#123; error_sheet : errorSheetId, company : company &#125;, reader : &#123; type : "json" &#125; &#125;, listeners: &#123; load: function(store, records, successful, eOpts)&#123; for(k in records)&#123; if (records[k].data) &#123; // console.log(records[k].data); if (distribute_account == records[k].data.name) &#123; Ext.getCmp('sendOperUser').setValue(records[k].data.id); &#125; &#125; &#125; &#125; &#125; &#125;), valueField : 'id',displayField : 'name',mode : 'local',triggerAction : 'all',allowBlank : false,blankText : '必选项',maxHeight : 150 拼接URL 1234567proxy : &#123; type : "ajax", url : '../alarm/getMaintainer?error_sheet='+errorSheetId+'&amp;company='+company, reader : &#123; type : "json" &#125;&#125;, 监听 tabpanel 事件12345listeners:&#123; tabchange :function(tabPanel,tab)&#123; &#125; &#125;, 解析store返回自定义参数值12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 查询条件 封装var getParams = function() &#123; return &#123; sheetIds : Ext.getCmp('sheetId').getValue(), station : Ext.getCmp('station').getValue(), maintain : Ext.getCmp('maintainer').getValue(), startTime : Ext.util.Format.date(Ext.getCmp('startTime').getValue(),'Y-m-d'), status : state,// Ext.getCmp('status').getValue(), endTime : Ext.util.Format.date(Ext.getCmp('endTime').getValue(),'Y-m-d'), worksheettype : Ext.getCmp('worksheetType').getValue() &#125; &#125; // 条件查询 function reportLoad()&#123; // 移除为空的查询条件 var params = getParams(); for ( var key in params) &#123; if (params[key] == null || params[key] == "") &#123; delete params[key]; continue; &#125; &#125; // 添加自定义返回参数`no_coinfirm` reportStore.setProxy(&#123; type : 'ajax', url: '../centerSheet/getWorkSheet', extraParams : params, reader:&#123; type:'json', root:'records', totalProperty:'totalCount', no_coinfirm:'no_confirm', no_repair:'no_repair', no_statements:'no_statements', statements:'statements' &#125; &#125;); // 加载对应的 tabpanel 的数据、更新titel reportStore.load(&#123; scope: this, callback: function(records, operation, success) &#123; var reader = reportStore.getProxy().getReader(); Ext.getCmp('no_confirm').setTitle(tabpanel1 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.no_confirm); Ext.getCmp('no_repair').setTitle(tabpanel2 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.no_repair); Ext.getCmp('no_statements').setTitle(tabpanel3 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.no_statements); Ext.getCmp('statements').setTitle(tabpanel3 + '&amp;nbsp;&amp;nbsp;'+reader.jsonData.statements); &#125; &#125;); &#125; fieldset 可折叠控制`collapsible : true` 监听表格数据双击事件12345678910111213listeners: &#123; // 监听双击事件 itemdblclick: function (dataView, record, item, index, e) &#123; // 当前数据行数据 var data = record.data; console.log(data); //传参 var user_id = data.id; var process_time = Ext.util.Format.date(data.process_time, 'YmdHi'); queryQosLog(user_id, process_time); &#125; &#125; Ext window遮罩效果实现12在Ext.window.Window 中添加属性 modal: true, 设置隔行变色、同时指定行背景色123456789101112131415161718192021222324252627/* CSS */// 隔行背景色.x-grid-record-ou td &#123; background-color: #cacaca;&#125;/* 设置背景色 */.x-grid-record-fenghuo td&#123; background-color: #ff3333;&#125;/* js */forceFit: true,//列宽自适应viewConfig:&#123; stripeRows:false,//开启隔行变色,默认false但是遇到的是没用。所以设置了false值 getRowClass: function (record, rowIndex, rowParams, stroe) &#123; if (record.get('type').indexOf('错误') != -1) &#123; return 'x-grid-record-fenghuo td';// 指定的背景色class &#125; else &#123; if (rowIndex % 2 == 0) &#123; return 'x-grid-record-ou'; // 隔行变色的class &#125; else &#123; return ''; &#125; &#125; &#125;&#125; 表单重置12// 需要获取的 region_form 的 xtype: 'form';formpanel 设置则无效Ext.getCmp('region_form').getForm().reset(); Ext表格数据翻页传递参数1234567891011121314151617181920212223// 表单查询参数封装function form_parameter() &#123; // 时间粒度 var time_granularity = Ext.getCmp('time_granularity').getChecked()[0].inputValue; // 开始时间 var start_time = Ext.getCmp('start_time').getValue(); start_time = dateFormat(start_time); // 结束时间 var end_time = Ext.getCmp('end_time').getValue(); end_time = dateFormat(end_time); return &#123; time_granularity: time_granularity, start_time: start_time, end_time: end_time &#125;&#125;// 加载分页数据时的参数传递store.on("beforeload", function () &#123; let params = form_parameter(); Ext.apply(speechQualityStore.proxy.extraParams, params);&#125;)]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Web Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse | STS(Spring Tool Suite)开发工具配置]]></title>
    <url>%2Fblog%2FEclipse%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Eclipse | STS(Spring Tool Suite)开发工具配置 开发环境中Eclipse、STS(Spring Tool Suite)通用配置 Java实体类，重写toString().生成JSON字符串配置 Eclipse 快捷键 Alt + S 选择 Generate toString，重写toString()方法 添加自定义的format格式，选择Edit 格式化文本内容 1&#123;"$&#123;member.name()&#125;":"$&#123;member.value&#125;", "$&#123;otherMembers&#125;"&#125; 新的template，输入Name和Pattern 点击OK，完成创建。 回到第一个页面，默认选中刚刚创建的JSONString，点击Generate完成创建 创建完成后效果]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目集成 FineBI 应用系统]]></title>
    <url>%2Fblog%2FWeb-Plugins%2FFineBI%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[FineBI后台Java集成报表页面 项目集成 FineBI 应用系统 概述 安装 FineBI 客户端,或已有 FineBI 服务端; 使用FineBI Web 页面集成; 前提 安装FIneBi 找到..\FineBI5.0\webapps\webroot 文件夹，复制文件至..\apache-tomcat-9.0.8\webapps\目录下; 复制JDK 1.8 或以上环境中的 D:\Program Files\Java\jdk1.8.0_161\lib\tools.jar文件到 D:\Environment\Tomcat\apache-tomcat-9.0.8\lib 文件夹下; 在dos窗口执行catalina.bat run命令启动tomcat 或执行start.sh; 访问http://127.0.0.1:8080/webroot/decision 出现FineBI登录配置页面. 如有变动或启动失败,可以查看官网地址Tomcat 服务器部署 web 页面集成 实现思路 配置登录FineBI系统信息,创建配置文件或设置配置文件到主配置文件中; 创建登录跳转链接 &gt;&gt; 实现通过访问项目地址 &gt;&gt; 返回登录FineBI登录地址,携带登录信息 &gt;&gt; 重定向至FineBI系统 完成集成 配置文件 finebi.properties配置文件内容 12345678910finebi.path= webroot/decision/login/cross/domainfinebi.redirect= webroot/decision#-------localhost-------#finebi.ip=xxxx#finebi.port=xxxx#--------online---------finebi.ip=xxxxfinebi.port=xxxxx finebi.path: 登录FineBI接口URL finebi.redirect: 登录成功后重定向URL finebi.ip: FineBI 服务部署地址 finebi.port: FineBI 服务部署端口 实体类获取配置文件内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.io.BufferedInputStream;import java.io.InputStream;import java.util.Properties;/** * * @ClassName: FineBIProperties * @Description: FineBI 系统相关配置 * @date 2018/12/05 */public class FineBIProperties &#123; private static String ip; private static String port; private static String path; private static String redirect; static &#123; // 读取配置文件 Properties property = new Properties(); try &#123; ClassLoader cl = Thread.currentThread().getContextClassLoader(); InputStream inputStream = new BufferedInputStream(cl.getResourceAsStream("finebi.properties")); property.load(inputStream); inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; ip = property.getProperty("finebi.ip"); port = property.getProperty("finebi.port"); path = property.getProperty("finebi.path"); redirect = property.getProperty("finebi.redirect"); &#125; /** * 拼接登录FineBI 系统的登录URL **/ public String loginFineBI() &#123; String finbiURL = "http://" + ip + ":" + port + "/" + path + "?"; return finbiURL; &#125; /** * 拼接登陆后重定向的URL **/ public String redirectURL() &#123; String finbiURL = "http://" + ip + ":" + port + "/" + redirect; return finbiURL; &#125;&#125; 访问API返回登录FinBI系统登录URL12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.HashMap;import java.util.Map;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.sanss.finebi.FineBIProperties;import com.sanss.user.entity.User;/** * * @ClassName: FineBIController * @Description: 接入 FineBI 相关 * @date 2018/12/05 */@Controller@RequestMapping(value = "finebi")public class FineBIController &#123; /** * @return Object * @Title: getLoginUrl * @Description: 获取登录 FineBI 系统的路径,Path */ @ResponseBody @RequestMapping(value = "getLoginPath") public Object getLoginUrl(HttpServletRequest request) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(); FineBIProperties properties = new FineBIProperties(); // 获取登录用户信息 User user = new User("张三","1234"); String userName = user.getUser_name(); String password = user.getPasswd(); // 获取登录 FineBI 的地址 String url = properties.loginFineBI(); // 拼接 FineBI 登录 url StringBuffer str = new StringBuffer(url); str.append( "fine_username=" + userName + "&amp;fine_password=" + password + "&amp;validity=-1" + "&amp;&amp;callback=loginFineBI"); result.put("url", str); result.put("redirect", properties.redirectURL()); return result; &#125;&#125; 登录的用户信息获取方式有可能不一样,需要根据自身现状进行调整。 FineBI跳转页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;FineBI 页面&lt;/title&gt;&lt;script type="text/javascript" src="jquery/jquery.min.js"&gt;&lt;/script&gt;&lt;style type="text/css"&gt;html &#123; overflow: hidden;&#125;html, body, iframe &#123; width: 100%; height: 100%; margin: 0px; padding: 0px;&#125;iframe &#123; border: none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe scrolling="no"&gt;&lt;/iframe&gt; &lt;script type="text/javascript"&gt; /** 获取项目名称 */ function getProjectName()&#123; var pathName = window.document.location.pathname; var projectName = pathName.substring(0,pathName.substr(1).indexOf('/')+1); return projectName; &#125; //../js/util.js中定义的获取项目名称的方法 var projectName = getProjectName(); $(function() &#123; $.getJSON(projectName + '/finebi/getLoginPath.do', function(data) &#123; $.ajax(&#123; type : 'GET', url : data.url, dataType : 'jsonp', success : function(token) &#123; loginFineBI(data, token); &#125; &#125;); &#125;); &#125;) var loginFineBI = function(data, token) &#123; $('iframe').attr("src", data.redirect); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 其他的集成方式注：以上方式实现登录需要同步项目连接数据库用户登录相关表与FineBI系统的用户信息表才能实现登录,也可以采用Token或其他方式实现登录,有关其他的详细步骤可以查看官网Web页面集成简单例子]]></content>
      <categories>
        <category>blog</category>
        <category>Web Plugins</category>
      </categories>
      <tags>
        <tag>FineBI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML log]]></title>
    <url>%2Fblog%2FHTML%2FHTML%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[css设置奇偶行数、跳转、border渐变色、xml转为json、js获取查询参数 HTML 应用记录css获取奇偶行数 奇数行：td:nth-child(odd){} 偶数行：td:nth-child(even){} css选择器：参考地址 跳转html页面1parent.window.location.href = "../main/index.do"; border设置渐变色123456.customborder &#123; border-image: -webkit-linear-gradient(#F80, #2ED) 20 20; border-image: -moz-linear-gradient(#F80, #2ED) 20 20; border-image: -o-linear-gradient(#F80, #2ED) 20 20; border-image: linear-gradient(#F80, #2ED) 20 20;&#125; 数组首尾添加空对象1234 // 头部添加result.unshift(&#123;&#125;);// 数组 尾部添加result.push(&#123;&#125;); 将XML字符串转为JSON对象 下载插件http://www.kawa.net/works/js/xml/objtree-e.html#download 按照案例实现即可 JS函数获取url参数 已URL为参数 12345678910function getQueryParams(url)&#123; var params = url.split('?')[1].split("&amp;"); var param = &#123;&#125;; for (var i=0;i&lt;params.length;i++) &#123; console.info(params[i]); var pair = params[i].split('='); param[pair[0]] = pair[1]; &#125; console.info(JSON.stringify(param))&#125; 获取跳转当前页面的参数 12345678910111213/** * 解析URL 参数,封装为JSON对象 */function getParam() &#123; var param = &#123;&#125;; var params = decodeURI(window.location.search.substr(1)); var param_arr = params.split("&amp;"); for (var i = 0; i &lt; param_arr.length; i++) &#123; var pair = param_arr[i].split("="); param[pair[0]] = pair[1]; &#125; return param;&#125; 转换时间格式 当前时间转为时间格式 1new Date().toLocaleDateString().split('/').join('-') + ' ' + new Date().toLocaleTimeString('chinese',&#123;hour12: false&#125;) 常用的正则 字符长度 1234567891011121314151617181920 function getChars(str) &#123; var i = 0; var c = 0.0; var unicode = 0; var len = 0; if (str == null || str == "") &#123; return 0; &#125; len = str.length; for (i = 0; i &lt; len; i++) &#123; unicode = str.charCodeAt(i); if (unicode &lt; 127) &#123; //判断是单字符还是双字符 c += 1; &#125; else &#123; //chinese c += 2; &#125; &#125; return c;&#125; 登录名格式校验(只允许字母、数字、_) 12345678910111213let reg = /^[0-9a-zA-Z_]&#123;4,14&#125;$/g; if (!reg.test(value)) &#123; return '用户名不能有特殊字符'; &#125; if (/(^\_)|(\__)|(\_+$)/.test(value)) &#123; return '用户名首尾不能出现下划线\'_\''; &#125; if (/^\d+\d+\d$/.test(value)) &#123; return '用户名不能全为数字'; &#125; if (is_repeat) &#123; return '用户名不能重复'; &#125; 密码复杂度校验(数字、符号、字母其中两种) 1234567891011// 必填项不能为空new RegExp("/[\\S]+/").test(value)// 密码必须6到18位，且不能出现空格new RegExp("/^[\\S]&#123;8,14&#125;$/")// 长度为8~14个字符,字母/数字/标点符号至少包含两种,不允许有空格、中文new RegExp('^(?![\\d]+$)(?![a-zA-Z]+$)(?![^\\da-zA-Z]+$)(?![\\u4E00-\\u9FFF]).&#123;8,14&#125;$')// 不允许包含特殊字符new RegExp("[`~!@#$^&amp;*()=|&#123;&#125;':;',\\[\\].&lt;&gt;《》/?~！@#￥……&amp;*（）\\-|&#123;&#125;【】‘；：”“'。，、？\\%]"); LayUI组件某些数据行不可选123456789101112131415161718192021222324// 数据加载后禁用批量删除按钮table.render(&#123; id: 'LAY_ACCOUNT_TABLE', done:function(res,curr,count)&#123; $('#face-del').addClass('layui-btn-disabled'); let _all = false; let data = res.data; for (let i = 0; i &lt; data.length; i++) &#123; let status = data[i].enableDelete; if (!status) &#123; // checkbox 根据条件设置不可选中 $('div[lay-id=LAY_ACCOUNT_TABLE]&gt;.layui-table-box&gt;.layui-table-body&gt;.layui-table&gt;tbody&gt; tr[data-index=' + i + '] input[type="checkbox"]').prop('disabled', true); _all = true;// 隐藏表头全选判断状态 form.render();// 重新渲染一下 &#125; &#125; if (_all) &#123; // 禁用全选 checkbox $('th[data-field=' + 0 + '] input[type="checkbox"]').prop('disabled', true); &#125; form.render('checkbox'); &#125;&#125;)]]></content>
      <categories>
        <category>blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eureka-Server]]></title>
    <url>%2FSpringCloud%2FEureka-Server%2F</url>
    <content type="text"><![CDATA[Eureka-Server 基于 Eureka 搭建高可用(双节点服务注册中心)本项目是一个基于 SpringBoot(1.5.19.RELEASE)、SpringCloud(Dalston.SR5)、Eureka 的服务注册中心 配置文件说明 application.yml: 单个 Eureka 服务注册中心 application-colony.yml: 双节点注册中心示例,实现双向注册从而提高可用性 默认使用 application.yml 配置文件; 使用application-conlony.yml 配置文件时,需要指定激活的配置项.(例如启动server-1,需运行java -jar xx.jar --spring.profiles.active=server-1)]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用EasyExcel上传文件]]></title>
    <url>%2FBlog%2FJava%2FEasyExcel%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Java使用EasyExcel上传文件 Java使用EasyExcel 上传文件 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;1.1.2-beta5&lt;/version&gt;&lt;/dependency&gt; 部分代码 导入信息实体类(上传文件对应实体类) 123456789101112131415161718192021222324252627282930313233343536/** * * @ClassName: Advertising * @Description: 广告信息批量导入Model * @date 2019/01/29 */public class AdvertisingImportModel extends BaseRowModel &#123; @ExcelProperty(index = 0) private String ad; @ExcelProperty(index = 1) private String address; public String getAd() &#123; return ad; &#125; public void setAd(String ad) &#123; this.ad = ad.trim(); &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address.trim(); &#125; @Override public String toString() &#123; return "&#123;\"ad\":\"" + ad + "\",\"address\":\"" + address + "\"&#125;"; &#125;&#125; 导出文件上传实体类 1234567891011121314151617181920212223242526272829303132333435363738public class AdvertisingExportModel extends BaseRowModel &#123; @ExcelProperty(value = "用户AD", index = 0) private String name; @ExcelProperty(value = "用户地址", index = 1) private String address; public AdvertisingExportModel() &#123; &#125; public AdvertisingExportModel(String name, String address) &#123; this.name = name; this.address = address; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "&#123;\"name\":\"" + name + "\",\"address\":\"" + address + "\"&#125;"; &#125;&#125; 需要自己创建 ExcelListener 1234567891011121314151617181920212223public class ExcelListener extends AnalysisEventListener&lt;Object&gt; &#123; private List&lt;Object&gt; data = new ArrayList&lt;&gt;(); @Override public void invoke(Object object, AnalysisContext context) &#123; data.add(object); &#125; @Override public void doAfterAllAnalysed(AnalysisContext context) &#123; &#125; public List&lt;Object&gt; getData() &#123; return data; &#125; public void setData(List&lt;Object&gt; data) &#123; this.data = data; &#125;&#125; API实现方法,简单起见将代码都写在了controller(可以将具体的实现写在service层中) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * * @Title: synchronizationInformation * @Description: 上传文件并返回自己生成的数据文件 * @param file 需要同步的用户文件 * @param response 下载的文件 * void */@RequestMapping(value = "easyexcel", consumes = "multipart/*", headers = "content-type=multipart/form-data", method = RequestMethod.POST)public void synchronizationInformation(@RequestParam(name = "file", required = false) MultipartFile file, HttpServletResponse response) &#123; try &#123; List&lt;AdvertisingImportModel&gt; result; // 1. 将excel 转换为 List&lt;Object&gt; list InputStream inputStream = new BufferedInputStream(file.getInputStream()); // 文件名 String fileName = file.getOriginalFilename(); // 文件后缀 String prefix = fileName.substring(fileName.lastIndexOf(".") + 1); ExcelListener excelListener = new ExcelListener(); EasyExcelFactory.readBySax(inputStream, new Sheet(1, 1, AdvertisingImportModel.class), excelListener); // 文件内容 List&lt;Object&gt; data = excelListener.getData(); result = JSONObject.parseArray(JSON.toJSONString(data), AdvertisingImportModel.class); logger.info("上传文件包含内容:\t" + result.toString()); // 原本是要调用http接口,作为list的返回值(现暂时模拟返回值为这些) // 2.导出栅格数据文件内容 List&lt;AdvertisingExportModel&gt; list = new ArrayList&lt;&gt;(); list = JSONObject.parseArray( "[&#123;\"name\":\"亚索\",\"address\":\"艾欧尼亚\"&#125;,&#123;\"name\":\"诺克\",\"address\":\"诺克萨斯\"&#125;,&#123;\"name\":\"瑞文\",\"address\":\"艾欧尼亚\"&#125;]", AdvertisingExportModel.class); ExcelTypeEnum excelTypeEnum = prefix == ".xls" ? ExcelTypeEnum.XLS : ExcelTypeEnum.XLSX; ServletOutputStream outputStream = response.getOutputStream(); ExcelWriter writer = new ExcelWriter(outputStream, excelTypeEnum, true); Sheet sheet = new Sheet(1, 0, AdvertisingExportModel.class); sheet.setAutoWidth(true); sheet.setSheetName("第一个sheet"); fileName = new String(new SimpleDateFormat("yyyy-MM-dd").format(new Date()).getBytes(), "utf-8"); // System.out.println(fileName + prefix); response.setContentType("application/octet-stream"); response.setCharacterEncoding("utf-8"); response.setHeader("Content-Disposition", "attachment;filename=" + fileName + "." + prefix); writer.write(list, sheet); writer.finish(); outputStream.flush(); inputStream.close(); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 注： InputStream 使用file.getInputStream()时,会报异常。 使用easyexcel工具类时,需要将项目中原有的poi、poi-ooxml、poi-ooxml-schemas 版本需与easyexcel版本一致。 使用EasyExcel时,遇到的问题 org.apache.catalina.core.StandardWrapperValve 控制台输出 123二月 21, 2019 1:59:51 下午 org.apache.catalina.core.StandardWrapperValve invoke严重: Servlet.service() for servlet [springmvc] in context with path [/iptvView] threw exception [Request processing failed; nested exception is com.alibaba.excel.exception.ExcelAnalysisException: File type error，io must be available markSupported,you can do like this &lt;code&gt; new BufferedInputStream(new FileInputStream(\"/xxxx\"))&lt;/code&gt; "] with root causecom.alibaba.excel.exception.ExcelAnalysisException: Xls must be available markSupported,you can do like this &lt;code&gt; new BufferedInputStream(new FileInputStream("/xxxx"))&lt;/code&gt; 问题原因 123InputStream inputStream = file.getInputStream();//获取的时文件inputStream,获取xls时失败.抛出异常InputStream inputStream = new BufferedInputStream(file.getInputStream());//正确的获取方式 解决方式 1改为第二种获取InputStream 的方式 java.lang.ClassNotFoundException: org.apache.poi.poifs.filesystem.FileMagic 问题原因 项目中引用了poi、poi-oomxl、poi-oomxl-schemas jar包，并且版本与 easyexcel 版本不一致 解决方案 更新/降低 项目中引入的poi版本,使 版本保持一致]]></content>
      <categories>
        <category>Blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Echarts使用总结]]></title>
    <url>%2Fblog%2FWeb-Plugins%2FECharts%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Echarts使用总结 Echarts使用笔记设置默认选中显示数据1234567option =&#123; legend:&#123; selected : &#123; 'XX':false //不想显示的设为false &#125; &#125;&#125; 设置Y轴数值 1000显示为1K123456789101112131415yAxis : &#123; type : 'value', axisLabel : &#123; color : '#fff', formatter : function(value, index) &#123; var thousand; if (value &gt;= 1000) &#123; thousand = value / 1000 + 'k'; &#125; else &#123; thousand = value &#125; return thousand; &#125; &#125;&#125; 设置超长字符串为...设置echarts 柱状图颜色123option:&#123; color: ['#003366', '#006699', '#4cabce', '#ccc']&#125; 图标点击事件监听 文档地址 12345/* 使用文档相同的监听不知道为什么无效,需要改为如下写法 */// 始呼接通率监听事件myCharts.getZr().on('click', function () &#123; console.info('监听点击事件')&#125;); 坐标轴赋值12345678910111213141516171819202122function myCharts(params) &#123; var url=""; $.getJSON(url, params,l function (result) &#123; op.setOption(&#123; xAxis: &#123; data: result.map(function (item) &#123; return item.time; &#125;) &#125;, series: [&#123; data: result.map(function (item) &#123; return item.eci_rate; &#125;) &#125;, &#123; data: result.map(function (item) &#123; return item.ne_rate; &#125;) &#125;] &#125;); &#125;);&#125; 饼图123456789101112131415161718192021222324// 使用自定义的echarts themevar failed_pie_charts = echarts.init(document.getElementById("failed_pie"),'macarons');$.getJSON(url, params, function (result) &#123; var failed_reason = []; $.each(result, function (index, items) &#123; failed_reason.push(&#123; name: items.QUERY_TYPE, value: items.RATE &#125;) &#125;); failed_pie_charts.setOption(&#123; legend: &#123; data: result.map(function (item) &#123; return item.QUERY_TYPE &#125;) &#125;, series: &#123; data: failed_reason &#125; &#125;) &#125;) Echarts 图标横坐标显示不全12345678910xAxis: &#123; type: 'category', boundaryGap: true, axisTick: &#123; alignWithLabel: true &#125;, axisLabel: &#123; interval: 0, // 显示不全的主要配置,加上该配置即可 &#125; &#125; 设置图形以平滑曲线显示123series-line.smooth:true // 是否以平滑曲线显示series-line.symbol: 'none' // 标记的图形]]></content>
      <categories>
        <category>blog</category>
        <category>Web Plugins</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fall%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[页面传参中文参数乱码]]></title>
    <url>%2Fblog%2FHTML%2Furl%E4%BC%A0%E5%8F%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[页面传参中文参数乱码 页面传递中文参数乱码解决 方案一: 接收端设置编码格式 使用 request.setCharacterEncoding(&#39;utf-8&#39;); 使用 request.getParameter(&quot;handlerType&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;utf-8&quot;) 接受传递的参数值]]></content>
      <categories>
        <category>blog</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>CharacterEncoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat 多端口部署 web 项目]]></title>
    <url>%2Fblog%2FTomcat%2F%E5%8D%95%E4%B8%AATomcat%E5%A4%9A%E7%AB%AF%E5%8F%A3%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[Tomcat 多端口部署 web 项目 单个 Tomcat 运行多个实例、分配不同端口 第一种方式：更改 Connector 中的端口号 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;!-- 第一个项目端口号 --&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;!-- 第二个端口号 --&gt; &lt;Connector port="7090" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" maxThreads="150" maxSpareThreads="75" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 多个 Tomcat 部署上传多个不同版本 tomcat/tomcat 部署多个实例修改 server.xml默认 server.xml 配置 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Server port="8005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 修改 shutdown 端口,如果同样使用 8005 那么关闭其中一个时另外的 shutdown.port= 7005 的tomcat 也会被关闭 --&gt;&lt;Server port="7005" shutdown="SHUTDOWN"&gt; &lt;Listener className="org.apache.catalina.startup.VersionLoggerListener" /&gt; &lt;Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" /&gt; &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" /&gt; &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" /&gt; &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" /&gt; &lt;GlobalNamingResources&gt; &lt;Resource name="UserDatabase" auth="Container" type="org.apache.catalina.UserDatabase" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" pathname="conf/tomcat-users.xml" /&gt; &lt;/GlobalNamingResources&gt; &lt;Service name="Catalina"&gt; &lt;!-- 修改启动端口号 --&gt; &lt;Connector port="7090" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="7443" maxThreads="150" maxSpareThreads="75" /&gt; &lt;Connector port="7009" protocol="AJP/1.3" redirectPort="7443" /&gt; &lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true" reloadable="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt;&lt;/Server&gt; 关闭tomcat 时杀死进程 修改catalina.sh文件 123456# 设置记录 CATALINA_PID# 该设置会在启动时在 /bin 目录下新建CATALINA_PID 文件# 关闭时从 CATALINA_PID 文件找到 pid,kill 同时删除 CATALINA_PID 文件if [ -z "$CATALINA_PID" ]; then CATALINA_PID=$PRGDIR/CATALINA_PIDfi 修改shutdown.sh文件,在最后一行加上-force 更新Tomcat版本 增加catalina.sh 配置 123456789export JAVA_HOME=/usr/java/jdk1.8.0_101export JRE_HOME=/usr/java/jdk1.8.0_101/jreexport CATALINA_HOME=/opt/tomcat-iptvview/apache-tomcat-8.5.40export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH# specify jdk versionJAVA_HOME=/usr/java/jdk1.8.0_101JRE_HOME=/usr/java/jdk1.8.0_101/jre]]></content>
      <categories>
        <category>blog</category>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通 Java/Jave Web 转为 Maven 项目]]></title>
    <url>%2Fblog%2FJava%2F%E6%A0%B9%E6%8D%AEjar%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90pom%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[普通 Java/Jave Web 转为 Maven 项目 Jar文件 更改为 pom.xml 依赖 只需要运行方法即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.sanss.util;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.jar.JarInputStream;import java.util.jar.Manifest;import org.dom4j.Element;import org.dom4j.dom.DOMElement;import org.jsoup.Jsoup;import com.alibaba.fastjson.JSONObject;/** * * @ClassName: MakePomFromJars * @author: * @Date: 2018/06/21 * @Description: 将jar 包生pom依赖 * */public class MakePomFromJars &#123; public static void main(String[] args) throws FileNotFoundException, IOException &#123; Element dependencys = new DOMElement("dependencies"); File dir = new File("D:\\Code\\sts-work-workspace\\iptvView\\WebRoot\\WEB-INF\\lib");// 生pom文件的lib路径 System.out.println("读取文件路径为:\t" + dir.getPath()); System.out.println("开始读取文件: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); StringBuffer missJar = new StringBuffer(); for (File jar : dir.listFiles()) &#123; JarInputStream jis = new JarInputStream(new FileInputStream(jar)); Manifest manifest = jis.getManifest(); jis.close(); if (manifest == null) &#123; continue; &#125; String bundleName = manifest.getMainAttributes().getValue("Bundle-Name"); String bundleVersion = manifest.getMainAttributes().getValue("Bundle-Version"); Element element = null; System.out.println(jar.getName()); StringBuffer sb = new StringBuffer(jar.getName()); if (bundleName != null) &#123; bundleName = bundleName.toLowerCase().replace(" ", "-"); sb.append(bundleName + "\t" + bundleVersion); element = getDependices(bundleName, bundleVersion); // System.out.println(sb.toString()); // System.out.println(element.asXML()); &#125; if (element == null || element.elements().size() == 0) &#123; bundleName = ""; bundleVersion = ""; String[] ns = jar.getName().replace(".jar", "").split("-"); for (String s : ns) &#123; if (Character.isDigit(s.charAt(0))) &#123; bundleVersion += s + "-"; &#125; else &#123; bundleName += s + "-"; &#125; &#125; if (bundleVersion.endsWith("-")) &#123; bundleVersion = bundleVersion.substring(0, bundleVersion.length() - 1); &#125; if (bundleName.endsWith("-")) &#123; bundleName = bundleName.substring(0, bundleName.length() - 1); &#125; element = getDependices(bundleName, bundleVersion); sb.setLength(0); sb.append(bundleName + "\t").append(bundleVersion); // System.out.println(sb.toString()); // System.out.println(element.asXML()); &#125; element = getDependices(bundleName, bundleVersion); if (element.elements().size() == 0) &#123; element.add(new DOMElement("groupId").addText("not found")); element.add(new DOMElement("artifactId").addText(bundleName)); element.add(new DOMElement("version").addText(bundleVersion)); missJar.append(bundleName + "\n");// 统计缺失的jar名称 &#125; else &#123; dependencys.add(element); // System.out.println(); &#125; &#125; System.err.println(missJar); System.out.println(dependencys.asXML()); &#125; private static Element getDependices(String key, String ver) &#123; Element dependency = new DOMElement("dependency"); // 设置代理 // System.setProperty("http.proxyHost","127.0.0.1"); // System.setProperty("http.proxyPort", "8090"); try &#123; String url = "http://search.maven.org/solrsearch/select?q=a%3A%22" + key + "%22%20AND%20v%3A%22" + ver + "%22&amp;rows=3&amp;wt=json"; org.jsoup.nodes.Document doc = Jsoup.connect(url).ignoreContentType(true).timeout(30000).get(); String elem = doc.body().text(); JSONObject response = JSONObject.parseObject(elem).getJSONObject("response"); if (response.containsKey("docs") &amp;&amp; response.getJSONArray("docs").size() &gt; 0) &#123; JSONObject docJson = response.getJSONArray("docs").getJSONObject(0); Element groupId = new DOMElement("groupId"); Element artifactId = new DOMElement("artifactId"); Element version = new DOMElement("version"); groupId.addText(docJson.getString("g")); artifactId.addText(docJson.getString("a")); version.addText(docJson.getString("v")); dependency.add(groupId); dependency.add(artifactId); dependency.add(version); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return dependency; &#125;&#125;]]></content>
      <categories>
        <category>blog</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 在线文档地址]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SpringBoot 在线文档地址 SpringBoot 在线文档地址英文版中文版 15.1 在main函数类中使用@Import注解1You need not put all your @Configuration into a single class. The @Import annotation can be used to import additional configuration classes. Alternatively, you can use @ComponentScan to automatically pick up all Spring components, including @Configuration classes. 释义： 您无需将所有@Configuration放入单个类中。 @Import注释可用于导入其他配置类。或者，您可以使用@ComponentScan自动获取所有Spring组件，包括@Configuration类。 24.56 使用Java类加载 配置文件参数值 配置类 1234567891011121314151617181920212223242526 @ConfigurationProperties("foo") public class FooProperties &#123; private final List&lt;MyPojo&gt; list = new ArrayList&lt;&gt;(); public List&lt;MyPojo&gt; getList() &#123; return this.list; &#125; &#125; ``` * 注: 推荐使用构造函数的方式注入属性值&gt; 配置文件 ```ymlfoo: list: - name: my name description: my description---spring: profiles: devfoo: list: - name: my another name]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Redis 自定义主键增长策略]]></title>
    <url>%2FSpringBoot%2FSpringboot%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%94%AE%E5%A2%9E%E9%95%BF%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[SpringBoot + Redis 自定义主键增长策略 SpringBoot 使用 Redis 生成yyyyMMdd + 0001 格式id 开发环境 当前开发环境: SpringBoot + redis，应该可以用于其他同样使用Redis的环境生成唯一id环境(未曾亲自实践) 适用场景: 单个服务的唯一id生成工具类 如果之前未引入Redis则需要增加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在.properties文件中增加Redis配置 123456789101112131415161718192021# REDIS的配置信息# Redis数据库索引（默认为0）spring.redis.database=0 # 指定Redis服务器地址，多环境/注释实现(本文有参考链接)spring.redis.host=127.0.0.1# Redis服务器连接端口spring.redis.port=6379# 用户缓存超时时间spring.redis.expireTime=1800# Redis服务器连接密码（默认为空）#spring.redis.password=foobared# 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=8 # 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1 # 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=8 # 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0 # 连接超时时间（毫秒）spring.redis.timeout=12000 注: SpringBoot多环境配置[^多环境配置] 工具类代码片段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Calendar; import java.util.Date;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.support.atomic.RedisAtomicLong;import org.springframework.stereotype.Service;/** * * @ClassName: RedisGeneratorCode * @Description: 生成日期开头加0001，0002，0003的工具类 * @author time * @date 2018/10/09 * &#123;@link https://www.cnblogs.com/jbml-154312/p/7490810.html&#125; */@Servicepublic class RedisGeneratorCode &#123; private static final Logger logger = LoggerFactory.getLogger(RedisGeneratorCode.class); private RedisTemplate&lt;String, Object&gt; redisTemplate; @Autowired public RedisGeneratorCode(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; /** * * @Title: generateCode * @Description: 生成自定义前缀的类似 HTG201810120001格式的自增数 * @param key * @param prefix * @param hasExpire * @param minLength * @return * String */ public String generateCode(String key, String prefix, boolean hasExpire, Integer minLength) &#123; return this.createGenerateCode(key, prefix, hasExpire, minLength); &#125; /** * * @Title: generateCode * @Description: 生成 类似 201810120001格式的自增数 * @param key * @param hasExpire * @param minLength * @return * String */ public String generateCode(String key, boolean hasExpire, Integer minLength) &#123; return this.createGenerateCode(key, "", hasExpire, minLength); &#125; /** * * @Title: generateCode * @Description: 组装符合自己规则的id并设置过期时间 * @param key redis中的key值 * @param prefix 最后编码的前缀 * @param hasExpire redis 是否使用过期时间设置自增id * @param minLength redis生成的自增id的最小长度，如果小于这个长度前面补0 * @return * String */ public String createGenerateCode(String key, String prefix, boolean hasExpire, Integer minLength) &#123; try &#123; Date date = null; Long id = null; Calendar calendar = Calendar.getInstance(); if (hasExpire) &#123; calendar.set(Calendar.HOUR_OF_DAY, 23); calendar.set(Calendar.MINUTE, 59); calendar.set(Calendar.SECOND, 59); calendar.set(Calendar.MILLISECOND, 9999); date = calendar.getTime(); &#125; else &#123; calendar.set(Calendar.MINUTE, calendar.get(Calendar.MINUTE) + 10); date = calendar.getTime(); &#125; id = this.generateId(key, date); if (id != null) &#123; return this.format(id, prefix, minLength); &#125; &#125; catch (Exception e) &#123; logger.info("error --&gt; redis 生成自增id出现异常"); logger.error(e.getMessage(), e); &#125; return null; &#125; /** * * @Title: generateId * @Description: 使用RedisAtomicLong自增 * @param key * @param date * @return * Long */ private Long generateId(String key, Date date) &#123; RedisAtomicLong counter = new RedisAtomicLong(key, redisTemplate.getConnectionFactory()); // 通过key获取自增并设定过期时间 counter.expireAt(date); return counter.incrementAndGet(); &#125; /** * * @Title: format * @Description: 获取 redis 自增后，生成自定义格式的id * @param id redis 获取的 id值 * @param prefix 自定义前缀 * @param minLength 生成数的长度，不满足时 0 补齐 * @return * String */ private String format(Long id, String prefix, Integer minLength) &#123; // 拼接的字符串 StringBuffer sb = new StringBuffer(); // 当前日期 Date date = new Date(); // 自定义前缀 sb.append(prefix); if (date != null) &#123; DateFormat df = new SimpleDateFormat("yyyyMMdd"); sb.append(df.format(date)); &#125; /* 对不满足长度的id值,使用0补齐 */ // redis 生成的id值 String strId = String.valueOf(id); // redis 生成id 的长度 int length = strId.length(); if (length &lt; minLength) &#123; for (int i = 0; i &lt; minLength - length; i++) &#123; sb.append("0"); &#125; sb.append(strId); &#125; else &#123; sb.append(strId); &#125; return sb.toString(); &#125;&#125; 测试工具类 123456789101112131415@Autowiredprivate RedisGeneratorCode redisGeneratorCode;@Testpublic void createGenerateCodeTest() &#123; // String code = primaryGenerater.generateCode("worksheet_id", "", true, 4); boolean flag = true; String code = null; int count = 0; while (flag) &#123; code = redisGeneratorCode.generateCode("worksheet_id", "", true, 4); flag = code == null ? true : false; &#125; System.out.println(code);&#125; 参考链接: java生成自增流水号，并从每月第一天重新清零计数将业务流水号添加到数据库(原创) 使用redis生成全局唯一id SpringBoot集成Redis 脚注 [^多环境配置]: 参考另一篇博客SpringBoot多环境配置]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置https(xx.Jar、xx.war)]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8https%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[SpringBoot配置https(xx.Jar、xx.war) SpringBoot配置https 与 War包配置https参考地址：https://blog.csdn.net/u012702547/article/details/53790722 SpringBoot 项目配置 *.jar 第一步：生成加密证书 方法：使用Java自带的命令,在cmd中执行以下语句 keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 参数说明 -storetype 指定秘钥仓库类型 -keyalg 指定证书生成算法签名，RSA是一种非对称加密算法 -keysize 证书大小 -keystore 生成证书文件的存储路径 -validity 证书有效期 第二步：修改项目配置 执行上述命令后，可在当前系统登录用户根目录下找到keystore.p12文件。将文件复制到springboot项目根目录下.同时需要对application.yml文件作出修改，增加如下内容。(也可使用xx.properties文件，文本内容修改为properties文件格式即可) 配置文件修改(.yml格式文件，.properties文件修改只是使用了不同的书写方式如有不懂请自行百度) 123456server: ssl: key-store: keystore.p12 key-store-password: 111111 key-store-type: PKCS12 key-alias: tomcat Tomcat 部署 SpringBoot *.war 文件 第一步：生成加密证书 方法：使用Java自带的命令,在cmd中执行以下语句 keytool -genkey -alias tomcat -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 3650 第二步： 注释 8080 (tomcat默认端口为8080,如果修改为其他端口则注释修改后的端口) &lt;!-- &lt;Connector port=&quot;7090&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; --&gt; 取消注释 8433 端口配置,并修改为 443 端口(访问可不加端口设置)，修改tomcat中D:\Environment\Tomcat\apache-tomcat-8.0.50\conf\server.xml 需做如下配置。(tomcat路径为发布war文件的server.xml) keystoreFile=&quot;D:\Environment\Tomcat\apache-tomcat-8.5.31\conf\keystore.p12&quot; keystorePass=&quot;111111&quot; 注：修改后如下 12345678910&lt;Connector port="443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true" keystoreFile="D:\Environment\Tomcat\apache-tomcat-8.5.31\conf\keystore.p12" keystorePass="111111" &gt; &lt;!-- &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile="conf/localhost-rsa.jks" type="RSA" /&gt; &lt;/SSLHostConfig&gt; --&gt;&lt;/Connector&gt; &lt;!-- 修改8443端口为443 --&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="443" /&gt;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + logback 日志配置]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AElogback%2F</url>
    <content type="text"><![CDATA[SpringBoot + logback 日志配置 SpringBoot 使用 logback-spring.xml 生成日志文件 注: 参考配置1参考配置2 logback配置文件命名 自定义日志配置 创建名为 logback.xml、logback-xxx.xml的文件,需要在 application.yml/application.properties文件中指定加载的配置文件路径 12logging: config: classpath:logback.xml 注：官方推荐将logback-spring.xml放在根目录下,可以省略上述步骤. logback-spring.xml配置 在application.yml中指定日志文件输出路径、文件名 123logback: logdir: D:/project/logs name: project 注: 当前环境为window为包含盘符的绝对路径,linux环境需要修改为不含盘符的绝对路径 logback-spring.xml配置文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="tue" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- application.yml 传递参数，不能使用logback 自带的&lt;property&gt;标签 --&gt; &lt;!-- 日志输出路径,在yml文件中配置 --&gt; &lt;springProperty scope="context" name="logdir" source="logback.logdir" /&gt; &lt;!-- 文件名 --&gt; &lt;springProperty scope="context" name="logName" source="logback.name" /&gt; &lt;!-- 输出到控制台 Consoleappender --&gt; &lt;appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 展示格式 layout --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy/MM/dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- infoLog 输出 --&gt; &lt;appender name="fileInfoLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 如果只是想要 info 级别的日志,只是过滤 info 还是会输出 error 日志,因为 Error 的日志级别更高。 使用下面的策略,可以避免输出 Error 日志 --&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;!-- 过滤 Error --&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;!-- 匹配到就禁止 --&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;!-- 没有匹配到就允许 --&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;!-- 日志名称,如果没有 File 属性,name只会使用FileNamePattern的文件路径规则 如果同时又&lt;File&gt;和&lt;FileNamePattern&gt;,那么当天日志时&lt;File&gt;.明天会自动把今天的日志名改为今天的日期 即：&lt;File&gt; 的日志都是当天的。 --&gt; &lt;File&gt;$&#123;logdir&#125;/info.$&#123;logName&#125;.log&lt;/File&gt; &lt;!-- 滚动策略,按照时间滚动 TimeBasedRollingPolicy --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件路径,定义了日志的切分方式 把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间 --&gt; &lt;FileNamePattern&gt;$&#123;logdir&#125;/info.$&#123;logName&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!-- 设置 日志保留时间 30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 用来指定日志文件的上限大小,到上限之后会删除旧日志 --&gt; &lt;!-- &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; --&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出编码格式化 --&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;yyyy/MM/dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- Error 级别日志文件 --&gt; &lt;appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 如果只是想要 Error 级别的日志,那么需要过滤一下.默认是info 级别的,ThresholdFilter --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;Error&lt;/level&gt; &lt;/filter&gt; &lt;!-- 日志名称,如果没有 File 属性,name只会使用FileNamePattern的文件路径规则 如果同时又&lt;File&gt;和&lt;FileNamePattern&gt;,那么当天日志时&lt;File&gt;.明天会自动把今天的日志名改为今天的日期 即：&lt;File&gt; 的日志都是当天的。 --&gt; &lt;File&gt;$&#123;logdir&#125;/error.$&#123;logName&#125;.log&lt;/File&gt; &lt;!-- 滚动策略,按照时间滚动 TimeBasedRollingPolicy --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 文件路径,定义了日志的切分方式 把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间 --&gt; &lt;FileNamePattern&gt;$&#123;logdir&#125;/error.$&#123;logName&#125;.%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!-- 设置 日志保留时间 30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;!-- 用来指定日志文件的上限大小,到上限之后会删除旧日志 --&gt; &lt;!-- &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt; --&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出编码格式化 --&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d&#123;yyyy/MM/dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 开发环境日志级别为DEBUG ,可以使用逗号分隔列表指定多个配置文件 --&gt; &lt;springProfile name="dev"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="consoleLog" /&gt; &lt;appender-ref ref="fileInfoLog" /&gt; &lt;appender-ref ref="fileErrorLog" /&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;springProfile name="test,prod"&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="consoleLog" /&gt; &lt;appender-ref ref="fileInfoLog" /&gt; &lt;appender-ref ref="fileErrorLog" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 配置文件标签说明 根节点&lt;configuration&gt;包含的属性 scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 注: 依照本文配置,可在指定路径中生成自定义的日志文件名(info与error日志分开,默认当前日志为application.yml中的logging.name作为文件名可自行定义)。历史日志文件名 增加日期格式]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot Log]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E7%88%AC%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[SpringBoot Log Transactional事务回滚 12345678910//方法上增加注解@Transactional(rollbackOn = Exception.class)public void example() &#123; try &#123; &#125; catch (Exception e) &#123; // 设置异常时执行回滚 TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); &#125;&#125; 配置类序列化失败 问题描述： 将配置类使用 JackSon 序列化时，出现序列化异常 SpringBoot请求跨域 12345678910111213141516171819202122232425262728293031323334package com.learnning.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;/** * * @ClassName: CustomCORSConfiguration * @Description: 配置跨域请求访问失败的问题 * @author time * @date 2018/11/21 */@Configurationpublic class CustomCORSConfiguration &#123; private CorsConfiguration buildConfig() &#123; CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin("*"); corsConfiguration.addAllowedHeader("*"); corsConfiguration.addAllowedMethod("*"); return corsConfiguration; &#125; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration("/**", buildConfig()); return new CorsFilter(source); &#125;&#125; 注: 引用链接: 周立解决方案 SpringBoot JPA查询传参 使用占位符? 12@Query(value = "select account_id,user_name,validity from t_account where account_id = ?", nativeQuery = true)User findByAccount_id(Long account_id); 使用命名化参数:name 12@Query(value = "select account_id,user_name,validity from t_account where account_id =:id", nativeQuery = true)User findByAccount_id(@Param("id") Long account_id); 注: 参考Spring Data JPA系列: 使用@Query注解（Using @Query） 自定义SpringBoot web页面图标 将图标放在/src/main/resources/static/目录下(推荐使用favicon.ico名字,符合*.ico即可) 在需要替换图标的页面加入以下标签 1&lt;link rel="icon" type="image/x-icon" th:href="@&#123;/favicon.ico&#125;"&gt; 注:该方式为最简单的实现,可以根据自身情况做调整。更改相应的相对路径即可,可自行尝试。]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Hikari +JPA 多数据源]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90JPA%2F</url>
    <content type="text"><![CDATA[SpringBoot + Hikari +JPA 多数据源 SpringBoot2.0 Hikari 多数据源 —— JPA SpringBoot 连接多数据源使用 JPA 查询应用记录. pom.xml依赖配置12345&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 注：SpringBoot 2.0默认的数据连接池为Hikari，故不需要添加 Hikari 依赖 多数据源配置 primaryDataSource 配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.learnning.config;import javax.persistence.EntityManager;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.zaxxer.hikari.HikariDataSource;/** * * @ClassName: HikariDataSourceConfig * @Description: Hikari 多数据源配置(第一数据源配置) * @author time * @date 2018/10/29 * &#123;@link &#123;@link http://blog.didispace.com/springbootmultidatasource/&#125;&#125; */@Configuration@EnableTransactionManagement@EnableJpaRepositories(entityManagerFactoryRef = "primaryEntityManagerFactory", // transactionManagerRef = "primaryTransactionManager", // basePackages = &#123; "com.learnning.domain.p" &#125;) // 设置Repository所在位置public class PrimaryConfig &#123; @Primary @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Primary @Bean(name = "primaryEntityManager") public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return primaryEntityManagerFactory(builder).getObject().createEntityManager(); &#125; @Primary @Bean(name = "primaryEntityManagerFactory") public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return builder// .dataSource(primaryDataSource()) // .packages("com.learnning.domain.p")// .persistenceUnit("primaryPersistenceUnit")// .build(); &#125; @Primary @Bean(name = "primaryTransactionManager") public PlatformTransactionManager transactionManager(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(primaryEntityManagerFactory(builder).getObject()); &#125;&#125; sencondaryDataSource 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.learnning.config;import javax.persistence.EntityManager;import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.jpa.repository.config.EnableJpaRepositories;import org.springframework.orm.jpa.JpaTransactionManager;import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import com.zaxxer.hikari.HikariDataSource;/** * * @ClassName: HikariDataSourceConfig * @Description: Hikari 多数据源配置(第一数据源配置) * @author time * @date 2018/10/29 * &#123;@link &#123;@link http://blog.didispace.com/springbootmultidatasource/&#125;&#125; */@Configuration@EnableTransactionManagement@EnableJpaRepositories(entityManagerFactoryRef = "secondaryEntityManagerFactory", // transactionManagerRef = "secondaryTransactionManager", // basePackages = &#123; "com.learnning.domain.s" &#125;) // 设置Repository所在位置public class SecondaryConfig &#123; @Bean(name = "sencondaryDataSource") @Qualifier(value = "sencondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.secondary") public DataSource sencondaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "secondaryEntityManager") public EntityManager entityManager(EntityManagerFactoryBuilder builder) &#123; return secondaryEntityManagerFactory(builder).getObject().createEntityManager(); &#125; @Bean(name = "secondaryEntityManagerFactory") public LocalContainerEntityManagerFactoryBean secondaryEntityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return builder// .dataSource(sencondaryDataSource()) // .packages("com.learnning.domain.s")// .persistenceUnit("secondaryPersistenceUnit")// .build(); &#125; @Bean(name = "secondaryTransactionManager") PlatformTransactionManager transactionManager(EntityManagerFactoryBuilder builder) &#123; return new JpaTransactionManager(secondaryEntityManagerFactory(builder).getObject()); &#125;&#125; JPA 使用多数据源查询划重点： JPA的entity与table因为有映射关系，所以实体类路径需要映射到对应的DataSource中 JPA查询接口最好也根据不同数据源区分开 primary数据源配置 primary数据源实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.learnning.domain.p;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name = "t_account")public class User &#123; @Id @GeneratedValue private Long account_id; private String user_name; private Integer validity; public Long getAccount_id() &#123; return account_id; &#125; public void setAccount_id(Long account_id) &#123; this.account_id = account_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getValidity() &#123; return validity; &#125; public void setValidity(Integer validity) &#123; this.validity = validity; &#125; @Override public String toString() &#123; return "&#123;\"account_id\":\"" + account_id + "\",\"user_name\":\"" + user_name + "\",\"validity\":\"" + validity + "\"&#125;"; &#125;&#125; primary 数据源Repository 1234567891011121314151617181920212223package com.learnning.domain.p.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import com.learnning.domain.p.User;public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; /** * * @Title: findByAccount_id * @Description: 查询用户 User 信息 * nativeQuery：指定为原生SQL查询 * @param account_id * @return * User */ /// 模糊匹配 @Query(value = "select account_id,user_name,validity from t_account where account_id = ?", nativeQuery = true) User findByAccount_id(Long account_id);&#125; secondary 数据源配置 secondary 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.learnning.domain.s;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name = "t_user")public class PopUser &#123; @Id @GeneratedValue private Long pop_id; private String pop_name; private String ip_start; private String ip_end; private String netmask; private String description; private String start_num; private String end_num; private String platform; private Integer ipgap; private Integer pop_type; public Long getPop_id() &#123; return pop_id; &#125; public void setPop_id(Long pop_id) &#123; this.pop_id = pop_id; &#125; public String getPop_name() &#123; return pop_name; &#125; public void setPop_name(String pop_name) &#123; this.pop_name = pop_name; &#125; public String getIp_start() &#123; return ip_start; &#125; public void setIp_start(String ip_start) &#123; this.ip_start = ip_start; &#125; public String getIp_end() &#123; return ip_end; &#125; public void setIp_end(String ip_end) &#123; this.ip_end = ip_end; &#125; public String getNetmask() &#123; return netmask; &#125; public void setNetmask(String netmask) &#123; this.netmask = netmask; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public String getStart_num() &#123; return start_num; &#125; public void setStart_num(String start_num) &#123; this.start_num = start_num; &#125; public String getEnd_num() &#123; return end_num; &#125; public void setEnd_num(String end_num) &#123; this.end_num = end_num; &#125; public String getPlatform() &#123; return platform; &#125; public void setPlatform(String platform) &#123; this.platform = platform; &#125; public Integer getIpgap() &#123; return ipgap; &#125; public void setIpgap(Integer ipgap) &#123; this.ipgap = ipgap; &#125; public Integer getPop_type() &#123; return pop_type; &#125; public void setPop_type(Integer pop_type) &#123; this.pop_type = pop_type; &#125; @Override public String toString() &#123; return "&#123;\"pop_id\":\"" + pop_id + "\",\"pop_name\":\"" + pop_name + "\",\"ip_start\":\"" + ip_start + "\",\"ip_end\":\"" + ip_end + "\",\"netmask\":\"" + netmask + "\",\"description\":\"" + description + "\",\"start_num\":\"" + start_num + "\",\"end_num\":\"" + end_num + "\",\"platform\":\"" + platform + "\",\"ipgap\":\"" + ipgap + "\",\"pop_type\":\"" + pop_type + "\"&#125;"; &#125;&#125; secondary 数据源 Repository 123456789101112131415package com.learnning.domain.s.repository;import java.util.List;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Query;import com.learnning.domain.s.PopUser;public interface PopUserRepository extends JpaRepository&lt;PopUser, Long&gt; &#123; @Query(value = "select pop_name,pop_id,ip_start,ip_end,netmask,description,start_num,end_num,platform,ipgap,pop_type from t_user where rownum&lt;= 10", nativeQuery = true) List&lt;PopUser&gt; queryPopUserPage1();&#125; 测试类123456789101112131415@Autowiredprivate UserRepository userRepository;@Autowiredprivate PopUserRepository popUserRepository;@Testpublic void testPrimarySession() &#123; User users = userRepository.findByAccount_id(1L); System.out.println(users.toString()); List&lt;PopUser&gt; page = popUserRepository.queryPopUserPage1(); System.out.println(page.toString());&#125; 注： SpringBoot官方建议使用构造函数的方式注入依赖，上述测试代码为在测试类中使用. 使用构造函数注入如下： 123456789private UserRepository userRepository;private PopUserRepository popUserRepository;@Autowiredpublic MyErrorController(UserRepository userRepository, PopUserRepository popUserRepository) &#123; this.userRepository = userRepository; this.popUserRepository = popUserRepository;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Hikari</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot + Durid | Hikari 多数据源 JDBCTemplate]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[SpringBoot + Durid 多数据源 JDBCTemplateSpringBoot + Hikari 多数据源 JDBCTemplate SpringBoot 配置多数据源(Druid | Hikari) 注释: Druid：阿里系数据连接池Hikari：SpringBoot 2.0开始推HikariCP，将默认的数据库连接池tomcat jdbc pool改为了hikari SpringBoot + Druid 配置Druid-Jdbctemplate 连接配置jdbctemplate连接 增加pom依赖 1234567891011121314151617181920&lt;!-- 本地连接oracle的文件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;$&#123;ojdbc.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据库连接池 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 设置application.yml文件配置 12345678910111213141516171819202122232425262728293031323334spring: autoconfigure: ## 多数据源下必须排除掉 DataSourceAutoConfiguration,否则会导致循环依赖报错 exclude: - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration datasource: type: com.alibaba.druid.pool.DruidDataSource druid: ## 以`spring.datasources`和`spring.datasource.druid`开头的属性会作为公共配置,注入到每一个数据源 initial-size: 5 min-idle: 5 max-active: 20 stat-view-servlet: login-username: admin login-password: admin max-wait: 60000 time-between-eviction-runs-millis: 60000 ## 配置间隔多久才进行一次检测,检测需要关闭的空闲连接.单位是毫秒 min-evictable-idle-time-millis: 300000 ## 配置一个连接池中最小生存的时间,单位是毫秒 ## 配置监控统计拦截的filters,去掉后监控界面SQL无法进行统计,`wall`用于防火墙(https://blog.csdn.net/garyond/article/details/80189939) filters: config,stat,wall,log4j web-stat-filter: exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' ## 多数据源的标识,若该属性存在则为多数据源环境,不存在则为但数据源环境 data-sources: primary: url: jdbc:oracle:thin:@//xx:1521/xx username: xx password: xx driverClassName: oracle.jdbc.driver.OracleDriver secondary: url: jdbc:oracle:thin:@//xx:1521/xx username: xx password: xx driverClassName: oracle.jdbc.driver.OracleDriver Druid 连接池配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import com.alibaba.druid.pool.DruidDataSource;/*** * @ClassName: DruidDataScouConfig* @Description: 多数据源,集成Druid* @author time* @date 2018/10/29*/@Configurationpublic class DruidDataScouConfig &#123; @Primary//必需注解，缺少该注解将启动异常.可自定义某个数据源为主数据源 @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.druid.data-sources.primary") public DataSource primaryDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.druid.data-sources.secondary") public DataSource secondaryDataSource() &#123; return new DruidDataSource(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryJdbcTemplate") public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 测试数据源是否可用 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.sanss.config;import java.util.List;import java.util.Map;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import com.alibaba.fastjson.JSON;@RunWith(SpringRunner.class)@SpringBootTestpublic class DruidDataSourceTest &#123; @Autowired // @Qualifier("primaryJdbcTemplate") private JdbcTemplate primaryJdbcTemplate; @Autowired // @Qualifier("secondaryJdbcTemplate")//注解可省略 private JdbcTemplate secondaryJdbcTemplate; @Test public void TestPrimaryDataSourceConnect() &#123; System.err.println("primary data source connection start:"); String sql = "select 1 from dual"; List&lt;Map&lt;String, Object&gt;&gt; result = primaryJdbcTemplate.queryForList(sql); System.out.println(JSON.toJSONString(result)); &#125; @Test public void TestSecondaryDataSourceConnect() &#123; System.err.println("secondary data source connection start:"); String sql = "select 1 from dual"; List&lt;Map&lt;String, Object&gt;&gt; result = secondaryJdbcTemplate.queryForList(sql); System.out.println(JSON.toJSONString(result)); &#125;&#125; 注: 连接池配置参数,可以参考数据库连接配置策略和实践指南 Hikari-jdbctemplate 连接配置 添加pom.xml依赖 1234567891011&lt;!-- 本地连接oracle的文件 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.oracle.ojdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;version&gt;$&#123;ojdbc.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 设置application.yml多环境配置文件 123456789101112spring: datasource: primary: jdbc-url: jdbc:oracle:thin:@//xx:1521/xx username: xx password: xx driver-class-name: oracle.jdbc.driver.OracleDriver secondary: jdbc-url: jdbc:oracle:thin:@//xx:1521/xx username: xx password: xx driver-class-name: oracle.jdbc.driver.OracleDriver Hikari 数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import javax.sql.DataSource;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.jdbc.core.JdbcTemplate;import com.zaxxer.hikari.HikariDataSource;/** * * @ClassName: HikariDataSourceConfig * @Description: Hikari 多数据源配置 * @author time * @date 2018/10/29 */@Configurationpublic class HikariDataSourceConfig &#123; @Primary @Bean(name = "primaryDataSource") @Qualifier(value = "primaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.primary") public DataSource primaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "secondaryDataSource") @Qualifier(value = "secondaryDataSource") @ConfigurationProperties(prefix = "spring.datasource.secondary") public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build(); &#125; @Bean(name = "primaryJdbcTemplate") public JdbcTemplate primaryJdbcTemplate(@Qualifier("primaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; @Bean(name = "secondaryJdbcTemplate") public JdbcTemplate secondaryJdbcTemplate(@Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125;&#125; 测试数据源是否可用 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.List;import java.util.Map;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit4.SpringRunner;import com.alibaba.fastjson.JSON;@RunWith(SpringRunner.class)@SpringBootTestpublic class HikariDataSourceTest &#123; @Autowired private JdbcTemplate primaryJdbcTemplate; @Autowired private JdbcTemplate secondaryJdbcTemplate; @Test public void TestPrimaryDataSourceConnect() &#123; System.err.println("primary data source connection start:"); String sql = "select 1 from dual"; List&lt;Map&lt;String, Object&gt;&gt; result = primaryJdbcTemplate.queryForList(sql); System.out.println("primary data source :\t"+JSON.toJSONString(result)); &#125; @Test public void TestSecondaryDataSourceConnect() &#123; System.err.println("secondary data source connection start:"); String sql = "select 1 from dual"; List&lt;Map&lt;String, Object&gt;&gt; result = secondaryJdbcTemplate.queryForList(sql); System.out.println("secondary data source :\t"+JSON.toJSONString(result)); &#125;&#125; 配置 NamedParameterJdbcTemplate pom.xml依赖、applicaiton.yml数据源配置文件内容与jdbctemplate配置一致 需要修改配置类返回的实例为NamedParameterJdbcTemplate 123456789101112@Bean(name = "secondaryDataSource")@Qualifier(value = "secondaryDataSource")@ConfigurationProperties(prefix = "spring.datasource.secondary")public DataSource secondaryDataSource() &#123; return DataSourceBuilder.create().type(HikariDataSource.class).build();&#125;@Bean(name = "secondaryJdbcTemplate")public NamedParameterJdbcTemplate secondaryJdbcTemplate( @Qualifier("secondaryDataSource") DataSource dataSource) &#123; return new NamedParameterJdbcTemplate(dataSource);&#125; 测试类 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class HikariDataSourceConfigTest &#123; @Autowired private NamedParameterJdbcTemplate secondaryJdbcTemplate; @Test public void TestNamedParameterJdbcTemplate() &#123; System.err.println("namedParameterJdbcTemplate data source connection start:"); String sql = "select 1 from dual"; int result = secondaryJdbcTemplate.queryForObject(sql, new HashMap&lt;&gt;(), Integer.class); System.out.println("TestNamedParameterJdbcTemplate data source:\t" + result); &#125;&#125;]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Hikari</tag>
        <tag>Durid</tag>
        <tag>JDBCTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康威定律与微服务的关系]]></title>
    <url>%2Fblog%2F%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[康威定律与微服务的关系 康威定律与微服务的关系康威第一定律 人类是复杂的社会动物 康威第二定律罗马不是一天建成的，学会先解决首要问题 康威第三定律创建独立的子系统，减少沟通成本 总结前面提到，人类是复杂的社会动物，人与人之间的交流是非常复杂的，当涉及到一个系统时，人们经常选择增加人力去减少复杂性，对于企业来说，该如何处理这样的沟通问题？答案是：分而治之。 看看公司内，一名经理管理的员工一般少于15个，二三线经理管理的员工要更少，因此，大企业通常会将团队拆成一个个小团队或部门减少沟通成本及管理的问题，有一些需要考虑的场景： 创业的项目很好，拿到一大笔风投，再招募更多的程序员 人员太多，需要找几个经理进行管理 康威定律好告诉我们，可以从系统设计中看出组织通信的模式，每个经理要对大系统的某一小部分负责，通过这种方式，它们和更大的系统间沟通有了便捷，因此大的系统也会被拆分成一个个小系统。（微服务可以更好地服务于此) 康威定律与微服务康威定律是如何在半个世纪前就奠定了微服务理论基础的 人与人之间的交流很复杂，每个人的精力都是有限的，因此当问题很复杂需要协调的去解决时，需要将组织划分进而提高沟通效率。 团队成员工作的系统设计依赖于成员之间的沟通，管理人员可以调整划分模式，实现团队之间的不同沟通方式，这也会影响系统的设计。 如果子系统有清晰的外部通信便捷，那么就可以有效的降低通信成本，相应的设计将更加适合和有效。 需要不断优化一个复杂的系统，并容错性和故障恢复率的帮助下进行优化，不要期望大而全面额设计或架构，因为它们的开发以迭代的方式发生。 具体的实践建议： 利用一切手段提高通信效率，如Slack、GitHub、Wiki，且至于相关人员进行沟通，每个人和每个系统必须有明确的职责，在遇到问题时，知道找谁去解决。 在MVP模式下设计一套系统，以迭代的方式优化及验证，并确保系统的弹性。 采用与系统设计相一致的团队，以扁平化和以业务为基准的方式去简化团队，每个小团队之间必须有对应负责的模块，避免模糊的界限，可以在发生问题时定义责任承担者。 精简团队规模，求精而不将就。人员数量的增加在降低效率的同时也在增加投入成本，亚马逊CEO Jeff Bezos的经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。互联网公司的产品团队普遍由7-8人组成(包括前端和后端测试、交互和用户体验师，一人可能身兼数职)。 在查看以下微服务标准时，更能体现微服务与康威定律间的关系： 由分布式服务组成的系统 企业部门的业务线 开发优秀的产品 Smart endpoints and dumb pipes DevOps 容错 快速发展 内容来源：简化自翟永超文章]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 使用自定义 Swagger2]]></title>
    <url>%2FSpringBoot%2FSpringBoot%E6%95%B4%E5%90%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84SwaggerAPI%2F</url>
    <content type="text"><![CDATA[SpringBoot 使用自定义 Swagger2 SpringBoot 整合 Swagger2 | 自定义 swagger-spring-boot-starter 注: 传统的后端开发人员与其他前端或APP端需共同制定API接口文档，Swagger2 将文档变成可更新的在线版本，并且支持在线测试可以提高沟通效率和规范接口说明. 自定义 swagger-spring-boot-starter 的依赖，我所知道的分别有 唐亚峰 12345&lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5-RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring4all社区版 12345&lt;dependency&gt; &lt;groupId&gt;com.spring4all&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.7.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; 前提： 创建 SpringBoot 项目(也可以是SpringMVC项目，配置方法另行百度咯) 第一种：使用 Swagger 原生依赖配置创建SpringBoot应用，添加pom.xml依赖项目创建完成完整依赖如下： 1234567891011121314151617181920212223242526&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 创建 Swagger2配置类 创建API组 注: 本文创建的是API组，故Swagger2Config配置类中有多个。只需要创建单个API组时无需创建两个 Docke @Bean实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.learning.config;import org.springframework.context.annotation.Bean;import org.springframework.web.context.request.async.DeferredResult;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2; /** * Swagger2 配置类, * 不使用@Configuration 注解是可以在 SwaggerApplication.class 中使用@Import注解代替 * @ClassName: Swagger2Config * @Description: TODO * @Created by time on 2018/07/19 */ @Configuration public class Swagger2Config &#123; /** * 第一组 API */ private final String BASEPACKAGE ="com.learning.controller"; private final String BASEPACKAGE2 ="com.learning.group"; /** * 定义单个 API * */ @Bean public Docket createApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName("用户相关API") .genericModelSubstitutes(DeferredResult.class) .useDefaultResponseMessages(false) .forCodeGeneration(true) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(BASEPACKAGE)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("SpringBoot 官方版 Swagger 构建RESTful文档") .description("SpringBoot应用在线调试文档") .termsOfServiceUrl("http://www.baidu.com") .contact(new Contact("author", "http://baidu.com", ""))//名字，地址，邮箱 .version("1.0") .build(); &#125; /** * 定义 API 组 */ @Bean public Docket innerApi() &#123; return new Docket(DocumentationType.SWAGGER_12) .groupName("innerApi") .genericModelSubstitutes(DeferredResult.class) .useDefaultResponseMessages(false) .forCodeGeneration(true) .select() .apis(RequestHandlerSelectors.basePackage(BASEPACKAGE2)) .paths(PathSelectors.any()) .build() .apiInfo(innerApiInfo()); &#125; private ApiInfo innerApiInfo() &#123; return new ApiInfoBuilder() .title("SpringBoot 官方版 Swagger 构建RESTful文档") .description("SpringBoot应用在线调试文档") .termsOfServiceUrl("http://www.baidu.com") .contact(new Contact("程序员DD", "http://blog.didispace.com", "")) .version("1.0") .build(); &#125;&#125; 修改Application.class中增加@Import 12// 增加 Class 类注解@Import(value= &#123;Swagger2Config.class&#125;) 创建带有Swagger注解实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.learning.entity.vo;import java.io.Serializable;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * 用户视图实体类 * @ClassName: UserVO * @Description: TODO * @Created by time on 2018/07/18 */@ApiModel(value = "用户实体类")public class UserVO implements Serializable &#123; private static final long serialVersionUID = 1L; @ApiModelProperty(value = "账户", required = true) private String account; @ApiModelProperty(value = "姓名", required = true) private String name; @ApiModelProperty(value = "昵称", required = true) private String nickName; public UserVO() &#123; &#125; public UserVO(String account, String name, String nickName) &#123; this.name = name; this.nickName = nickName; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; UserVO other = (UserVO) obj; if (account == null) &#123; if (other.account != null) return false; &#125; else if (!account.equals(other.account)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; if (nickName == null) &#123; if (other.nickName != null) return false; &#125; else if (!nickName.equals(other.nickName)) return false; return true; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getNickName() &#123; return nickName; &#125; public void setNickName(String nickName) &#123; this.nickName = nickName; &#125; @Override public String toString() &#123; return "UserVO [account=" + account + ", name=" + name + ", nickName=" + nickName + "]"; &#125;&#125; 创建带有Swagger注解的controller另一个Controller与下面的一致，就不贴代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.learning.controller;import java.util.ArrayList;import java.util.List;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import com.learning.entity.vo.UserVO;import io.swagger.annotations.Api;import io.swagger.annotations.ApiImplicitParam;import io.swagger.annotations.ApiImplicitParams;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiResponse;import io.swagger.annotations.ApiResponses;/** * * @ClassName: UserController * @Description: 用户管理 * @author time * @date 2018/11/20 */@RestController@RequestMapping(value = "/user")@Api(value = "UserManager", tags = &#123; "用户管理" &#125;)public class UserController &#123; /** * * @Title: getUser * @Description: 获取用户list * @param userName * @param password * @return * List&lt;UserVO&gt; */ @ApiOperation("获取用户相关信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "userName", dataType = "String", required = true, value = "用户的姓名", defaultValue = "张飞"), @ApiImplicitParam(paramType = "query", name = "password", dataType = "String", required = true, value = "用户的密码", defaultValue = "wangga") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "/getUser", method = RequestMethod.POST) public List&lt;UserVO&gt; getUser(@RequestParam("userName") String userName, @RequestParam("password") String password) &#123; System.out.print("logger.in:getUser---------"); UserVO info = new UserVO("test01", "测试账户一", "士兵"); UserVO info2 = new UserVO("test02", "测试账户二", "将领"); UserVO info3 = new UserVO("test03", "测试账户三", "元帅"); List&lt;UserVO&gt; list = new ArrayList&lt;&gt;(); list.add(info); list.add(info2); list.add(info3); return list; &#125; /** * * @Title: queryUserInfo * @Description: 查询用户详细信息 * @param id * @return * Object */ @ApiOperation(value = "查询用户详细信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者页面跳转路径错误") &#125;) @RequestMapping(value = "queryUserInfo/&#123;id&#125;", method = RequestMethod.GET) public Object queryUserInfo(@PathVariable("id") Long id) &#123; UserVO info = new UserVO("士兵" + id, "00" + id, "张三" + id); return info; &#125; /** * * @Title: modifyUserInfo * @Description: 修改用户信息 * @param id * @param UserVO * @return * Object */ @ApiOperation(value = "修改用户信息") @ApiImplicitParams(&#123; @ApiImplicitParam(paramType = "query", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1"), @ApiImplicitParam(paramType = "body", name = "User", dataType = "User", value = "修改的用户信息") &#125;) @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径没有或者跳转页面错误") &#125;) @RequestMapping(value = "modifyUserInfo", method = RequestMethod.POST) public Object modifyUserInfo(@RequestParam("id") Long id, @RequestBody UserVO UserVO) &#123; System.out.print("-----------modifyUserInfo:" + UserVO.toString()); UserVO.setAccount(++id + ""); return UserVO; &#125; /** * * @Title: delUserById * @Description: 删除用户信息 * @param id * @return * String */ @ApiOperation(value = "删除用户信息") @ApiImplicitParam(paramType = "path", name = "id", dataType = "long", required = true, value = "用户id", defaultValue = "1") @ApiResponses(&#123; @ApiResponse(code = 400, message = "请求参数错误"), @ApiResponse(code = 404, message = "请求路径异常,或者跳转页面错误") &#125;) @RequestMapping(value = "delUserById/&#123;id&#125;", method = RequestMethod.DELETE) public String delUserById(@PathVariable(value = "id", required = true) Long id) &#123; System.err.print("-----del"); return "success"; &#125;&#125; RESTful接口 Swagger 注解说明 @Api： 描述Controller value：文档页面不显示 tags:数组类型（{“…”,”…”}）；显示 @ApiIgnore： 忽略该Controller，指不对当前类做扫描 @ApiOperation： 描述Controller类中的method接口 @ApiParam： 单个参数描述，与@ApiImplicitParam不同的是，他是写在参数左侧的。如（@ApiParam(name = &quot;username&quot;,value = &quot;用户名&quot;) String username） @ApiModel： 描述POJO对象 @ApiProperty： 描述POJO对象中的属性值 @ApiImplicitParam： 描述单个入参信息 @ApiImplicitParams： 描述多个入参信息 @ApiResponse： 描述单个出参信息 @ApiResponses： 描述多个出参信息 @ApiError： 接口错误所返回的信息 第二种: 使用自定义 Swagger 依赖配置创建SpringBoot项目 添加pom.xml中的依赖 注: 替换上述的swagger dependency为下方依赖即可** 12345&lt;dependency&gt; &lt;groupId&gt;com.battcn&lt;/groupId&gt; &lt;artifactId&gt;swagger-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.5-RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改application.yml配置文件，定义在线接口显示内容 123456789spring: swagger: base-package: com.learning.controller enabled: true title: Swagger API文档说明 description: 在线调试文档 version: 1.0 contact: name: Time Machine 修改主函数Application.class，添加@EnableSwagger2Doc注解 注: 只需要按照Swagger的注解创建controller与entity即可，无需SwaggerConfig配置类]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Swagger2</tag>
      </tags>
  </entry>
</search>
